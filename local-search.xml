<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/24/object-oriented-programming/"/>
    <url>/2022/05/24/object-oriented-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>现在软件开发当中，面向对象编程已经成为一个黄金标准，那究竟什么是面向对象？对于这个问题有很多回答，一种回答是 “数据与函数的组合”，另一种回答是对真实世界进行建模的方式，还有另外一种回答是涉及到封装，继承，多态，也就是说面向对象是这三项的组合。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装这个特性因为在面向对象编程用的多了，导致不少人经常会认为它就是面向对象的一部分，其实不是这样的。C 语言中的 struct 结构体就是支持完整的封装，在引入 point.h 文件的程序中是没有 Point 这个结构体的内部访问权限的，只能调用 makePoint 和 distance 函数，但是不清楚函数内部的具体实现细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// point.h </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span>;<br><br><span class="hljs-comment">// point.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-comment">// 构造 Point</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span> &#123;<br>    <span class="hljs-comment">// 计算距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 作为一个面向对象编程语言，在封装的完整性反而不如 C 语言。稍微改造一下上面的 Point 例子，虽然编译器会禁止外部 x,y 这 2 个变量的范围，但是调用者都知道了它们的存在。不过 C++ 在语法层面引入了 public，private，protected 这些访问控制的关键词，在一定程度上维护了封装性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一个面向对象编程语言 Java 则彻底抛弃了头文件和实现文件分离的编程方式，这也是破坏封装完整性的表现，因为我们无法区分一个类的声明和定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>      <span class="hljs-comment">// 构造 Point</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(Point p1, Point p2)</span> &#123;<br>      <span class="hljs-comment">// 计算距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们基本可以得出强封装并不是面向对象编程的必要条件。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的主要作用是让程序员可以在某个作用域内对外部定义的一组变量与函数进行覆盖。但是实际上 C 语言也可以做到，不仅仅是面向对象编程语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// namedPoint.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span>;</span><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// namedPoint.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>    <span class="hljs-type">char</span>* name;<br>&#125;<br><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-comment">// 构造 NamedPoint</span><br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">orgin</span> =</span> makeNamedPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">upperRight</span> =</span> makeNamedPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;upperRight&quot;</span>);<br><br>distance((<span class="hljs-keyword">struct</span> Point *)orgin, (<span class="hljs-keyword">struct</span> Point *)upperRight);<br></code></pre></td></tr></table></figure><p>看 main.c 里面的代码，因为 NamedPoint 和 Point 结构体的前 2 个成员顺序一致，所以 NamedPoint 可以被伪装成 Point 来使用，在程序中必须显式把 NamedPoint 强制转换为 Point 类型。通过上面的案例，我们可以了解到继承的特性在面向对象被发明之前就已经在使用了。但是在面向对象编程语言中，这种向上的类型转换是隐式，虽然面向对象编程在继承性上没有突破，但是至少在数据类型的转换上提供了便利。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象编程涉及到封装，继承，多态这 3 个特性，前面提到了封装和继承都不是面向对象编程独有特性，那么多态是不是面向对象编程独有的呢？答案也是否定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getchar()) != EOF) &#123;<br>        <span class="hljs-built_in">putchar</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getchar() 负责从 STDIN 读数据，putchar() 负责往 STDOUT 写数据，那么 STDIN 和 STDOUT 又具体表示哪些设备呢？显然 getchar 和 putchar 这类函数就具有多态性，因为他们的行为依赖于 STDIN 和 STDOUT 的具体实现。</p><p>以 Unix 为例，每个 IO 设备的驱动程序都要提供 open,close,read,write,seek 这 5 个标准函数实现。在 FILE 数据结构体中也包含了这 5 个标准函数对于的函数指针，这些函数指针用于指向 IO 设备驱动提供标准函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FILE 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br>    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode)<br>    <span class="hljs-type">void</span> (*close)();<br>    <span class="hljs-type">int</span> (*read)();<br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br>    <span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode);<br>&#125;<br><br><span class="hljs-comment">// 设备驱动程序实现</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// open 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*close)() &#123;<br>    <span class="hljs-comment">// close 实现</span><br>&#125;<br><span class="hljs-type">int</span> (*read)() &#123;<br>    <span class="hljs-comment">// read 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>) &#123;<br>    <span class="hljs-comment">// write 实现</span><br>&#125;<br><br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// seek 实现</span><br>&#125;<br><br><span class="hljs-comment">//getchar 函数的大致实现</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span>* <span class="hljs-title">STDIN</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> STDIN-&gt;read()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的程序中看，getchar 函数本质上是使用了 STDIN 来调用保存在 FILE 结构中的 read 函数指针所指向的函数实现。说到底，多态其实就是函数指针的一种应用。用函数指针实现多态的最大问题就是函数指针的危险性了，因为函数指针的调用依赖于程序员的约定，程序员必须严格遵守规则按照函数指针的类型来初始化函数指针，并严格按照函数指针的类型来使用函数指针。在编程中可以确定计算机能够遵守规则，但是无法确定程序员会遵守规则。</p><p>同继承一样，面向对象编程本质上还是没有在多态上进行创新，面向对象编程语言为程序员消除了人工遵守规则的必要，它让多态变得更安全，更便于使用了。<strong>结构化编程对程序控制权的直接转移进行了限制和规范，而面向对象编程其实是对程序的间接控制权的转移进行了限制，具体一些就是原来多态的调用只要函数类型一致就可以使用函数指针进行调用，而不需要有什么其他额外关系，但是现在面向对象编程在这个基础上加上了一些数据类型的限制。</strong></p><h3 id="带来的价值"><a href="#带来的价值" class="headerlink" title="带来的价值"></a>带来的价值</h3><ul><li>插件式架构</li></ul><p>Unix 系统将 IO 设备设计成插件式架构，随后在多个操作系统都有应用，即使知道多态有如此多的优点，但是碍于函数指针是一项及其危险的技术，大部分程序员还是不敢将插件式架构引入系统。但是面向对象编程的出现使得插件式架构可以安全地被应用在任何地方。</p><ul><li>依赖反转</li></ul><p>在安全和便利的多态技术出现之前，软件的典型调用树是这样的，HightLayer 模块要调用 MiddleLayer 模块，HightLayer 模块必须要依赖 MiddleLayer 模块 ，程序的源代码依赖不可避免的需要跟随程序的控制流。这让我们这些程序员在软件架构上没有什么其他多余的选择，软件的系统行为决定了程序的控制流，而控制流则决定了源代码依赖关系。</p><p>依赖关系和控制关系如下图所示，实线表示源代码依赖关系，虚线表示控制流关系。</p><img src="/2022/05/24/object-oriented-programming/Untitled.png" class="" title="This is an example image"><br><p>现在利用面向对象编程语言提供的安全便利的多态实线，无论我们面对怎么样的源代码依赖，我们都可以将其反转（源代码依赖方向和控制流方向相反）。如下图所示，模块 HightLayer 调用模块 MiddleLayer 中的 function 函数，这里的调用在是通过源代码界别的 interface 来实现的，在程序的实际运行过程中，interface 这个概念是不存在的，HightLayer 会直接调用 MiddleLayer 中的 function 函数。</p><img src="/2022/05/24/object-oriented-programming/Untitled01.png" class="" title="This is an example image"><br><p>延伸一下，这种能力在实际的软件架构设计中有什么作用呢？看下图，我们可以让用户界面和数据库都依赖业务逻辑，业务逻辑不需要引入用户界面和数据库的依赖，这样用户界面和数据库就成为业务逻辑的插件。这样一来，用户界面，业务逻辑，数据库就可以成为 3 个独立的组件，可以单独编译和部署，同时用户界面或者数据库的修改就不会对业务逻辑产生任何的影响。进一步说，当某个组件需要修改是，仅仅需要重新编译和部署该组件，不需要更改其他的组件，这就是独立部署能力。再进一步说，如果组件可以独立部署，那么就意味着组件可以由不同的团队并行开发，这就是架构的独立开发能力，也是架构和团队组织互相影响。</p><img src="/2022/05/24/object-oriented-programming/Untitled02.png" class="" title="This is an example image"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">https://zh.wikipedia.org/wiki/面向对象程序设计</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS缓存框架－PINCache 解读</title>
    <link href="/2022/05/24/reading-source-code-of-PINCache/"/>
    <url>/2022/05/24/reading-source-code-of-PINCache/</url>
    
    <content type="html"><![CDATA[<p>在项目中总是需要缓存一些网络请求数据以减轻服务器压力，业内也有许多优秀的开源的解决方案。通常的缓存方案都是由内存缓存和磁盘缓存组成的，内存缓存速度快容量小，磁盘缓存容量大速度慢可持久化。常见的内存缓存有NSCache、<a href="https://github.com/tumblr/TMCache">TMMemoryCache</a>、<a href="https://github.com/pinterest/PINCache">PINMemoryCache</a>、<a href="https://github.com/ibireme/YYCache">YYMemoryCache</a>。常见的磁盘缓存有TMDiskCache、PINDiskCache、SDWebImage。这次解读先从<a href="https://github.com/pinterest/PINCache">PINCache</a>这个优秀的开源项目开始。PINCache项目是在Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的基于TMCache的一个内存缓存，修复了TMCache存在的性能和死锁问题，可以说是有了一个较大的提升。</p><h3 id="PINCache概论"><a href="#PINCache概论" class="headerlink" title="PINCache概论"></a>PINCache概论</h3><p>PINCache是多线程安全的，使用键值对来保存数据。PINCache内部包含了2个类似的对象属性，一个是内存缓存PINMemoryCache，另一个是磁盘缓存PINDiskCache。PINCache本身并没有过多的做处理缓存的具体工作，而是全部交给它内部的2个对象属性来实现，它只是对外提供了一些同步或者异步接口。在iOS中，当App收到内存警告或者进入后台的时候，PINCache能够清理掉所有的内存缓存。</p><h3 id="PINCache使用"><a href="#PINCache使用" class="headerlink" title="PINCache使用"></a>PINCache使用</h3><p>采用PINCache项目的Demo来说明，这个是从服务器加载数据，再缓存下来，继而做业务逻辑处理，如果下次还需要同样的数据，要是缓存里面还有这个数据的话，那么就不需要再次发起网络请求了，而是直接使用这个数据。<strong>PINCache除了可以按键取值、按键存值、按键删值之外，还可以移除某个日期之前的缓存数据、删除所有缓存、限制缓存大小，限制缓存对象的存活时间等</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP">[[PINCache sharedCache] objectForKey:[url absoluteString]  block:^(PINCache *cache, NSString *key, id object) &#123;<br>                                     <span class="hljs-keyword">if</span> (object) &#123;<br>                                      <span class="hljs-comment">//有缓存，在这里做业务逻辑处理</span><br>                                         <span class="hljs-keyword">return</span>;<br>                                     &#125; <br>                                     <span class="hljs-comment">//没有缓存，那么去服务器加载数据，存入缓存，做业务逻辑处理</span><br>                                    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;cache miss, requesting %@&quot;</span>, url);<br>                                   [[PINCache sharedCache] setObject:data forKey:[url absoluteString]];<br>   &#125;];<br></code></pre></td></tr></table></figure><h3 id="PINCache结构"><a href="#PINCache结构" class="headerlink" title="PINCache结构"></a>PINCache结构</h3><p><img src="http://upload-images.jianshu.io/upload_images/656644-39fadea3c4a0f457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PINCache"></p><p>PINCache的内部结构比较简单，最核心的就是2个缓存实现类，这里先给出一个大概的结构，让大家可以有个了解，下面就来讲讲详细的接口。</p><h3 id="PINCache接口"><a href="#PINCache接口" class="headerlink" title="PINCache接口"></a>PINCache接口</h3><p><img src="http://upload-images.jianshu.io/upload_images/656644-3c6028a9ac848e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PINCache属性"><br><strong>核心属性</strong><br>1.name是PINCache的名字<br>2.concurrentQueue是一个用来执行异步任务的并行队列<br>3.磁盘缓存<br>4.内存缓存</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-8c8fa4521be1ce54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化方法"><br><strong>初始化方法</strong><br>1.单例对象<br>2.使用名字初始化<br>3.使用名字和缓存路径来初始化</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-dff34434c7ae9bc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步方法"><br><strong>异步方法</strong><br>多数开源缓存框架的方法也就这么几个，大多类似。<br>1.异步按键取值，之后执行Block<br>2.异步按键设值，之后执行Block<br>3.异步按键删值，之后执行Block<br>4.异步删除某个时间之后没有使用的缓存，之后执行Block<br>5.异步删除所有缓存，之后执行Block</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-a50cb8240b53de3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="同步方法"><br><strong>同步方法</strong><br>这里的同步方法与异步方法的区别除了方法是否立即返回之外，还有一个区别就是异步方法可以传入一个Block参数<br>1.同步按键取值<br>2.同步按键设值<br>3.同步按键删值<br>4.同步删除某个时间之后没有使用的缓存<br>5.同步删除所有缓存</p><p><strong>PINCache主要是包装PINDiskCache和PINMemoryCache的功能，具体的功能实现是交给对应的对象去实现</strong>。</p><p>###PINDiskCache解析<br>PINDiskCache涉及到磁盘缓存的具体实现，这里就不再一一列举所有的属性和方法了（具体的内容可以查看PINCache的文档），主要挑重要的取值方法，设值方法，还有删除方法来讲。</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-7e4cd4c89e17a522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="semaphore"><br>PINDiskCache使用semaphore来做线程同步控制的，在写磁盘缓存的时候给diskCache对象加锁，写完之后解锁。在读磁盘缓存的时候也会给diskCache对象加锁，读完之后解锁。<em>读写过程都会加锁</em>。</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-688052b180a4a4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="写入磁盘缓存"><br>写磁盘缓存的大概步骤是这样的，只是讲解一些思路，具体的详细信息需要大家查看源代码。<br>1.判断给的键值是否为空<br>2.加锁，保证多线程安全<br>3.把数据写入磁盘<br>4.更新缓存信息（包括但不限于保存磁盘缓存的总容量）<br>5.判断现在的磁盘缓存容量是否超过容量限制，若超出，按照缓存时间策略来删除对应的缓存，没有超过则不做操作<br>6.解锁，让其他线程可以进入操作</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-7a6e6653b60aa094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="读取磁盘缓存"><br>读磁盘缓存相对简单一些，就是找到文件，然后读取。<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把数据从磁盘读到内存对象中<br>4.解锁，让其他线程可以进入操作</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-03cb11f73f486141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除缓存"><br>移除缓存就是文件的删除操作<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把文件从磁盘中删除<br>4.解锁，让其他线程可以进入操作</p><h3 id="PINMemoryCache解析"><a href="#PINMemoryCache解析" class="headerlink" title="PINMemoryCache解析"></a>PINMemoryCache解析</h3><p>内存缓存相比磁盘缓存多了一个App收到内存警告或者App进入后台的时候清理缓存的功能。内存缓存的数据保存在字典里面。</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-f432fd27bb45603b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收到通知，清理内存缓存"><br>1.收到系统内存警告通知，清理内存缓存<br>2.收到App进入后台的系统通知,清理内存缓存</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-dc5a0f07a390d88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存缓存设值"><br>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.将数据存到缓存池，也就是字典里面<br>4.更新缓存对应的数据<br>5.解锁<br>6.判断内存缓存容量是否超出，超过删除部分</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-5c1eba27b475d3e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存缓存取值"><br>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.从字典里面取对应值<br>4.更新缓存对应的数据<br>5.解锁</p><p><img src="http://upload-images.jianshu.io/upload_images/656644-b8a9559c6c521775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存缓存删除"></p><p>1.取出内存缓存值<br>2.加锁<br>3.更新内存缓存容量<br>4.删除内存缓存<br>5.更新内存缓存对应的数据<br>6.解锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存一般🈶️2个部分组成，一个是内存缓存，一个是磁盘缓存。<br>1.对于<strong>内存缓存</strong>来说，一般使用字典来作为数据的缓存池，配合一个保存每个内存缓存数据的缓存时间的字典，一个保存每个内存缓存数据的缓存容量的字典，一个保存内存缓存总容量的变量。对于增删改查操作，基本也都是围绕着字典来的，需要重点注意的就是在这些个操作过程的多线程安全问题，还有同步和异步访问方法，以及异步方法中的Block参数的循环引用问题。<br>2.对于<strong>磁盘缓存</strong>来说，使用文件系统来保存缓存数据，配合设置文件的参数，比如文件的修改日期（访问一次即修改一次），文件的大小来管理着这个缓存数据。对缓存数据的增删改查，也就是转化成为对文件的读写删除操作。<br>3.不管是内存缓存还是磁盘缓存，在删除超过限制容量的缓存的时候总是有一个同样的策略。有优先删除缓存最久，最少使用的策略，也有优先删除，容量最大，最少使用的策略。没有什么最好的策略，只有适合你业务产品的策略。<br>最后感谢<a href="https://github.com/pinterest">PINCache作者</a>给我们提供了一个优秀的缓存开源框架。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://blog.ibireme.com/2015/10/26/yycache/">http://blog.ibireme.com/2015/10/26/yycache/</a><br><a href="https://github.com/pinterest/PINCache">https://github.com/pinterest/PINCache</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构化编程</title>
    <link href="/2022/05/24/procedural-programming/"/>
    <url>/2022/05/24/procedural-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h1><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>计算机科学家 dijkstra 认为 goto 语句的无限制跳转会损坏程序的整体结构，应该使用 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句来替代跳转语句。简单总结起来，结构化编程对程序控制权的直接转移进行了限制和规范。</p><h3 id="结构化编程的诞生"><a href="#结构化编程的诞生" class="headerlink" title="结构化编程的诞生"></a>结构化编程的诞生</h3><p>dijkstra 提出为了能够证明程序的正确性，就必须把程序模块递归拆分成更小的，可以被证明的单元，dijkstra 经过研究发现，goto 语句可能会导致大模块无法被进一步拆分成更小的，可被证明的单元，同时 goto 语句的用法与 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句的作用又没有明显的区别，所以 goto 是可以被替代的。</p><p>另外一个证明是代码中使用了顺序结构，分支结构，循环结构，那么代码是一定可以被拆解成更小的，可证明的单元，而且程序员可以用顺序结构，分支结构，循环结构这 3 类结构构造出任何程序。到这里有个发现很重要，构建可被证明的模块所需要的控制单元和构建所有程序所需要的控制单元的最小集合是一样的，结构化编程就这样诞生了！！！</p><p>结构化编程范式可以将模块递归降解成可以被推导的单元，这意味着可以把模块按功能进行分解，更进一步说可以把一个大型问题拆分成一系列高级函数组合，而高级函数又可以进一步被拆分为一系列低级函数，每个被拆分出来的函数都可以使用结构化编程范式来构造程序。然后再编写相关的测试来证明这些函数程序是错误的，如果无法证明这些函数代码是错误的，那么我们就可以直接认为这些函数代码是正确的，推导到整个程序是正确的。</p><h3 id="结构化编程的价值"><a href="#结构化编程的价值" class="headerlink" title="结构化编程的价值"></a>结构化编程的价值</h3><p>结构化编程范式中最有价值的点赋予了我们创造可证伪程序单元的能力。延伸到架构设计领域，功能性拆解仍然是验证程序正确性的最佳实践之一。</p><p>我近几年来都是在接触代码重构相关的事情，项目涉及的业务多种多样，但是项目都存在一个明显的问题就是功能模块互相依赖的问题，因为依赖太多导致变更带来非常多的不确定性，同时变更带来的测试成本大无法接受的地步。另外功能模块互相依赖还会带来一个明显部署问题，由于互相依赖，模块无法单独部署，需要所有的模块一起部署。随之而来的还有编译问题，互相依赖过多，一旦被依赖方发生变动，所有的依赖方都必须重新编译，这个最明显的是很多项目中的 common 模块。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://book.douban.com/subject/30333919/">架构整洁之道</a></p><p>2、<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/过程式编程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈软件架构的价值</title>
    <link href="/2022/05/23/talking-about-the-value-of-architecture/"/>
    <url>/2022/05/23/talking-about-the-value-of-architecture/</url>
    
    <content type="html"><![CDATA[<p>一个业务功能，新手和高手同样都可以实现，为什么还要招聘高手呢？在项目预算支持的情况下，通常会招聘更多有经验的程序员来进行开发。</p><p>软件行业中，确实是普遍存在上述的这类现象。 调试并实现一个业务功能并不需要非常高深的知识，甚至一名初入行的实习生都可以做到，将需求文档转换为能够实际上线运行的代码也不会多难，实习生写出来的代码可能不够优雅，但是确实能够正常工作。</p><p>在系统运作一段时间之后，新手可能需要 007 疯狂加班来实现需求。高手因为丰富的架构设计经验，提前做好软件架构设计，系统能够适应各类变化，新需求只需要很少的时间就能够上线。</p><h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>回想我自己的从业经历，确实经历不少这样的场景。某个软件历史悠久，各个组件互相依赖，到处充满了垃圾代码。即使是小改动，也是牵一发而动全身，让整个项目的产品，设计，开发，测试人员充满痛苦。每逢这个时候就会臆想，这个软件要是采用了好的架构设计，可以大大节省软件的开发和测试成本，每次变更都能控制最小影响范围，用最小的成本满足功能性需求。</p><p>好的架构设计具有这么大的魅力，那究竟什么才是软件架构？类比建筑，软件架构就是软件的组织架构，它关注组件，类，函数，模块，层级的设计。</p><h3 id="软件架构有什么用"><a href="#软件架构有什么用" class="headerlink" title="软件架构有什么用"></a>软件架构有什么用</h3><p>正如前面所提，它的目标就是用最小的人力成本来满足构建和维护系统的需求。软件架构具有 2 个方面的价值，一个价值是架构价值，一个价值是行为价值。</p><p>行为价值比较直观，就是程序员把需求文档转换为上线运行的代码，给用户创造价值，同时获取利润。</p><p>对于架构价值的理解可能比较抽象，提一些具体场景，正常来说第一个版本的系统通常都是没有经过什么设计，匆匆忙忙被构建起来。后面业务有了一定的发展，为了加快发布的速度，团队开始招聘新人，同时迫于业务压力，对代码质量提升和软件架构设计存在长期忽视。团队经常加班，拼命工作，团队中的个人不管投入多少个人时间，救了多少火，产出始终上不去。团队的时间大部分都消耗在对现有系统的修复上，新功能的实现投入时间并没有多少，陷入恶性循环。软件架构的价值之一就是要解决类似这个场景的问题，良好的软件架构设计能够避免系统陷入混乱，让软件容易被修改，新增需求或者变更需求，随之所需的软件变更可以简单而方便的实现。</p><h3 id="坚持软件架构的价值"><a href="#坚持软件架构的价值" class="headerlink" title="坚持软件架构的价值"></a>坚持软件架构的价值</h3><p>软件架构设计是一个重要但不紧急的事情。在业务迭代中，技术团队经常容易陷入不重要但紧急的需求旋涡中。对于技术 leader 来说，就是要坚持架构设计的价值，同时也要说服其他人相信架构设计的价值，这也是技术 leader 的价值之一， 只有这样才有可能在紧凑的业务迭代周期中预留部分架构设计和代码 review 时间，以尽量延长软件的生命时间，降低软件的变更成本，让技术团队能够更愉悦的工作。</p><p>参考</p><ol><li><a href="https://book.douban.com/subject/30333919/">https://book.douban.com/subject/30333919/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
