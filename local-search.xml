<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/24/object-oriented-programming/"/>
    <url>/2022/05/24/object-oriented-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>现在软件开发当中，面向对象编程已经成为一个黄金标准，那究竟什么是面向对象？对于这个问题有很多回答，一种回答是 “数据与函数的组合”，另一种回答是对真实世界进行建模的方式，还有另外一种回答是涉及到封装，继承，多态，也就是说面向对象是这三项的组合。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装这个特性因为在面向对象编程用的多了，导致不少人经常会认为它就是面向对象的一部分，其实不是这样的。C 语言中的 struct 结构体就是支持完整的封装，在引入 point.h 文件的程序中是没有 Point 这个结构体的内部访问权限的，只能调用 makePoint 和 distance 函数，但是不清楚函数内部的具体实现细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// point.h </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span>;<br><br><span class="hljs-comment">// point.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-comment">// 构造 Point</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span> &#123;<br>    <span class="hljs-comment">// 计算距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 作为一个面向对象编程语言，在封装的完整性反而不如 C 语言。稍微改造一下上面的 Point 例子，虽然编译器会禁止外部 x,y 这 2 个变量的范围，但是调用者都知道了它们的存在。不过 C++ 在语法层面引入了 public，private，protected 这些访问控制的关键词，在一定程度上维护了封装性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一个面向对象编程语言 Java 则彻底抛弃了头文件和实现文件分离的编程方式，这也是破坏封装完整性的表现，因为我们无法区分一个类的声明和定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>      <span class="hljs-comment">// 构造 Point</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(Point p1, Point p2)</span> &#123;<br>      <span class="hljs-comment">// 计算距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们基本可以得出强封装并不是面向对象编程的必要条件。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的主要作用是让程序员可以在某个作用域内对外部定义的一组变量与函数进行覆盖。但是实际上 C 语言也可以做到，不仅仅是面向对象编程语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// namedPoint.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span>;</span><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// namedPoint.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>    <span class="hljs-type">char</span>* name;<br>&#125;<br><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-comment">// 构造 NamedPoint</span><br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">orgin</span> =</span> makeNamedPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">upperRight</span> =</span> makeNamedPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;upperRight&quot;</span>);<br><br>distance((<span class="hljs-keyword">struct</span> Point *)orgin, (<span class="hljs-keyword">struct</span> Point *)upperRight);<br></code></pre></td></tr></table></figure><p>看 main.c 里面的代码，因为 NamedPoint 和 Point 结构体的前 2 个成员顺序一致，所以 NamedPoint 可以被伪装成 Point 来使用，在程序中必须显式把 NamedPoint 强制转换为 Point 类型。通过上面的案例，我们可以了解到继承的特性在面向对象被发明之前就已经在使用了。但是在面向对象编程语言中，这种向上的类型转换是隐式，虽然面向对象编程在继承性上没有突破，但是至少在数据类型的转换上提供了便利。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象编程涉及到封装，继承，多态这 3 个特性，前面提到了封装和继承都不是面向对象编程独有特性，那么多态是不是面向对象编程独有的呢？答案也是否定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getchar()) != EOF) &#123;<br>        <span class="hljs-built_in">putchar</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getchar() 负责从 STDIN 读数据，putchar() 负责往 STDOUT 写数据，那么 STDIN 和 STDOUT 又具体表示哪些设备呢？显然 getchar 和 putchar 这类函数就具有多态性，因为他们的行为依赖于 STDIN 和 STDOUT 的具体实现。</p><p>以 Unix 为例，每个 IO 设备的驱动程序都要提供 open,close,read,write,seek 这 5 个标准函数实现。在 FILE 数据结构体中也包含了这 5 个标准函数对于的函数指针，这些函数指针用于指向 IO 设备驱动提供标准函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FILE 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br>    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode)<br>    <span class="hljs-type">void</span> (*close)();<br>    <span class="hljs-type">int</span> (*read)();<br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br>    <span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode);<br>&#125;<br><br><span class="hljs-comment">// 设备驱动程序实现</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// open 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*close)() &#123;<br>    <span class="hljs-comment">// close 实现</span><br>&#125;<br><span class="hljs-type">int</span> (*read)() &#123;<br>    <span class="hljs-comment">// read 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>) &#123;<br>    <span class="hljs-comment">// write 实现</span><br>&#125;<br><br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// seek 实现</span><br>&#125;<br><br><span class="hljs-comment">//getchar 函数的大致实现</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span>* <span class="hljs-title">STDIN</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> STDIN-&gt;read()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的程序中看，getchar 函数本质上是使用了 STDIN 来调用保存在 FILE 结构中的 read 函数指针所指向的函数实现。说到底，多态其实就是函数指针的一种应用。用函数指针实现多态的最大问题就是函数指针的危险性了，因为函数指针的调用依赖于程序员的约定，程序员必须严格遵守规则按照函数指针的类型来初始化函数指针，并严格按照函数指针的类型来使用函数指针。在编程中可以确定计算机能够遵守规则，但是无法确定程序员会遵守规则。</p><p>同继承一样，面向对象编程本质上还是没有在多态上进行创新，面向对象编程语言为程序员消除了人工遵守规则的必要，它让多态变得更安全，更便于使用了。<strong>结构化编程对程序控制权的直接转移进行了限制和规范，而面向对象编程其实是对程序的间接控制权的转移进行了限制，具体一些就是原来多态的调用只要函数类型一致就可以使用函数指针进行调用，而不需要有什么其他额外关系，但是现在面向对象编程在这个基础上加上了一些数据类型的限制。</strong></p><h3 id="带来的价值"><a href="#带来的价值" class="headerlink" title="带来的价值"></a>带来的价值</h3><ul><li>插件式架构</li></ul><p>Unix 系统将 IO 设备设计成插件式架构，随后在多个操作系统都有应用，即使知道多态有如此多的优点，但是碍于函数指针是一项及其危险的技术，大部分程序员还是不敢将插件式架构引入系统。但是面向对象编程的出现使得插件式架构可以安全地被应用在任何地方。</p><ul><li>依赖反转</li></ul><p>在安全和便利的多态技术出现之前，软件的典型调用树是这样的，HightLayer 模块要调用 MiddleLayer 模块，HightLayer 模块必须要依赖 MiddleLayer 模块 ，程序的源代码依赖不可避免的需要跟随程序的控制流。这让我们这些程序员在软件架构上没有什么其他多余的选择，软件的系统行为决定了程序的控制流，而控制流则决定了源代码依赖关系。</p><p>依赖关系和控制关系如下图所示，实线表示源代码依赖关系，虚线表示控制流关系。</p><img src="/2022/05/24/object-oriented-programming/Untitled.png" class="" title="This is an example image"><p>现在利用面向对象编程语言提供的安全便利的多态实线，无论我们面对怎么样的源代码依赖，我们都可以将其反转（源代码依赖方向和控制流方向相反）。如下图所示，模块 HightLayer 调用模块 MiddleLayer 中的 function 函数，这里的调用在是通过源代码界别的 interface 来实现的，在程序的实际运行过程中，interface 这个概念是不存在的，HightLayer 会直接调用 MiddleLayer 中的 function 函数。</p><img src="/2022/05/24/object-oriented-programming/Untitled01.png" class="" title="This is an example image"><p>延伸一下，这种能力在实际的软件架构设计中有什么作用呢？看下图，我们可以让用户界面和数据库都依赖业务逻辑，业务逻辑不需要引入用户界面和数据库的依赖，这样用户界面和数据库就成为业务逻辑的插件。这样一来，用户界面，业务逻辑，数据库就可以成为 3 个独立的组件，可以单独编译和部署，同时用户界面或者数据库的修改就不会对业务逻辑产生任何的影响。进一步说，当某个组件需要修改是，仅仅需要重新编译和部署该组件，不需要更改其他的组件，这就是独立部署能力。再进一步说，如果组件可以独立部署，那么就意味着组件可以由不同的团队并行开发，这就是架构的独立开发能力，也是架构和团队组织互相影响。</p><img src="/2022/05/24/object-oriented-programming/Untitled02.png" class="" title="This is an example image"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">https://zh.wikipedia.org/wiki/面向对象程序设计</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构化编程</title>
    <link href="/2022/05/24/procedural-programming/"/>
    <url>/2022/05/24/procedural-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h1><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>计算机科学家 dijkstra 认为 goto 语句的无限制跳转会损坏程序的整体结构，应该使用 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句来替代跳转语句。简单总结起来，结构化编程对程序控制权的直接转移进行了限制和规范。</p><h3 id="结构化编程的诞生"><a href="#结构化编程的诞生" class="headerlink" title="结构化编程的诞生"></a>结构化编程的诞生</h3><p>dijkstra 提出为了能够证明程序的正确性，就必须把程序模块递归拆分成更小的，可以被证明的单元，dijkstra 经过研究发现，goto 语句可能会导致大模块无法被进一步拆分成更小的，可被证明的单元，同时 goto 语句的用法与 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句的作用又没有明显的区别，所以 goto 是可以被替代的。</p><p>另外一个证明是代码中使用了顺序结构，分支结构，循环结构，那么代码是一定可以被拆解成更小的，可证明的单元，而且程序员可以用顺序结构，分支结构，循环结构这 3 类结构构造出任何程序。到这里有个发现很重要，构建可被证明的模块所需要的控制单元和构建所有程序所需要的控制单元的最小集合是一样的，结构化编程就这样诞生了！！！</p><p>结构化编程范式可以将模块递归降解成可以被推导的单元，这意味着可以把模块按功能进行分解，更进一步说可以把一个大型问题拆分成一系列高级函数组合，而高级函数又可以进一步被拆分为一系列低级函数，每个被拆分出来的函数都可以使用结构化编程范式来构造程序。然后再编写相关的测试来证明这些函数程序是错误的，如果无法证明这些函数代码是错误的，那么我们就可以直接认为这些函数代码是正确的，推导到整个程序是正确的。</p><h3 id="结构化编程的价值"><a href="#结构化编程的价值" class="headerlink" title="结构化编程的价值"></a>结构化编程的价值</h3><p>结构化编程范式中最有价值的点赋予了我们创造可证伪程序单元的能力。延伸到架构设计领域，功能性拆解仍然是验证程序正确性的最佳实践之一。</p><p>我近几年来都是在接触代码重构相关的事情，项目涉及的业务多种多样，但是项目都存在一个明显的问题就是功能模块互相依赖的问题，因为依赖太多导致变更带来非常多的不确定性，同时变更带来的测试成本大无法接受的地步。另外功能模块互相依赖还会带来一个明显部署问题，由于互相依赖，模块无法单独部署，需要所有的模块一起部署。随之而来的还有编译问题，互相依赖过多，一旦被依赖方发生变动，所有的依赖方都必须重新编译，这个最明显的是很多项目中的 common 模块。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://book.douban.com/subject/30333919/">架构整洁之道</a></p><p>2、<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/过程式编程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈软件架构的价值</title>
    <link href="/2022/05/23/talking-about-the-value-of-architecture/"/>
    <url>/2022/05/23/talking-about-the-value-of-architecture/</url>
    
    <content type="html"><![CDATA[<p>一个业务功能，新手和高手同样都可以实现，为什么还要招聘高手呢？在项目预算支持的情况下，通常会招聘更多有经验的程序员来进行开发。</p><p>软件行业中，确实是普遍存在上述的这类现象。 调试并实现一个业务功能并不需要非常高深的知识，甚至一名初入行的实习生都可以做到，将需求文档转换为能够实际上线运行的代码也不会多难，实习生写出来的代码可能不够优雅，但是确实能够正常工作。</p><p>在系统运作一段时间之后，新手可能需要 007 疯狂加班来实现需求。高手因为丰富的架构设计经验，提前做好软件架构设计，系统能够适应各类变化，新需求只需要很少的时间就能够上线。</p><h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>回想我自己的从业经历，确实经历不少这样的场景。某个软件历史悠久，各个组件互相依赖，到处充满了垃圾代码。即使是小改动，也是牵一发而动全身，让整个项目的产品，设计，开发，测试人员充满痛苦。每逢这个时候就会臆想，这个软件要是采用了好的架构设计，可以大大节省软件的开发和测试成本，每次变更都能控制最小影响范围，用最小的成本满足功能性需求。</p><p>好的架构设计具有这么大的魅力，那究竟什么才是软件架构？类比建筑，软件架构就是软件的组织架构，它关注组件，类，函数，模块，层级的设计。</p><h3 id="软件架构有什么用"><a href="#软件架构有什么用" class="headerlink" title="软件架构有什么用"></a>软件架构有什么用</h3><p>正如前面所提，它的目标就是用最小的人力成本来满足构建和维护系统的需求。软件架构具有 2 个方面的价值，一个价值是架构价值，一个价值是行为价值。</p><p>行为价值比较直观，就是程序员把需求文档转换为上线运行的代码，给用户创造价值，同时获取利润。</p><p>对于架构价值的理解可能比较抽象，提一些具体场景，正常来说第一个版本的系统通常都是没有经过什么设计，匆匆忙忙被构建起来。后面业务有了一定的发展，为了加快发布的速度，团队开始招聘新人，同时迫于业务压力，对代码质量提升和软件架构设计存在长期忽视。团队经常加班，拼命工作，团队中的个人不管投入多少个人时间，救了多少火，产出始终上不去。团队的时间大部分都消耗在对现有系统的修复上，新功能的实现投入时间并没有多少，陷入恶性循环。软件架构的价值之一就是要解决类似这个场景的问题，良好的软件架构设计能够避免系统陷入混乱，让软件容易被修改，新增需求或者变更需求，随之所需的软件变更可以简单而方便的实现。</p><h3 id="坚持软件架构的价值"><a href="#坚持软件架构的价值" class="headerlink" title="坚持软件架构的价值"></a>坚持软件架构的价值</h3><p>软件架构设计是一个重要但不紧急的事情。在业务迭代中，技术团队经常容易陷入不重要但紧急的需求旋涡中。对于技术 leader 来说，就是要坚持架构设计的价值，同时也要说服其他人相信架构设计的价值，这也是技术 leader 的价值之一， 只有这样才有可能在紧凑的业务迭代周期中预留部分架构设计和代码 review 时间，以尽量延长软件的生命时间，降低软件的变更成本，让技术团队能够更愉悦的工作。</p><p>参考</p><ol><li><a href="https://book.douban.com/subject/30333919/">https://book.douban.com/subject/30333919/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 图片加载框架－SDWebImage 解读</title>
    <link href="/2016/03/09/reading-source-code-of-SDWebImage/"/>
    <url>/2016/03/09/reading-source-code-of-SDWebImage/</url>
    
    <content type="html"><![CDATA[<h1 id="SDWebImage-解读"><a href="#SDWebImage-解读" class="headerlink" title="SDWebImage 解读"></a>SDWebImage 解读</h1><p>在 iOS 的图片加载框架中，<a href="https://github.com/rs/SDWebImage">SDWebImage</a> 可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的 UIImageView 控件或者 UIButton 控件。在项目中使用 SDWebImage 来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。</p><h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><p>1.提供了一个 UIImageView 的 category 用来加载网络图片并且对网络图片的缓存进行管理<br>2.采用异步方式来下载网络图片<br>3.采用异步方式，使用 memory＋disk 来缓存网络图片，自动管理缓存。<br>4.支持 GIF 动画<br>5.支持 WebP 格式<br>6.同一个 URL 的网络图片不会被重复下载<br>7.失效的 URL 不会被无限重试<br>8.耗时操作都在子线程，确保不会阻塞主线程<br>9.使用 GCD 和 ARC<br>10.支持 Arm64</p><h2 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h2><p>1.使用 ImageView+WebCache category 来加载 UITableView 中 cell 的图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>]];<br></code></pre></td></tr></table></figure><p>2.使用 block,采用这个方案可以在网络图片加载过程中得知图片的下载进度和图片加载成功与否</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>] completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="hljs-built_in">NSURL</span> *imageURL) &#123;<br>    <span class="hljs-comment">//... completion code here ... </span><br> &#125;];<br></code></pre></td></tr></table></figure><p>3.使用 SDWebImageManager,SDWebImageManager 为UIImageView+WebCache category 的实现提供接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SDWebImageManager *manager = [SDWebImageManager sharedManager] ;<br>[manager downloadImageWithURL:imageURL options:<span class="hljs-number">0</span> progress:^(<span class="hljs-built_in">NSInteger</span>   receivedSize, <span class="hljs-built_in">NSInteger</span> expectedSize) &#123; <br>      <span class="hljs-comment">// progression tracking code</span><br> &#125;  completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType,   <span class="hljs-type">BOOL</span> finished, <span class="hljs-built_in">NSURL</span> *imageURL) &#123; <br>   <span class="hljs-keyword">if</span> (image) &#123; <br>    <span class="hljs-comment">// do something with image</span><br>   &#125;<br> &#125;];<br></code></pre></td></tr></table></figure><p>4.加载图片还有使用 SDWebImageDownloader 和 SDImageCache 方式，但那个并不是我们经常用到的。基本上面所讲的3个方法都能满足需求。</p><h2 id="SDWebImage-流程"><a href="#SDWebImage-流程" class="headerlink" title="SDWebImage 流程"></a>SDWebImage 流程</h2><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled.webp" class="" title="This is an example image"><h2 id="SDWebImage-接口"><a href="#SDWebImage-接口" class="headerlink" title="SDWebImage 接口"></a>SDWebImage 接口</h2><p>SDWebImage 是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。</p><ol><li>给 UIImageView 设置图片的接口，SDWebImage 有提供多个给UIImageView 设置图片的接口，最终所有的接口都会调用下图的这个接口，这是大多数框架的做法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled1.webp" class="" title="This is an example image"><ol start="2"><li><p>获取 SDWebImage 的磁盘缓存大小,在项目中有时候会需要统计应用的磁盘缓存内容大小，那么获取图片的缓存大小就是使用这个接口来实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[SDImageCache sharedImageCache] getSize];<br></code></pre></td></tr></table></figure></li><li><p>清理内存缓存，清理内存中缓存的图片资源，释放内存资源。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearMemory];<br></code></pre></td></tr></table></figure></li><li><p>有了清理内存缓存，自然也有清理磁盘缓存的接口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearDisk];<br></code></pre></td></tr></table></figure></li></ol><h2 id="SDWebImage-解析"><a href="#SDWebImage-解析" class="headerlink" title="SDWebImage 解析"></a>SDWebImage 解析</h2><p>解析主要围绕着 SDWebImage 的图片加载流程来分析，介绍SDWebImage 这个框架加载图片过程中的一些处理方法和设计思路。</p><ol><li>给 UIImageView 设置图片，然后 SDWebImage 调用这个最终的图片加载方法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled2.webp" class="" title="This is an example image"><ol start="2"><li>开始加载之前图片先取消对应的 UIImageView 先前的图片下载操作。试想，如果我们给 UIImageView 设置了一张新的图片，那么我们还会在意该 UIImageVIew 先前是要加载哪一张图片么？应该是不在意的吧！那是不是应该尝试把该 UIImageView 先前的加载图片相关操作给取消掉呢?</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> sd_cancelCurrentImageLoad]<br></code></pre></td></tr></table></figure><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled3.webp" class="" title="This is an example image"><p>该方法经过周转，最后调用了以下方法，框架将图片对应的下载操作放到 UIView 的一个自定义字典属性 (operationDictionary) 中，取消下载操作第一步也是从这个 UIView 的自定义字典属性 (operationDictionary)中取出所有的下载操作，然后依次调用取消方法，最后将取消的操作从(operationDictionary) 字典属性中移除。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled4.webp" class="" title="This is an example image"><p>3.移除之前没用的图片下载操作之后就创建一个新的图片下载操作，然后设置到 UIView 的一个自定义字典属性 (operationDictionary) 中。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled5.webp" class="" title="This is an example image"><p>4.看看如何创建一个新的图片下载操作,框架保存了一个失效的 url 列表，如果 url 失效了就会被加入这个列表，保证不会重复多次请求失效的 url。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled6.webp" class="" title="This is an example image"><p>根据给定的 url 生成一个唯一的 key ,之后利用这个 key 到缓存中查找对应的图片缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled7.webp" class="" title="This is an example image"><p>5.读取图片缓存,根据 key 先从内存中读取图片缓存，若没有命中内存缓存则读取磁盘缓存，如果磁盘缓存命中，那么将磁盘缓存读到内存中成为内存缓存。如果都没有命中缓存的话，那么就在执行的 doneBlock中开始下载图片。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled8.webp" class="" title="This is an example image"><p>6.图片下载操作完成后会将图片对应的数据通过 completedBlock 进行回调</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled9.webp" class="" title="This is an example image"><p>在图片下载方法中，调用了一个方法用于添加创建和下载过程中的各类block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled10.webp" class="" title="This is an example image"><p>添加该 url 加载过程的状态回调 block<br> <img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled11.webp" class="" title="This is an example image"></p><p>如果该 url 是第一次加载的话，那么就会执行 createCallback 这个回调block ,然后在 createCallback 里面开始构建网络请求，在下载过程中执行各类进度 block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled12.webp" class="" title="This is an example image"><p>7.当图片下载完成之后会回到 done 的 block 回调中做图片转换处理和缓存操作</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled13.webp" class="" title="This is an example image"><p>回到 UIImageView 控件的设置图片方法 block 回调中，给对应的UIImageView 设置图片，操作流程到此完成。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled14.webp" class="" title="This is an example image"><p> 8.304 的处理<br>SDWebImage在加载图片网络请求的 NSURLConnection 的代理中对httpCode 做了判断，当 httpCode 为 304 的时候放弃下载，读取缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled15.webp" class="" title="This is an example image"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SDWebImage 作为一个优秀的图片加载框架，提供的使用方法和接口对开发者来说非常友好。其内部实现多是采用 block 的方式来实现回调，代码阅读起来可能没有那么直观。此文章旨在给大家讲解 SDWebImage 这个框架的图片大概加载流程，其中具体细节限于篇幅无法详细深究。能力有限，文章中难免有错误，若大家在阅读过程中有发现不合理或者错误的地方恳请在评论中指出，我会在第一时间进行修正,不胜感激。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>注释项目 <a href="https://github.com/junbinchencn/SDWebImage">https://github.com/junbinchencn/SDWebImage</a></li><li><a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS缓存框架－PINCache 解读</title>
    <link href="/2016/01/13/reading-source-code-of-PINCache/"/>
    <url>/2016/01/13/reading-source-code-of-PINCache/</url>
    
    <content type="html"><![CDATA[<h1 id="PINCache-解读"><a href="#PINCache-解读" class="headerlink" title="PINCache 解读"></a>PINCache 解读</h1><p>在项目中总是需要缓存一些网络请求数据以减轻服务器压力，业内也有许多优秀的开源的解决方案。通常的缓存方案都是由内存缓存和磁盘缓存组成的，内存缓存速度快容量小，磁盘缓存容量大速度慢可持久化。常见的内存缓存有 NSCache、<a href="https://github.com/tumblr/TMCache">TMMemoryCache</a>、<a href="https://github.com/pinterest/PINCache">PINMemoryCache</a>、<a href="https://github.com/ibireme/YYCache">YYMemoryCache</a>。常见的磁盘缓存有 TMDiskCache、PINDiskCache、SDWebImage。这次解读先从<a href="https://github.com/pinterest/PINCache">PINCache</a> 这个优秀的开源项目开始。PINCache 项目是在 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的基于 TMCache 的一个内存缓存，修复了 TMCache 存在的性能和死锁问题，可以说是有了一个较大的提升。</p><h3 id="PINCache-概论"><a href="#PINCache-概论" class="headerlink" title="PINCache 概论"></a>PINCache 概论</h3><p>PINCache 是多线程安全的，使用键值对来保存数据。PINCache 内部包含了 2 个类似的对象属性，一个是内存缓存 PINMemoryCache，另一个是磁盘缓存 PINDiskCache。PINCache 本身并没有过多的做处理缓存的具体工作，而是全部交给它内部的2个对象属性来实现，它只是对外提供了一些同步或者异步接口。在 iOS 中，当 App 收到内存警告或者进入后台的时候，PINCache 能够清理掉所有的内存缓存。</p><h3 id="PINCache-使用"><a href="#PINCache-使用" class="headerlink" title="PINCache 使用"></a>PINCache 使用</h3><p>采用 PINCache 项目的 Demo 来说明，这个是从服务器加载数据，再缓存下来，继而做业务逻辑处理，如果下次还需要同样的数据，要是缓存里面还有这个数据的话，那么就不需要再次发起网络请求了，而是直接使用这个数据。<strong>PINCache除了可以按键取值、按键存值、按键删值之外，还可以移除某个日期之前的缓存数据、删除所有缓存、限制缓存大小，限制缓存对象的存活时间等</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP">[[PINCache sharedCache] objectForKey:[url absoluteString]  block:^(PINCache *cache, NSString *key, id object) &#123;<br>                                     <span class="hljs-keyword">if</span> (object) &#123;<br>                                      <span class="hljs-comment">//有缓存，在这里做业务逻辑处理</span><br>                                         <span class="hljs-keyword">return</span>;<br>                                     &#125; <br>                                     <span class="hljs-comment">//没有缓存，那么去服务器加载数据，存入缓存，做业务逻辑处理</span><br>                                    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;cache miss, requesting %@&quot;</span>, url);<br>                                   [[PINCache sharedCache] setObject:data forKey:[url absoluteString]];<br>   &#125;];<br></code></pre></td></tr></table></figure><h3 id="PINCache-结构"><a href="#PINCache-结构" class="headerlink" title="PINCache 结构"></a>PINCache 结构</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled.webp" class="" title="This is an example image"><p>PINCache 的内部结构比较简单，最核心的就是 2 个缓存实现类，这里先给出一个大概的结构，让大家可以有个了解，下面就来讲讲详细的接口。</p><h3 id="PINCache-接口"><a href="#PINCache-接口" class="headerlink" title="PINCache 接口"></a>PINCache 接口</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled1.webp" class="" title="This is an example image"><p><strong>核心属性</strong><br>1.name 是 PINCache 的名字<br>2.concurrentQueue 是一个用来执行异步任务的并行队列<br>3.磁盘缓存<br>4.内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled2.webp" class="" title="This is an example image"><p><strong>初始化方法</strong><br>1.单例对象<br>2.使用名字初始化<br>3.使用名字和缓存路径来初始化</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled3.webp" class="" title="This is an example image"><p><strong>异步方法</strong><br>多数开源缓存框架的方法也就这么几个，大多类似。<br>1.异步按键取值，之后执行 Block<br>2.异步按键设值，之后执行 Block<br>3.异步按键删值，之后执行 Block<br>4.异步删除某个时间之后没有使用的缓存，之后执行 Block<br>5.异步删除所有缓存，之后执行 Block</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled4.webp" class="" title="This is an example image"><p><strong>同步方法</strong><br>这里的同步方法与异步方法的区别除了方法是否立即返回之外，还有一个区别就是异步方法可以传入一个 Block 参数<br>1.同步按键取值<br>2.同步按键设值<br>3.同步按键删值<br>4.同步删除某个时间之后没有使用的缓存<br>5.同步删除所有缓存</p><p><strong>PINCache 主要是包装 PINDiskCache 和 PINMemoryCache 的功能，具体的功能实现是交给对应的对象去实现</strong>。</p><p>###PINDiskCache 解析<br>PINDiskCache 涉及到磁盘缓存的具体实现，这里就不再一一列举所有的属性和方法了（具体的内容可以查看 PINCache 的文档），主要挑重要的取值方法，设值方法，还有删除方法来讲。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled5.webp" class="" title="This is an example image"><p>PINDiskCache 使用 semaphore 来做线程同步控制的，在写磁盘缓存的时候给 diskCache 对象加锁，写完之后解锁。在读磁盘缓存的时候也会给 diskCache 对象加锁，读完之后解锁。<em>读写过程都会加锁</em>。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled6.webp" class="" title="This is an example image"><p>写磁盘缓存的大概步骤是这样的，只是讲解一些思路，具体的详细信息需要大家查看源代码。<br>1.判断给的键值是否为空<br>2.加锁，保证多线程安全<br>3.把数据写入磁盘<br>4.更新缓存信息（包括但不限于保存磁盘缓存的总容量）<br>5.判断现在的磁盘缓存容量是否超过容量限制，若超出，按照缓存时间策略来删除对应的缓存，没有超过则不做操作<br>6.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled7.webp" class="" title="This is an example image"><p>读磁盘缓存相对简单一些，就是找到文件，然后读取。<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把数据从磁盘读到内存对象中<br>4.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled8.webp" class="" title="This is an example image"><p>移除缓存就是文件的删除操作<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把文件从磁盘中删除<br>4.解锁，让其他线程可以进入操作</p><h3 id="PINMemoryCache-解析"><a href="#PINMemoryCache-解析" class="headerlink" title="PINMemoryCache 解析"></a>PINMemoryCache 解析</h3><p>内存缓存相比磁盘缓存多了一个 App 收到内存警告或者 App 进入后台的时候清理缓存的功能。内存缓存的数据保存在字典里面。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled9.webp" class="" title="This is an example image"><p>1.收到系统内存警告通知，清理内存缓存<br>2.收到App进入后台的系统通知,清理内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled10.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.将数据存到缓存池，也就是字典里面<br>4.更新缓存对应的数据<br>5.解锁<br>6.判断内存缓存容量是否超出，超过删除部分</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled11.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.从字典里面取对应值<br>4.更新缓存对应的数据<br>5.解锁</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled12.webp" class="" title="This is an example image"><p>1.取出内存缓存值<br>2.加锁<br>3.更新内存缓存容量<br>4.删除内存缓存<br>5.更新内存缓存对应的数据<br>6.解锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存一般有 2 个部分组成，一个是内存缓存，一个是磁盘缓存。<br>1.对于<strong>内存缓存</strong>来说，一般使用字典来作为数据的缓存池，配合一个保存每个内存缓存数据的缓存时间的字典，一个保存每个内存缓存数据的缓存容量的字典，一个保存内存缓存总容量的变量。对于增删改查操作，基本也都是围绕着字典来的，需要重点注意的就是在这些个操作过程的多线程安全问题，还有同步和异步访问方法，以及异步方法中的 Block 参数的循环引用问题。<br>2.对于<strong>磁盘缓存</strong>来说，使用文件系统来保存缓存数据，配合设置文件的参数，比如文件的修改日期（访问一次即修改一次），文件的大小来管理着这个缓存数据。对缓存数据的增删改查，也就是转化成为对文件的读写删除操作。<br>3.不管是内存缓存还是磁盘缓存，在删除超过限制容量的缓存的时候总是有一个同样的策略。有优先删除缓存最久，最少使用的策略，也有优先删除，容量最大，最少使用的策略。没有什么最好的策略，只有适合你业务产品的策略。<br>最后感谢<a href="https://github.com/pinterest">PINCache的作者们</a>给我们提供了一个优秀的缓存开源框架。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://blog.ibireme.com/2015/10/26/yycache/">http://blog.ibireme.com/2015/10/26/yycache/</a><br><a href="https://github.com/pinterest/PINCache">https://github.com/pinterest/PINCache</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
