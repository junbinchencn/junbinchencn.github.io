<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>结构化编程 &amp; 函数式编程</title>
    <link href="/2022/05/25/functional-procedural-programming/"/>
    <url>/2022/05/25/functional-procedural-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="结构化编程-amp-函数式编程"><a href="#结构化编程-amp-函数式编程" class="headerlink" title="结构化编程 &amp; 函数式编程"></a>结构化编程 &amp; 函数式编程</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><ul><li>计算机科学家 dijkstra 认为 goto 语句的无限制跳转会损坏程序的整体结构，应该使用 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句来替代跳转语句。简而言之结构化编程对程序控制权的直接转移进行了限制和规范。</li><li>函数式编程语言中的变量是不可变的，函数式编程是对程序中的赋值操作进行限制。</li></ul><h2 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h2><ul><li><strong>结构化编程的诞生</strong></li></ul><p>dijkstra 提出为了能够证明程序的正确性，就必须把程序模块递归拆分成更小的，可以被证明的单元，dijkstra 经过研究发现，goto 语句可能会导致大模块无法被进一步拆分成更小的，可被证明的单元，同时 goto 语句的用法与 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句的作用又没有明显的区别，所以 goto 是可以被替代的。</p><p>另外一个证明是代码中使用了顺序结构，分支结构，循环结构，那么代码是一定可以被拆解成更小的，可证明的单元，而且程序员可以用顺序结构，分支结构，循环结构这 3 类结构构造出任何程序。到这里有个发现很重要，构建可被证明的模块所需要的控制单元和构建所有程序所需要的控制单元的最小集合是一样的，结构化编程就这样诞生了！！！</p><p>结构化编程范式可以将模块递归降解成可以被推导的单元，这意味着可以把模块按功能进行分解，更进一步说可以把一个大型问题拆分成一系列高级函数组合，而高级函数又可以进一步被拆分为一系列低级函数，每个被拆分出来的函数都可以使用结构化编程范式来构造程序。然后再编写相关的测试来证明这些函数程序是错误的，如果无法证明这些函数代码是错误的，那么我们就可以直接认为这些函数代码是正确的，推导到整个程序是正确的。</p><ul><li><strong>结构化编程的价值</strong></li></ul><p>结构化编程范式中最有价值的点赋予了我们创造可证伪程序单元的能力。延伸到架构设计领域，功能性拆解仍然是验证程序正确性的最佳实践之一。</p><p>我近几年来都是在接触代码重构相关的事情，项目涉及的业务多种多样，但是项目都存在一个明显的问题就是功能模块互相依赖的问题，因为依赖太多导致变更带来非常多的不确定性，同时变更带来的测试成本大无法接受的地步。另外功能模块互相依赖还会带来一个明显部署问题，由于互相依赖，模块无法单独部署，需要所有的模块一起部署。随之而来的还有编译问题，互相依赖过多，一旦被依赖方发生变动，所有的依赖方都必须重新编译，这个最明显的是很多项目中的 common 模块。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><strong>函数式编程的价值</strong></li></ul><p>函数式编程对变量可变性进行限制，而不可变性正是软件架构设计中需要考虑的重点。为什么软件架构设计中需要考虑可变性呢？因为所有的竞争问题，死锁问题，并发更新问题都是由变量的可变性造成的，如果变量永远不会被改变，那么就不会产生竞争或者并发问题。如果锁的状态是不可变的，那么就不会产生死锁问题。在软件架构设计中需要对并发问题保持高度关注，在实际应用中不可变性这个特点是否具备可行性呢？</p><ul><li><strong>可变性隔离</strong></li></ul><p>可变性隔离一种常见的方式是把应用程序的内部服务进行划分，划分为可变的和不可变的组件。不可变组件用纯函数来执行任务，期间不能修改任何的状态，不可变组件将通过非函数式组件通信的方式来修改变量的状态，由于修改变量的状态会产生一系列编发问题，所以通常采用某种事务型内存来保护可变变量，避免并发和死锁问题。</p><p>一个设计良好的软件架构中应该将状态修改的部分和不需要修改状态的部分分别隔离成单独的组件，然后用合适的机制来保护可变量，所以在架构设计中应该致力于将大部分处理逻辑都归纳到不可变组件中，可变状态组件的逻辑越少越好。</p><ul><li><strong>事件溯源</strong></li></ul><p>随着存储和计算能力的大幅提升，我们有可能做到只存储事务记录，不存储具体状态，当需要具体状态是，我们只要从头开始计算所有的事务即可，这样的设计看起来是很美好，不过实用性是差一些。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结笔记</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/过程式编程</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98">https://zh.m.wikipedia.org/zh-hans/事务内存</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/函数式编程</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/24/object-oriented-programming/"/>
    <url>/2022/05/24/object-oriented-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>现在软件开发当中，面向对象编程已经成为一个黄金标准，那究竟什么是面向对象？对于这个问题有很多回答，一种回答是 “数据与函数的组合”，另一种回答是对真实世界进行建模的方式，还有另外一种回答是涉及到封装，继承，多态，也就是说面向对象是这三项的组合。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装这个特性因为在面向对象编程用的多了，导致不少人经常会认为它就是面向对象的一部分，其实不是这样的。C 语言中的 struct 结构体就是支持完整的封装，在引入 point.h 文件的程序中是没有 Point 这个结构体的内部访问权限的，只能调用 makePoint 和 distance 函数，但是不清楚函数内部的具体实现细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// point.h </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span>;<br><br><span class="hljs-comment">// point.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-comment">// 构造 Point</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span> &#123;<br>    <span class="hljs-comment">// 计算距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 作为一个面向对象编程语言，在封装的完整性反而不如 C 语言。稍微改造一下上面的 Point 例子，虽然编译器会禁止外部 x,y 这 2 个变量的范围，但是调用者都知道了它们的存在。不过 C++ 在语法层面引入了 public，private，protected 这些访问控制的关键词，在一定程度上维护了封装性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一个面向对象编程语言 Java 则彻底抛弃了头文件和实现文件分离的编程方式，这也是破坏封装完整性的表现，因为我们无法区分一个类的声明和定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>      <span class="hljs-comment">// 构造 Point</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(Point p1, Point p2)</span> &#123;<br>      <span class="hljs-comment">// 计算距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们基本可以得出强封装并不是面向对象编程的必要条件。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的主要作用是让程序员可以在某个作用域内对外部定义的一组变量与函数进行覆盖。但是实际上 C 语言也可以做到，不仅仅是面向对象编程语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// namedPoint.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span>;</span><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// namedPoint.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>    <span class="hljs-type">char</span>* name;<br>&#125;<br><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-comment">// 构造 NamedPoint</span><br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">orgin</span> =</span> makeNamedPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">upperRight</span> =</span> makeNamedPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;upperRight&quot;</span>);<br><br>distance((<span class="hljs-keyword">struct</span> Point *)orgin, (<span class="hljs-keyword">struct</span> Point *)upperRight);<br></code></pre></td></tr></table></figure><p>看 main.c 里面的代码，因为 NamedPoint 和 Point 结构体的前 2 个成员顺序一致，所以 NamedPoint 可以被伪装成 Point 来使用，在程序中必须显式把 NamedPoint 强制转换为 Point 类型。通过上面的案例，我们可以了解到继承的特性在面向对象被发明之前就已经在使用了。但是在面向对象编程语言中，这种向上的类型转换是隐式，虽然面向对象编程在继承性上没有突破，但是至少在数据类型的转换上提供了便利。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象编程涉及到封装，继承，多态这 3 个特性，前面提到了封装和继承都不是面向对象编程独有特性，那么多态是不是面向对象编程独有的呢？答案也是否定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getchar()) != EOF) &#123;<br>        <span class="hljs-built_in">putchar</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getchar() 负责从 STDIN 读数据，putchar() 负责往 STDOUT 写数据，那么 STDIN 和 STDOUT 又具体表示哪些设备呢？显然 getchar 和 putchar 这类函数就具有多态性，因为他们的行为依赖于 STDIN 和 STDOUT 的具体实现。</p><p>以 Unix 为例，每个 IO 设备的驱动程序都要提供 open,close,read,write,seek 这 5 个标准函数实现。在 FILE 数据结构体中也包含了这 5 个标准函数对于的函数指针，这些函数指针用于指向 IO 设备驱动提供标准函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FILE 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br>    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode)<br>    <span class="hljs-type">void</span> (*close)();<br>    <span class="hljs-type">int</span> (*read)();<br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br>    <span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode);<br>&#125;<br><br><span class="hljs-comment">// 设备驱动程序实现</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// open 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*close)() &#123;<br>    <span class="hljs-comment">// close 实现</span><br>&#125;<br><span class="hljs-type">int</span> (*read)() &#123;<br>    <span class="hljs-comment">// read 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>) &#123;<br>    <span class="hljs-comment">// write 实现</span><br>&#125;<br><br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// seek 实现</span><br>&#125;<br><br><span class="hljs-comment">//getchar 函数的大致实现</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span>* <span class="hljs-title">STDIN</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> STDIN-&gt;read()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的程序中看，getchar 函数本质上是使用了 STDIN 来调用保存在 FILE 结构中的 read 函数指针所指向的函数实现。说到底，多态其实就是函数指针的一种应用。用函数指针实现多态的最大问题就是函数指针的危险性了，因为函数指针的调用依赖于程序员的约定，程序员必须严格遵守规则按照函数指针的类型来初始化函数指针，并严格按照函数指针的类型来使用函数指针。在编程中可以确定计算机能够遵守规则，但是无法确定程序员会遵守规则。</p><p>同继承一样，面向对象编程本质上还是没有在多态上进行创新，面向对象编程语言为程序员消除了人工遵守规则的必要，它让多态变得更安全，更便于使用了。<strong>结构化编程对程序控制权的直接转移进行了限制和规范，而面向对象编程其实是对程序的间接控制权的转移进行了限制，具体一些就是原来多态的调用只要函数类型一致就可以使用函数指针进行调用，而不需要有什么其他额外关系，但是现在面向对象编程在这个基础上加上了一些数据类型的限制。</strong></p><h3 id="带来的价值"><a href="#带来的价值" class="headerlink" title="带来的价值"></a>带来的价值</h3><ul><li>插件式架构</li></ul><p>Unix 系统将 IO 设备设计成插件式架构，随后在多个操作系统都有应用，即使知道多态有如此多的优点，但是碍于函数指针是一项及其危险的技术，大部分程序员还是不敢将插件式架构引入系统。但是面向对象编程的出现使得插件式架构可以安全地被应用在任何地方。</p><ul><li>依赖反转</li></ul><p>在安全和便利的多态技术出现之前，软件的典型调用树是这样的，HightLayer 模块要调用 MiddleLayer 模块，HightLayer 模块必须要依赖 MiddleLayer 模块 ，程序的源代码依赖不可避免的需要跟随程序的控制流。这让我们这些程序员在软件架构上没有什么其他多余的选择，软件的系统行为决定了程序的控制流，而控制流则决定了源代码依赖关系。</p><p>依赖关系和控制关系如下图所示，实线表示源代码依赖关系，虚线表示控制流关系。</p><img src="/2022/05/24/object-oriented-programming/Untitled.png" class="" title="This is an example image"><p>现在利用面向对象编程语言提供的安全便利的多态实线，无论我们面对怎么样的源代码依赖，我们都可以将其反转（源代码依赖方向和控制流方向相反）。如下图所示，模块 HightLayer 调用模块 MiddleLayer 中的 function 函数，这里的调用在是通过源代码界别的 interface 来实现的，在程序的实际运行过程中，interface 这个概念是不存在的，HightLayer 会直接调用 MiddleLayer 中的 function 函数。</p><img src="/2022/05/24/object-oriented-programming/Untitled01.png" class="" title="This is an example image"><p>延伸一下，这种能力在实际的软件架构设计中有什么作用呢？看下图，我们可以让用户界面和数据库都依赖业务逻辑，业务逻辑不需要引入用户界面和数据库的依赖，这样用户界面和数据库就成为业务逻辑的插件。这样一来，用户界面，业务逻辑，数据库就可以成为 3 个独立的组件，可以单独编译和部署，同时用户界面或者数据库的修改就不会对业务逻辑产生任何的影响。进一步说，当某个组件需要修改是，仅仅需要重新编译和部署该组件，不需要更改其他的组件，这就是独立部署能力。再进一步说，如果组件可以独立部署，那么就意味着组件可以由不同的团队并行开发，这就是架构的独立开发能力，也是架构和团队组织互相影响。</p><img src="/2022/05/24/object-oriented-programming/Untitled02.png" class="" title="This is an example image"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">https://zh.wikipedia.org/wiki/面向对象程序设计</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈软件架构的价值</title>
    <link href="/2022/05/23/talking-about-the-value-of-architecture/"/>
    <url>/2022/05/23/talking-about-the-value-of-architecture/</url>
    
    <content type="html"><![CDATA[<p>一个业务功能，新手和高手同样都可以实现，为什么还要招聘高手呢？在项目预算支持的情况下，通常会招聘更多有经验的程序员来进行开发。</p><p>软件行业中，确实是普遍存在上述的这类现象。 调试并实现一个业务功能并不需要非常高深的知识，甚至一名初入行的实习生都可以做到，将需求文档转换为能够实际上线运行的代码也不会多难，实习生写出来的代码可能不够优雅，但是确实能够正常工作。</p><p>在系统运作一段时间之后，新手可能需要 007 疯狂加班来实现需求。高手因为丰富的架构设计经验，提前做好软件架构设计，系统能够适应各类变化，新需求只需要很少的时间就能够上线。</p><h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>回想我自己的从业经历，确实经历不少这样的场景。某个软件历史悠久，各个组件互相依赖，到处充满了垃圾代码。即使是小改动，也是牵一发而动全身，让整个项目的产品，设计，开发，测试人员充满痛苦。每逢这个时候就会臆想，这个软件要是采用了好的架构设计，可以大大节省软件的开发和测试成本，每次变更都能控制最小影响范围，用最小的成本满足功能性需求。</p><p>好的架构设计具有这么大的魅力，那究竟什么才是软件架构？类比建筑，软件架构就是软件的组织架构，它关注组件，类，函数，模块，层级的设计。</p><h3 id="软件架构有什么用"><a href="#软件架构有什么用" class="headerlink" title="软件架构有什么用"></a>软件架构有什么用</h3><p>正如前面所提，它的目标就是用最小的人力成本来满足构建和维护系统的需求。软件架构具有 2 个方面的价值，一个价值是架构价值，一个价值是行为价值。</p><p>行为价值比较直观，就是程序员把需求文档转换为上线运行的代码，给用户创造价值，同时获取利润。</p><p>对于架构价值的理解可能比较抽象，提一些具体场景，正常来说第一个版本的系统通常都是没有经过什么设计，匆匆忙忙被构建起来。后面业务有了一定的发展，为了加快发布的速度，团队开始招聘新人，同时迫于业务压力，对代码质量提升和软件架构设计存在长期忽视。团队经常加班，拼命工作，团队中的个人不管投入多少个人时间，救了多少火，产出始终上不去。团队的时间大部分都消耗在对现有系统的修复上，新功能的实现投入时间并没有多少，陷入恶性循环。软件架构的价值之一就是要解决类似这个场景的问题，良好的软件架构设计能够避免系统陷入混乱，让软件容易被修改，新增需求或者变更需求，随之所需的软件变更可以简单而方便的实现。</p><h3 id="坚持软件架构的价值"><a href="#坚持软件架构的价值" class="headerlink" title="坚持软件架构的价值"></a>坚持软件架构的价值</h3><p>软件架构设计是一个重要但不紧急的事情。在业务迭代中，技术团队经常容易陷入不重要但紧急的需求旋涡中。对于技术 leader 来说，就是要坚持架构设计的价值，同时也要说服其他人相信架构设计的价值，这也是技术 leader 的价值之一， 只有这样才有可能在紧凑的业务迭代周期中预留部分架构设计和代码 review 时间，以尽量延长软件的生命时间，降低软件的变更成本，让技术团队能够更愉悦的工作。</p><p>参考</p><ol><li><a href="https://book.douban.com/subject/30333919/">https://book.douban.com/subject/30333919/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 模型框架- Mantle 解读</title>
    <link href="/2016/11/04/reading-source-code-of-Mantle/"/>
    <url>/2016/11/04/reading-source-code-of-Mantle/</url>
    
    <content type="html"><![CDATA[<h1 id="Mantle-解读"><a href="#Mantle-解读" class="headerlink" title="Mantle 解读"></a>Mantle 解读</h1><p><a href="https://github.com/Mantle/Mantle/">Mantle</a> 是由 Github 开发一款模型框架，Mantle 的主要作用在于让开发者更简单的构建应用的 model 层。本文主要介绍 Mantle 中最常使用的 JSON 功能–字典转模型。</p><h3 id="Mantle-的使用"><a href="#Mantle-的使用" class="headerlink" title="Mantle 的使用"></a>Mantle 的使用</h3><p>先以知乎的一个 <a href="http://news-at.zhihu.com/api/4/news/latest">API</a> 为例，讲解如何使用 Mantle 为这个 API 构建 model 。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled.webp" class="" title="API的数据结构"><p>1.按照 Mantle 要求构建对应的 model，Mantle 要求所有的 Model 都要继承于 MTLModel 并实现 MTLJSONSerializing 协议</p><p>构建 ZhihuLatestNews model 对应返回的 JSONKeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled1.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled2.webp" class="" title="image"><p>构建 ZhihuStory model 对应 sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled3.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled4.webp" class="" title="image"><p>构建 ZhihuStory model 对应 top_sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled5.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled6.webp" class="" title="image"><p>2.将网络请求的结果使用 Manlte 转化成 model</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled7.webp" class="" title="image"><h3 id="Mantle的接口"><a href="#Mantle的接口" class="headerlink" title="Mantle的接口"></a>Mantle的接口</h3><p>Mantle 通过 MTLJSONAdapter 实现 字典和 model 之间的转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">ZhihuLatestNews *lateNews = [MTLJSONAdapter modelOfClass:ZhihuLatestNews.<span class="hljs-keyword">class</span> fromJSONDictionary:dict error:&amp;merror];<br></code></pre></td></tr></table></figure><h3 id="Mantle的核心操作步骤"><a href="#Mantle的核心操作步骤" class="headerlink" title="Mantle的核心操作步骤"></a>Mantle的核心操作步骤</h3><p>1.获取 model 的属性–&gt; JSONKeyPath 映射字典<br>2.获取 model 的属性列表<br>3.根据 model 的方法给网络请求中返回的 JSON 字典中的 value 做值类型转化操作<br>4.使用 KVC 把值赋给 model 的属性，完成操作</p><h3 id="Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程"><a href="#Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程" class="headerlink" title="Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程"></a>Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>| +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<span class="hljs-comment">// Mantle 调用入口</span><br>|   [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; initWithModelClass:]<span class="hljs-comment">// 创建 MTLJSONAdapter </span><br>|     +[ZhihuLatestNews JSONKeyPathsByPropertyKey]<span class="hljs-comment">// 获取 属性-&gt; JSONKeyPath 映射字典</span><br>|     +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|       +[ZhihuLatestNews enumeratePropertiesUsingBlock:]<br>|         +[ZhihuLatestNews storageBehaviorForPropertyWithKey:] <span class="hljs-comment">// 判断 model 的属性是否 Mantle 要求</span><br><br>| From: -[MTLJSONAdapter initWithModelClass:]<br>| +[MTLJSONAdapter valueTransformersForModelClass:] <span class="hljs-comment">//值转化</span><br>|   +[ZhihuLatestNews propertyKeys]<br>|   +[MTLJSONAdapter transformerForModelPropertiesOfClass:]<br><br>| From: +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<br>| [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; modelFromJSONDictionary:error:] <br>|   +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|   +[ZhihuLatestNews modelWithDictionary:error:] <span class="hljs-comment">//生成 model 对象</span><br>|     [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; initWithDictionary:error:]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; init]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; setDate:]<br>|   [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; validate:]<br>|     +[ZhihuLatestNews propertyKeys]<br><br></code></pre></td></tr></table></figure><h3 id="Mantle的源码解读"><a href="#Mantle的源码解读" class="headerlink" title="Mantle的源码解读"></a>Mantle的源码解读</h3><p>1.初始化 MTLJSONAdapter</p><p>MTLJSONAdapter 是 字典和 model 之间的适配器，将 JSON 字典 转成应用的 model 对象</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled8.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>     <span class="hljs-comment">//初始化MTLJSONAdapter</span><br>MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];<br><br><span class="hljs-keyword">return</span> [adapter modelFromJSONDictionary:JSONDictionary error:error];<br>&#125;<br></code></pre></td></tr></table></figure><p>2.initWithModelClass:(Class)modelClass 的作用是使用给定的 modelClass 初始化 MTLJSONAdapter</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled9.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)initWithModelClass:(Class)modelClass &#123;<br>  <br>    <span class="hljs-comment">//对modelClass进行判空操作</span><br><span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-comment">//是否实现MTLJSONSerializing协议的判断，对是否继承了MTLModel进行确认</span><br><span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br><br>self = [super init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br><br>    <span class="hljs-comment">//使用变量保存modelClass，以便后续使用</span><br>     _modelClass = modelClass;<br><br>    <span class="hljs-comment">//获取属性值和JSONKeyPaths的映射字典，并使用_JSONKeyPathsByPropertyKey保存</span><br>    <span class="hljs-comment">//JSONKeyPathsByPropertyKey 是 MTLJSONSerializing 协议中定义的一个方法，在MTLModel的子类中实现</span><br>_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];<br><br>   <span class="hljs-comment">//获取 model 的属性，保存在propertyKeys变量中</span><br>   <span class="hljs-comment">//  **该方法后文有详细的实现解读**</span><br>NSSet *propertyKeys = [self.modelClass propertyKeys];<br><br>     <span class="hljs-comment">//判断 _JSONKeyPathsByPropertyKey 是否包含在 propertyKeys 里面,</span><br>     <span class="hljs-comment">//用来确认 _JSONKeyPathsByPropertyKey 里面的 key 都是 model 的属性</span><br><span class="hljs-keyword">for</span> (NSString *mappedPropertyKey in _JSONKeyPathsByPropertyKey) &#123;<br><span class="hljs-keyword">if</span> (![propertyKeys containsObject:mappedPropertyKey]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ is not a property of %@.&quot;</span>, mappedPropertyKey, modelClass);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>        <span class="hljs-comment">//根据 model 的属性 key 取出 JSONKeyPath</span><br>id value = _JSONKeyPathsByPropertyKey[mappedPropertyKey];<br>        <span class="hljs-comment">//TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？在文章末尾说明1</span><br><span class="hljs-keyword">if</span> ([value isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-keyword">for</span> (NSString *keyPath in value) &#123;<br><span class="hljs-keyword">if</span> ([keyPath isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>, mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (![value isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>,mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//获取 model 属性的 valueTransformers 用于做类型转化</span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>_valueTransformersByPropertyKey = [self.<span class="hljs-keyword">class</span> valueTransformersForModelClass:modelClass];<br>    <span class="hljs-comment">//A new map table object which has strong references to the keys and values.</span><br>_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.MTLModel的propertyKeys类方法,该方法会返回一个包含 model 属性列表的 NSSet 数据，但是这个 NSSet 数据不包含 被 readonly 修饰的属性，没有 ivars 变量的属性，以及 MTLModel 类自身的属性。除此之外的所有通过 @property 声明的属性都会存在 NSSet 数据中，</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled10.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/// Returns the keys for all @property declarations, except for `readonly`</span><br><span class="hljs-comment">/// properties without ivars, or properties on MTLModel itself.</span><br>+ (NSSet *)propertyKeys &#123;<br>    <span class="hljs-comment">// 判断 model 中 是否有属性列表的缓存，若有直接返回</span><br>NSSet *cachedKeys = <span class="hljs-built_in">objc_getAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey);<br><span class="hljs-keyword">if</span> (cachedKeys != nil) <span class="hljs-keyword">return</span> cachedKeys;<br><br>NSMutableSet *keys = [NSMutableSet set];<br>    <span class="hljs-comment">//遍历 model 所有的属性，判断哪些属性是符合要求的，加入 keys 变量中</span><br>   <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>[self enumeratePropertiesUsingBlock:^(<span class="hljs-type">objc_property_t</span> property, BOOL *stop) &#123;<br>        <span class="hljs-comment">//获取属性名字</span><br>NSString *key = @(<span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-comment">//判断哪些属性是可以做映射的，即不是 MTLPropertyStorageNone 的都可以做映射</span><br>        <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br><span class="hljs-keyword">if</span> ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;<br> [keys addObject:key];<br>&#125;<br>&#125;];<br><br><span class="hljs-comment">// It doesn&#x27;t really matter if we replace another thread&#x27;s work, since we do</span><br><span class="hljs-comment">// it atomically and the result should be the same.</span><br>    <span class="hljs-comment">// 给这个对象设置属性列表的缓存</span><br><span class="hljs-built_in">objc_setAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);<br><br><span class="hljs-keyword">return</span> keys;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.MTLModel 的enumeratePropertiesUsingBlock类方法，该方法用来遍历 model 的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (<span class="hljs-type">void</span>)enumeratePropertiesUsingBlock:(<span class="hljs-built_in">void</span> (^)(<span class="hljs-type">objc_property_t</span> property, BOOL *stop))block &#123;<br>Class cls = self;<br>BOOL stop = NO;<br>    <span class="hljs-comment">//按 mode l的继承层级，遍历 model 的属性</span><br><span class="hljs-keyword">while</span> (!stop &amp;&amp; ![cls isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-type">unsigned</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取属性列表</span><br><span class="hljs-type">objc_property_t</span> *properties = <span class="hljs-built_in">class_copyPropertyList</span>(cls, &amp;count);<br>cls = cls.superclass;<br><span class="hljs-keyword">if</span> (properties == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(properties);<br>&#125;;<br>        <span class="hljs-comment">//block回调</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br><span class="hljs-built_in">block</span>(properties[i], &amp;stop);<br><span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.MTLModel 的 storageBehaviorForPropertyWithKey 类方法，用于判断 model 的属性是否可以用来做转化</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled11.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;<br>    <span class="hljs-comment">//根据属性名获取属性的相关内容</span><br><span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(self.<span class="hljs-keyword">class</span>, propertyKey.UTF8String);<br><span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>  <span class="hljs-comment">//将属性的 runtime 表示方法 转成 Mantle 的表示方法</span><br>  <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(attributes);<br>&#125;;<br>  <span class="hljs-comment">//是否有 setter 和 getter 方法</span><br>BOOL hasGetter = [self instancesRespondToSelector:attributes-&gt;getter];<br>BOOL hasSetter = [self instancesRespondToSelector:attributes-&gt;setter]; <br><span class="hljs-keyword">if</span> (!attributes-&gt;dynamic &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span> &amp;&amp; !hasGetter &amp;&amp; !hasSetter) &#123;<br>        <span class="hljs-comment">// attributes 不是 dynamic ( @dynamic 就是要来告诉编译器，代码中用 @dynamic 修饰的属性，其 getter 和 setter 方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译)</span><br>        <span class="hljs-comment">// attributes-&gt;ivar 为空</span><br>        <span class="hljs-comment">//没有 getter 方法</span><br>        <span class="hljs-comment">//没有 setter 方法</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attributes-&gt;readonly &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">//attributes 是 readonly</span><br>        <span class="hljs-comment">//attributes-&gt;ivar 变量为空</span><br><span class="hljs-keyword">if</span> ([self isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br>            <span class="hljs-comment">//是否是 MTLModel 的属性</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check superclass in case the subclass redeclares a property that</span><br><span class="hljs-comment">// falls through</span><br>            <span class="hljs-comment">// 检查一下超类属性，防止超类属性被子类重新声明</span><br><span class="hljs-keyword">return</span> [self.superclass storageBehaviorForPropertyWithKey:propertyKey];<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> MTLPropertyStoragePermanent;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.EXTRuntimeExtensions 的 mtl_copyPropertyAttributes 方法，作用是将属性的runtime表示形式转成更好理解的 Mantle 表示形式。该方法比较枯燥无味且相对来说难以理解，可以略过，不影响 Mantle 解读。<br>该方法需要结合苹果的官方<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a>开发文档再进行单步调试才能更好的理解。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled12.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//以属性date为例,说明整个转化过程，具体的信息可以参考苹果官方的 runtime 文档</span><br><span class="hljs-comment">// @property (nonatomic,strong) NSString *date </span><br><br><span class="hljs-function">mtl_propertyAttributes *<span class="hljs-title">mtl_copyPropertyAttributes</span> <span class="hljs-params">(<span class="hljs-type">objc_property_t</span> property)</span> </span>&#123;<br>    <span class="hljs-comment">//The string starts with a T followed by the @encode type and a comma(逗号), and finishes with a V followed by the name of the backing instance variable.</span><br>    <span class="hljs-comment">//属性 date 的 runtime 表示形式为 &quot;T@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> attrString = <span class="hljs-built_in">property_getAttributes</span>(property);<br>    <span class="hljs-keyword">if</span> (!attrString) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not get attribute string from property %s\n&quot;</span>, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//必须以 T 开头</span><br>    <span class="hljs-keyword">if</span> (attrString[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;T&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Expected attribute string \&quot;%s\&quot; for property %s to start with &#x27;T&#x27;\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//去掉 T 变成 &quot;@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *typeString = attrString + <span class="hljs-number">1</span>;<span class="hljs-comment">//attrString代表字符串的起始地址，地址加1表示字符串截取</span><br><br>    <span class="hljs-comment">// Obtains the actual size and the aligned size of an encoded type.</span><br>    <span class="hljs-comment">// 去掉 @encode 字符串 变成 &quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *next = <span class="hljs-built_in">NSGetSizeAndAlignment</span>(typeString, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!next) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read past type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   <span class="hljs-comment">// 以属性 date 为例差11个字符</span><br>    <span class="hljs-type">size_t</span> typeLength = next - typeString;<br>    <span class="hljs-keyword">if</span> (!typeLength) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Invalid type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// allocate enough space for the structure and the type string (plus a NUL)</span><br>    <span class="hljs-comment">// 将propertyAttributes变成mtl_propertyAttributes类型</span><br>    <span class="hljs-comment">// TODO 长度的计算？为什么是这样计算？</span><br>    mtl_propertyAttributes *attributes = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(mtl_propertyAttributes) + typeLength + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!attributes) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not allocate mtl_propertyAttributes structure for attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the type string</span><br>    <span class="hljs-comment">// 复制属性的类型</span><br>    <span class="hljs-built_in">strncpy</span>(attributes-&gt;type, typeString, typeLength);<br>    attributes-&gt;type[typeLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//字符串结尾</span><br><br>    <span class="hljs-comment">// if this is an object type, and immediately followed by a quoted string...</span><br>    <span class="hljs-keyword">if</span> (typeString[<span class="hljs-number">0</span>] == *(@<span class="hljs-built_in">encode</span>(id)) &amp;&amp; typeString[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;<br>        <span class="hljs-comment">// we should be able to extract a class name</span><br>        <span class="hljs-comment">// &quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *className = typeString + <span class="hljs-number">2</span>;<span class="hljs-comment">//字符串截取</span><br><br>        <span class="hljs-comment">//extern char *strchr(const char *s,char c);查找字符串s中首次出现字符c的位置。</span><br>        <span class="hljs-comment">//&quot;\&quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(className, <span class="hljs-string">&#x27;&quot;&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (!next) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read class name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (className != next) &#123;<br>            <span class="hljs-comment">// 通过内存地址相减 0x0000000104f0347e((const char *) next) - 0x0000000104f03476((const char *) className) = 8</span><br>            <span class="hljs-type">size_t</span> classNameLength = next - className;<br>            <span class="hljs-type">char</span> trimmedName[classNameLength + <span class="hljs-number">1</span>];<span class="hljs-comment">//创建用于存放属性类型的数组</span><br><br>            <span class="hljs-built_in">strncpy</span>(trimmedName, className, classNameLength);<span class="hljs-comment">//复制属性类型到trimmedName</span><br>            trimmedName[classNameLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//数组末尾结束符号</span><br><br>            <span class="hljs-comment">// attempt to look up the class in the runtime</span><br>            attributes-&gt;objectClass = <span class="hljs-built_in">objc_getClass</span>(trimmedName);<span class="hljs-comment">//设置属性类型</span><br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">// &quot;\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-keyword">if</span> (*next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-comment">// skip past any junk before the first flag</span><br>        <span class="hljs-comment">// &quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (next &amp;&amp; *next == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-comment">//第一次循环 &amp;</span><br>        <span class="hljs-comment">//第一次循环 N</span><br>        <span class="hljs-comment">//第一次循环 V</span><br>        <span class="hljs-type">char</span> flag = next[<span class="hljs-number">1</span>];<br>        next += <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">switch</span> (flag) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>            <span class="hljs-comment">//The property is read-only (readonly).</span><br>            attributes-&gt;readonly = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            <span class="hljs-comment">//The property is a copy of the value last assigned (copy).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyCopy;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;&#x27;</span>:<br>            <span class="hljs-comment">//The property is a reference to the value last assigned (retain).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyRetain;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:<br>            <span class="hljs-comment">//The property is non-atomic (nonatomic).</span><br>            attributes-&gt;nonatomic = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).</span><br>            &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *nextFlag = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>                SEL name = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-keyword">if</span> (!nextFlag) &#123;<br>                    <span class="hljs-comment">// assume that the rest of the string is the selector</span><br>                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *selectorString = next;<br>                    next = <span class="hljs-string">&quot;&quot;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">size_t</span> selectorLength = nextFlag - next;<br>                    <span class="hljs-keyword">if</span> (!selectorLength) &#123;<br>                        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Found zero length selector name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>                        <span class="hljs-keyword">goto</span> errorOut;<br>                    &#125;<br><br>                    <span class="hljs-type">char</span> selectorString[selectorLength + <span class="hljs-number">1</span>];<br><br>                    <span class="hljs-built_in">strncpy</span>(selectorString, next, selectorLength);<br>                    selectorString[selectorLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                    next = nextFlag;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&#x27;G&#x27;</span>)<br>                    attributes-&gt;getter = name;<br>                <span class="hljs-keyword">else</span><br>                    attributes-&gt;setter = name;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>            <span class="hljs-comment">//The property is dynamic (@dynamic).</span><br>            attributes-&gt;dynamic = YES;<br>            attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:<br>            <span class="hljs-comment">// assume that the rest of the string (if present) is the ivar name</span><br>            <span class="hljs-comment">// V 之后的是变量名称</span><br>            <span class="hljs-keyword">if</span> (*next == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>                <span class="hljs-comment">// if there&#x27;s nothing there, let&#x27;s assume this is dynamic</span><br>                attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//取得变量名称</span><br>                attributes-&gt;ivar = next;<br>                next = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>             <span class="hljs-comment">//The property is a weak reference (__weak).</span><br>            attributes-&gt;weak = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;P&#x27;</span>:<br>            <span class="hljs-comment">//The property is eligible for garbage collection.</span><br>            attributes-&gt;canBeCollected = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Old-style type encoding is unsupported in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br><br>            <span class="hljs-comment">// skip over this type encoding</span><br>            <span class="hljs-keyword">while</span> (*next != <span class="hljs-string">&#x27;,&#x27;</span> &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                ++next;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Unrecognized attribute string flag &#x27;%c&#x27; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, flag, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Warning: Unparsed data \&quot;%s\&quot; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, next, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;getter) &#123;<br>        <span class="hljs-comment">// use the property name as the getter by default</span><br>        <span class="hljs-comment">//使用默认的 getter 方法</span><br>        attributes-&gt;getter = <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;setter) &#123;<br>        <span class="hljs-comment">//使用默认的 setter 方法</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propertyName = <span class="hljs-built_in">property_getName</span>(property);<br>        <span class="hljs-type">size_t</span> propertyNameLength = <span class="hljs-built_in">strlen</span>(propertyName);<br><br>        <span class="hljs-comment">// we want to transform the name to setProperty: style</span><br>        <span class="hljs-type">size_t</span> setterLength = propertyNameLength + <span class="hljs-number">4</span>;<br><br>        <span class="hljs-type">char</span> setterName[setterLength + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strncpy</span>(setterName, <span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">strncpy</span>(setterName + <span class="hljs-number">3</span>, propertyName, propertyNameLength);<br><br>        <span class="hljs-comment">// capitalize property name for the setter</span><br>        setterName[<span class="hljs-number">3</span>] = (<span class="hljs-type">char</span>)<span class="hljs-built_in">toupper</span>(setterName[<span class="hljs-number">3</span>]);<br><br>        setterName[setterLength - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;:&#x27;</span>;<br>        setterName[setterLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        attributes-&gt;setter = <span class="hljs-built_in">sel_registerName</span>(setterName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> attributes;<br><br>errorOut:<br>    <span class="hljs-built_in">free</span>(attributes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.在获取了 Mantle 需要的属性之后，接下来就需要做一些转化操作了。MTLJSONAdapter 的类方法 valueTransformersForModelClass 主要是将 JSONKeyPath 的值转成 model 的属性声明的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//对值做类型转化,值类型的转化方法由 model 提供</span><br>+ (NSDictionary *)valueTransformersForModelClass:(Class)modelClass &#123;<br>    <span class="hljs-comment">//基本判断</span><br>    <span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br>    NSMutableDictionary *result = [NSMutableDictionary dictionary];<br>    <br>    <span class="hljs-comment">//依次为每个属性拼接值类型转化方法并判断 model 是否实现了该方法</span><br>    <span class="hljs-keyword">for</span> (NSString *key in [modelClass propertyKeys]) &#123;<br>   <br>        <span class="hljs-comment">// 1、判断 model 是否实现了 +&lt;key&gt;JSONTransformer 类型方法</span><br>        SEL selector = <span class="hljs-built_in">MTLSelectorWithKeyPattern</span>(key, <span class="hljs-string">&quot;JSONTransformer&quot;</span>);<br>        <span class="hljs-comment">//判断是否有实现该方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:selector]) &#123;<br>            <span class="hljs-comment">//取得该方法的实现，调用该方法并获取该方法的返回值</span><br>            IMP imp = [modelClass methodForSelector:selector];<br>            NSValueTransformer * (*function)(id, SEL) = (__typeof__(function))imp;<br>            NSValueTransformer *transformer = <span class="hljs-built_in">function</span>(modelClass, selector);<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、判断 model 是否实现了 +JSONTransformerForKey: 类型方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(JSONTransformerForKey:)]) &#123;<br>            NSValueTransformer *transformer = [modelClass JSONTransformerForKey:key];<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(modelClass, key.UTF8String);<br>        <span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>       <span class="hljs-comment">//将属性的runtime 表示形式 转成 Mantle 的表示形式</span><br>        mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>        @onExit &#123;<br>            <span class="hljs-built_in">free</span>(attributes);<br>        &#125;;<br>      <span class="hljs-comment">//3、其他值类型转化</span><br>        NSValueTransformer *transformer = nil;<br>        <span class="hljs-keyword">if</span> (*(attributes-&gt;type) == *(@<span class="hljs-built_in">encode</span>(id))) &#123;<br>            Class propertyClass = attributes-&gt;objectClass;<br>            <span class="hljs-keyword">if</span> (propertyClass != nil) &#123;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                <span class="hljs-comment">//如果是对象类型，那么取出类型转化的 NSValueTransformer 对象</span><br>                transformer = [self transformerForModelPropertiesOfClass:propertyClass];<br>            &#125;<br>             <span class="hljs-comment">//用于做属性的值类型转换</span><br>            <span class="hljs-keyword">if</span> (transformer == nil) transformer = [NSValueTransformer mtl_validatingTransformerForClass:propertyClass ?: NSObject.<span class="hljs-keyword">class</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//区分BOOL类型</span><br>            transformer = [self transformerForModelPropertiesOfObjCType:attributes-&gt;type] ?: [NSValueTransformer mtl_validatingTransformerForClass:NSValue.<span class="hljs-keyword">class</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 方法完成字典转成 model 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>    <span class="hljs-comment">//判断是否实现 classForParsingJSONDictionary: 协议</span><br>    <span class="hljs-keyword">if</span> ([self.modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(classForParsingJSONDictionary:)]) &#123;<br>        <span class="hljs-comment">//获取Class</span><br>        Class <span class="hljs-keyword">class</span> = [self.modelClass classForParsingJSONDictionary:JSONDictionary];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> == nil) &#123;<br>            <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">//错误处理</span><br>                NSDictionary *userInfo = @&#123;<br>                    NSLocalizedDescriptionKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;Could not parse JSON&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>),<br>                    NSLocalizedFailureReasonErrorKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;No model class could be found to parse the JSON dictionary.&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>)<br>                &#125;;<br>                *error = [NSError errorWithDomain:MTLJSONAdapterErrorDomain code:MTLJSONAdapterErrorNoClassFound userInfo:userInfo];<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> != self.modelClass) &#123;<br>            <span class="hljs-comment">//实现协议判断</span><br>            <span class="hljs-built_in">NSAssert</span>([<span class="hljs-keyword">class</span> conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)], @<span class="hljs-string">&quot;Class %@ returned from +classForParsingJSONDictionary: does not conform to &lt;MTLJSONSerializing&gt;&quot;</span>, <span class="hljs-keyword">class</span>);<br><br>            MTLJSONAdapter *otherAdapter = [self JSONAdapterForModelClass:<span class="hljs-keyword">class</span> error:error];<br><br>            <span class="hljs-keyword">return</span> [otherAdapter modelFromJSONDictionary:JSONDictionary error:error];<br>        &#125;<br>    &#125;<br><br>    NSMutableDictionary *dictionaryValue = [[NSMutableDictionary alloc] initWithCapacity:JSONDictionary.count];<br>    <span class="hljs-comment">//取出 model 的属性 key</span><br>    <span class="hljs-keyword">for</span> (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;<br>        <span class="hljs-comment">//取出JSONKeyPath</span><br>        id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];<br><br>        <span class="hljs-keyword">if</span> (JSONKeyPaths == nil) <span class="hljs-keyword">continue</span>;<br><br>        id value;<br>        <span class="hljs-comment">//TODO 这个判断数组的用处？</span><br>        <span class="hljs-keyword">if</span> ([JSONKeyPaths isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br>            NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];<br>            <span class="hljs-keyword">for</span> (NSString *keyPath in JSONKeyPaths) &#123;<br>                BOOL success;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];<br>                <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                <span class="hljs-keyword">if</span> (value != nil) dictionary[keyPath] = value;<br>            &#125;<br>            value = dictionary;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            BOOL success;<br>           <span class="hljs-comment">//取出字典中JSONKeyPaths对应的值</span><br>           <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>            value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];<br>            <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value == nil) <span class="hljs-keyword">continue</span>;<br>        @<span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//取出值转化的 NSValueTransformer 对象，若是对象为空则说明该 propertyKey 不需要做值转化</span><br>            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];<br>            <span class="hljs-keyword">if</span> (transformer != nil) &#123;<br>                <span class="hljs-comment">// Map NSNull -&gt; nil for the transformer, and then back for the</span><br>                <span class="hljs-comment">// dictionary we&#x27;re going to insert into.</span><br>                <span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil;<br>                <span class="hljs-comment">//值转化操作</span><br>                <span class="hljs-keyword">if</span> ([transformer respondsToSelector:@<span class="hljs-built_in">selector</span>(transformedValue:success:error:)]) &#123;<br>                <span class="hljs-comment">//转化过程有回调 </span><br>                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;<br>                    BOOL success = YES;<br>                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];<br>                    <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不需要转化过程回调，直接转化</span><br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                    value = [transformer transformedValue:value];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (value == nil) value = NSNull.null;<br>            &#125;<br>            <span class="hljs-comment">// 保存被 NSValueTransformer 转化过的 JSONKeyPath 的值</span><br>            dictionaryValue[propertyKey] = value;<br>        &#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br>           <span class="hljs-comment">//省略错误处理代码</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;</span>, ex, JSONKeyPaths, JSONDictionary);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将字典转换成 model </span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>    id model = [self.modelClass modelWithDictionary:dictionaryValue error:error];<br>    <span class="hljs-comment">//进行错误验证</span><br>    <span class="hljs-keyword">return</span> [model validate:error] ? model : nil;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>9.NSDictionary+MTLJSONKeyPath 的 - (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error; 方法作用在于根据 JSONKeyPath 从 JSON 字典中取出对应的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error &#123;<br>    <span class="hljs-comment">//TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</span><br>NSArray *components = [JSONKeyPath componentsSeparatedByString:@<span class="hljs-string">&quot;.&quot;</span>];<br>id result = self;<span class="hljs-comment">//字典</span><br><span class="hljs-keyword">for</span> (NSString *component in components) &#123;<br><span class="hljs-comment">// Check the result before resolving the key path component to not</span><br><span class="hljs-comment">// affect the last value of the path.</span><br><span class="hljs-keyword">if</span> (result == nil || result == NSNull.null) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (![result isKindOfClass:NSDictionary.<span class="hljs-keyword">class</span>]) &#123;<br>                 <span class="hljs-comment">//错误处理代码</span><br>&#125;<br>        <span class="hljs-comment">//以JSONKeyPath为key取出JSON字典中的值</span><br>result = result[component];<br>&#125;<br><br><span class="hljs-keyword">if</span> (success != <span class="hljs-literal">NULL</span>) *success = YES;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>10.在取得了JSONKeyPath对应的 value 之后，那么下一步操作就是要根据 model 值转化方法返回的 NSValueTransformer 对象做值转化操作</p><p>MTLValueTransformer 是一个基于 block 操作的值转化对象，实现 JSON字典–&gt;model 的转化。而MTLReversibleValueTransformer<br>实现逆向转化操作。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled13.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>@implementation MTLValueTransformer<br><br><span class="hljs-comment">//转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.forwardBlock(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.forwardBlock(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br><br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br><br><span class="hljs-comment">//反向转化 model --&gt; JSON 字典</span><br>@implementation MTLReversibleValueTransformer<br><span class="hljs-comment">//反向转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现反向转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br>    <br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>11.在处理的值转化之后，那么接下来就是要将从 JSON 字典中获取的 model 属性值赋值给对应的 model 对象了。在 MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 的实现中的最后一部分代码就是用来生成对应的 model 对象的。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled14.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//MTLModel  代码片段</span><br><br><span class="hljs-comment">//使用字典初始化 model </span><br>+ (instancetype)modelWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br><span class="hljs-keyword">return</span> [[self alloc] initWithDictionary:dictionary error:error];<br>&#125;<br>......<br><span class="hljs-comment">//使用字典初始化 model </span><br>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br>self = [self init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br>       <span class="hljs-comment">//取出NSDictionary的key</span><br><span class="hljs-keyword">for</span> (NSString *key in dictionary) &#123;<br><span class="hljs-comment">// Mark this as being autoreleased, because validateValue may return</span><br><span class="hljs-comment">// a new object to be stored in this variable (and we don&#x27;t want ARC to</span><br><span class="hljs-comment">// double-free or leak the old or new values).</span><br>__autoreleasing id value = [dictionary objectForKey:key];<br><span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil; <br>        <span class="hljs-comment">//判断 model 的这个属性是否可以采用 KVC 来给属性赋值</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, YES, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>&#125;<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br><br><br><span class="hljs-comment">//判断 model 的某个属性是否可以采用 KVC 来给属性赋值，然后根据赋值条件给予赋值</span><br><span class="hljs-function"><span class="hljs-type">static</span> BOOL <span class="hljs-title">MTLValidateAndSetValue</span><span class="hljs-params">(id obj, NSString *key, id value, BOOL forceUpdate, NSError **error)</span> </span>&#123;<br>__autoreleasing id validatedValue = value;<br>@<span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当开发者需要验证能不能用KVC设定某个值时，可以调用validateValue: forKey:这个方法来验证</span><br>        <span class="hljs-comment">// 这个方法的默认实现是去类里面寻找是否有一个这样的方法：-(BOOL)validate&lt;Key&gt;:error:</span><br>        <span class="hljs-comment">// 如果有这个方法，就以这个方法的返回值作为判断标准，没有的话就直接返回YES</span><br><span class="hljs-keyword">if</span> (![obj validateValue:&amp;validatedValue forKey:key error:error]) <span class="hljs-keyword">return</span> NO;<br>        <span class="hljs-comment">// 设置新值</span><br>        <span class="hljs-comment">// obj 返回的 validatedValue 与 传进来的参数 value 进行对比，若不一致采用validatedValue的值</span><br>        <span class="hljs-comment">// forceUpdate 为 YES 那么也是直接给 key 设置值</span><br><span class="hljs-keyword">if</span> (forceUpdate || value != validatedValue) &#123;<br>[obj setValue:validatedValue forKey:key];<br>&#125;<br><span class="hljs-keyword">return</span> YES;<br>&#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br><span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception setting key \&quot;%@\&quot; : %@&quot;</span>, key, ex);<br><span class="hljs-comment">//错误处理代码</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// model 的属性验证，只做验证处理，不做赋值操作</span><br>- (BOOL)validate:(NSError **)error &#123;<br><span class="hljs-keyword">for</span> (NSString *key in self.<span class="hljs-keyword">class</span>.propertyKeys) &#123;<br>id value = [self valueForKey:key];<br>        <span class="hljs-comment">//验证 model 是否有某个属性不能使用 KVC 赋值，若是有属性无法通过 KVC 赋值那么返回 NO。 此时 JSON 字典 --&gt; model 过程会得到一个 nil 对象，model 转化失败</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, NO, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br><span class="hljs-keyword">return</span> YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>12.Mantle完成最后的 model 属性验证之后，返回相关的 model 对象。至此 Mantle 的 JSON 字典 –&gt; model 过程就完成了。</p><p>13.TODO 的应用场景说明<br> 在文中有 2 个 TODO  说明，限于篇幅统一放在这里说明。可以搜索 TODO 关键字找到文章做 TODO 标记文职<br>&#x2F;&#x2F; TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                               @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span><br>                          &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下可能想把 temp 和 temp_max 放到一个字典当中。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSDictionary *temp;<br><br>@end<br><span class="hljs-comment">// temp 和 temp_max 放到一个字典当中 ,那么 JSONKeyPathsByPropertyKey 方法做如下实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:[NSArray arrayWithObjects:@<span class="hljs-string">&quot;temp&quot;</span>, @<span class="hljs-string">&quot;temp_max&quot;</span>,nil]<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;weather&quot;</span>:@&#123;<br>                                       @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_min&quot;</span> : @<span class="hljs-string">&quot;53.01&quot;</span><br>                                       &#125;<br>                               &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法会再给 TestModel 新建一个名为 weather 的对象属性</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) Weather *weather;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下并不想给 TestModel 新建对象属性，而是把 JSON 字典中所有层级的 JSONKeyPath 都放到第一层级来。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_min;<br>@end<br><span class="hljs-comment">//JSON 字典中所有层级的 JSONKeyPath 都放到第一层级,那么 JSONKeyPathsByPropertyKey 方法需要做好对应的层级关系实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:@<span class="hljs-string">&quot;weather.temp&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_max&quot;</span>:@<span class="hljs-string">&quot;weather.temp_max&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_min&quot;</span>:@<span class="hljs-string">&quot;weather.temp_min&quot;</span>,<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mantle 作为一款经典的 JSON 字典 &lt;–&gt; model 转化模型框架，主要是利用 KVC 特性为 model 赋值,其框架设计有不少优点，比如值转化过程的设计等，阅读优秀的开源项目不仅可以扩大技术眼界，也可以增加对代码细节的把控能力。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://github.com/Mantle/Mantle">https://github.com/Mantle/Mantle</a><br><a href="http://southpeak.github.io/2015/01/11/sourcecode-mantle/">http://southpeak.github.io/2015/01/11/sourcecode-mantle/</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a><br><a href="http://www.jianshu.com/p/f49ddbf8a2ea">http://www.jianshu.com/p/f49ddbf8a2ea</a><br><a href="http://www.jianshu.com/p/9f039124efef">http://www.jianshu.com/p/9f039124efef</a><br><a href="https://github.com/johnno1962/Xtrace">https://github.com/johnno1962/Xtrace</a><br><a href="http://nshipster.com/nsvaluetransformer/">http://nshipster.com/nsvaluetransformer/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS GIF 动画加载框架 - FLAnimatedImage 解读</title>
    <link href="/2016/08/31/reading-source-code-of-FLAnimatedImage/"/>
    <url>/2016/08/31/reading-source-code-of-FLAnimatedImage/</url>
    
    <content type="html"><![CDATA[<h1 id="FLAnimatedImage-解读"><a href="#FLAnimatedImage-解读" class="headerlink" title="FLAnimatedImage 解读"></a>FLAnimatedImage 解读</h1><p><a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> 是由Flipboard开源的iOS平台上播放GIF动画的一个优秀解决方案，在内存占用和播放体验都有不错的表现。<br>本文章主要是介绍FLAnimatedImage框架的GIF动画加载和播放流程，旨在说明流程和主要细节点，大家可以参考流程进行源码解读并调试，相信可以得到大量有用信息。<br>文章不免有不足或者错误之处，请大家在下方评论指出，我会尽快修正 l-(&gt;-&lt;)-l 。</p><h3 id="FLAnimatedImage简单流程图"><a href="#FLAnimatedImage简单流程图" class="headerlink" title="FLAnimatedImage简单流程图"></a>FLAnimatedImage简单流程图</h3><p>FLAnimatedImage项目的流程比较简单，FLAnimatedImage就是负责GIF数据的处理，然后提供给FLAnimatedImageView一个UIImage对象。FLAnimatedImageView拿到UIImage对象显示出来就可以了。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage使用"><a href="#FLAnimatedImage使用" class="headerlink" title="FLAnimatedImage使用"></a>FLAnimatedImage使用</h3><p>使用FLAnimatedImage处理GIF动画数据，使用FLAnimatedImageView展示FLAnimatedImage处理后的动画数据。</p><ul><li><p>使用NSData初始化FLAnimatedImage,然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView1) &#123;<br>       self.imageView1 = [[FLAnimatedImageView alloc] init];<br>       self.imageView1.contentMode = UIViewContentModeScaleAspectFill;<br>       self.imageView1.clipsToBounds = YES;<br>   &#125;<br>   [self.view addSubview:self.imageView1];<br>   self.imageView1.frame = CGRectMake(0.0, 120.0, self.view.bounds.size.width, 447.0);   <br>   NSURL *url1 = [[NSBundle mainBundle] URLForResource:@&quot;rock&quot; withExtension:@&quot;gif&quot;];<br>   NSData *data1 = [NSData dataWithContentsOfURL:url1];<br>   FLAnimatedImage *animatedImage1 = [FLAnimatedImage animatedImageWithGIFData:data1];<br>   self.imageView1.animatedImage = animatedImage1;<br></code></pre></td></tr></table></figure></li><li><p>使用URL初始化FLAnimatedImage，然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView2) &#123;<br>    self.imageView2 = [[FLAnimatedImageView alloc] init];<br>    self.imageView2.contentMode = UIViewContentModeScaleAspectFill;<br>    self.imageView2.clipsToBounds = YES;<br>&#125;<br>[self.view addSubview:self.imageView2];<br>self.imageView2.frame = CGRectMake(0.0, 577.0, 379.0, 447.0);<br><br>NSURL *url2 = [NSURL URLWithString:@&quot;https://cloud.githubusercontent.com/assets/1567433/10417835/1c97e436-7052-11e5-8fb5-69373072a5a0.gif&quot;];<br>[self loadAnimatedImageWithURL:url2 completion:^(FLAnimatedImage *animatedImage) &#123;<br>    self.imageView2.animatedImage = animatedImage;<br>&#125;];<br></code></pre></td></tr></table></figure></li></ul><h3 id="FLAnimatedImage项目代码结构"><a href="#FLAnimatedImage项目代码结构" class="headerlink" title="FLAnimatedImage项目代码结构"></a>FLAnimatedImage项目代码结构</h3><p> FLAnimatedImage项目采用了“生产者和消费者”模型来处理这个GIF动画的播放问题。一个线程负责生产数据，另一个线程负责消费数据。生产者FLAnimatedImage负责提供帧UIImage对象，消费者FLAnimatedImageView负责显示该UIImage对象。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled1.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage接口"><a href="#FLAnimatedImage接口" class="headerlink" title="FLAnimatedImage接口"></a>FLAnimatedImage接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">@property (nonatomic, strong, readonly) UIImage *posterImage;//GIF动画的封面帧图片<br>@property (nonatomic, assign, readonly) CGSize size; //GIF动画的封面帧图片的尺寸<br>@property (nonatomic, assign, readonly) NSUInteger loopCount; //GIF动画的循环播放次数<br>@property (nonatomic, strong, readonly) NSDictionary *delayTimesForIndexes; // GIF动画中的每帧图片的显示时间集合<br>@property (nonatomic, assign, readonly) NSUInteger frameCount; //GIF动画的帧数量<br>@property (nonatomic, assign, readonly) NSUInteger frameCacheSizeCurrent; //当前被缓存的帧图片的总数量<br>@property (nonatomic, assign) NSUInteger frameCacheSizeMax; // 允许缓存多少帧图片<br><br>// Intended to be called from main thread synchronously; will return immediately.<br>// If the result isn&#x27;t cached, will return `nil`; the caller should then pause playback, not increment frame counter and keep polling.<br>// After an initial loading time, depending on `frameCacheSize`, frames should be available immediately from the cache.<br>// 取出对应索引的帧图片<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index;<br><br>// Pass either a `UIImage` or an `FLAnimatedImage` and get back its size<br>// 计算该帧图片的尺寸<br>+ (CGSize)sizeForImage:(id)image;<br><br>// 初始化方法<br>// On success, the initializers return an `FLAnimatedImage` with all fields initialized, on failure they return `nil` and an error will be logged.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data;<br>// Pass 0 for optimalFrameCacheSize to get the default, predrawing is enabled by default.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled NS_DESIGNATED_INITIALIZER;<br>+ (instancetype)animatedImageWithGIFData:(NSData *)data;<br><br>//初始化数据<br>@property (nonatomic, strong, readonly) NSData *data; // The data the receiver was initialized with; read-only<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImage解析"><a href="#FLAnimatedImage解析" class="headerlink" title="FLAnimatedImage解析"></a>FLAnimatedImage解析</h3><ul><li>关键方法 初始化解析<br>a、对传进来的数据进行合法性判断，至少不能为nil。<br>b、初始化对应的变量，用于存储各类辅助数据。<br>c、将传进来的数据处理成图片数据，根据 kCGImageSourceShouldCache 的官方文档描述 <strong>Whether the image should be cached in a decoded form. The value of this key must be a CFBoolean value. The default value is kCFBooleanFalse in 32-bit, kCFBooleanTrue in 64-bit.</strong>  所以设置 kCGImageSourceShouldCache为NO,可以避免系统对图片进行缓存，<br>d、从数据中读取图片类型，判断该图片是不是GIF动画类型。<br>e、读取GIF动画中的动画信息，包括动画循环次数，有几帧图片等。<br>f、遍历GIF动画中的所有帧图片，取出并保存帧图片的播放信息，设置GIF动画的封面帧图片<br>g、根据设置或者GIF动画的占用内存大小，与缓存策略对比，确认缓存策略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled<br>&#123;<br>    // 1、进行数据合法性判断<br>    BOOL hasData = ([data length] &gt; 0);<br>    if (!hasData) &#123;<br>        FLLog(FLLogLevelError, @&quot;No animated GIF data supplied.&quot;);<br>        return nil;<br>    &#125;<br>    <br>    self = [super init];<br>    if (self) &#123;<br>        // 2、初始化对应的变量<br>        // Do one-time initializations of `readonly` properties directly to ivar to prevent implicit actions and avoid need for private `readwrite` property overrides.<br>        // Keep a strong reference to `data` and expose it read-only publicly.<br>        // However, we will use the `_imageSource` as handler to the image data throughout our life cycle.<br>        _data = data;<br>        _predrawingEnabled = isPredrawingEnabled;<br>        <br>        // Initialize internal data structures<br>        _cachedFramesForIndexes = [[NSMutableDictionary alloc] init];//key-&gt;帧图片在GIF动画的索引位置 value-&gt;单帧图片<br>        _cachedFrameIndexes = [[NSMutableIndexSet alloc] init];//缓存的帧图片在GIF动画的索引位置集合<br>        _requestedFrameIndexes = [[NSMutableIndexSet alloc] init];//需要生产者生产的的帧图片的索引位置<br><br>        // 3、创建图片数据<br>        // Note: We could leverage `CGImageSourceCreateWithURL` too to add a second initializer `-initWithAnimatedGIFContentsOfURL:`.<br>        _imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)data,<br>                                                   (__bridge CFDictionaryRef)@&#123;(NSString *)kCGImageSourceShouldCache: @NO&#125;);<br>        // Early return on failure!<br>        if (!_imageSource) &#123;<br>            FLLog(FLLogLevelError, @&quot;Failed to `CGImageSourceCreateWithData` for animated GIF data %@&quot;, data);<br>            return nil;<br>        &#125;<br>        // 4、取出图片类型，判断是否是GIF动画<br>        // Early return if not GIF!<br>        CFStringRef imageSourceContainerType = CGImageSourceGetType(_imageSource);<br>        BOOL isGIFData = UTTypeConformsTo(imageSourceContainerType, kUTTypeGIF);<br>        if (!isGIFData) &#123;<br>            FLLog(FLLogLevelError, @&quot;Supplied data is of type %@ and doesn&#x27;t seem to be GIF data %@&quot;, imageSourceContainerType, data);<br>            return nil;<br>        &#125;<br>        // 5、取出GIF动画信息<br>        // Get `LoopCount`<br>        // Note: 0 means repeating the animation indefinitely.<br>        // Image properties example:<br>        // &#123;<br>        //     FileSize = 314446;<br>        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>        //         HasGlobalColorMap = 1;<br>        //         LoopCount = 0;<br>        //     &#125;;<br>        // &#125;<br>        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(_imageSource, NULL);<br>        //获取GIF动画循环次数<br>        _loopCount = [[[imageProperties objectForKey:(id)kCGImagePropertyGIFDictionary] objectForKey:(id)kCGImagePropertyGIFLoopCount] unsignedIntegerValue];<br>        <br>        // Iterate through frame images<br>        //遍历图片<br>        size_t imageCount = CGImageSourceGetCount(_imageSource);<br>        NSUInteger skippedFrameCount = 0;//用于记录GIF动画中异常帧的数量<br>        NSMutableDictionary *delayTimesForIndexesMutable = [NSMutableDictionary dictionaryWithCapacity:imageCount];//记录GIF动画中每帧图片的显示时间<br>        for (size_t i = 0; i &lt; imageCount; i++) &#123;<br>            @autoreleasepool &#123;<br>                // 6、取出帧图片<br>                //Return the image at `index&#x27; in the image source `isrc&#x27;.<br>                CGImageRef frameImageRef = CGImageSourceCreateImageAtIndex(_imageSource, i, NULL);<br>                if (frameImageRef) &#123;<br>                    UIImage *frameImage = [UIImage imageWithCGImage:frameImageRef];<br>                    // Check for valid `frameImage` before parsing its properties as frames can be corrupted (and `frameImage` even `nil` when `frameImageRef` was valid).<br>                    if (frameImage) &#123;<br>                        // Set poster image<br>                        // 取出的第一张图片为GIF动画的封面图片<br>                        if (!self.posterImage) &#123;<br>                            _posterImage = frameImage;<br>                            // Set its size to proxy our size.<br>                            _size = _posterImage.size;<br>                            // Remember index of poster image so we never purge it; also add it to the cache.<br>                            _posterImageFrameIndex = i;<br>                            [self.cachedFramesForIndexes setObject:self.posterImage forKey:@(self.posterImageFrameIndex)];<br>                            [self.cachedFrameIndexes addIndex:self.posterImageFrameIndex];<br>                        &#125;<br>                        // 7、取出帧图片的信息<br>                        // Get `DelayTime`<br>                        // Note: It&#x27;s not in (1/100) of a second like still falsely described in the documentation as per iOS 8 (rdar://19507384) but in seconds stored as `kCFNumberFloat32Type`.<br>                        // Frame properties example:<br>                        // &#123;<br>                        //     ColorModel = RGB;<br>                        //     Depth = 8;<br>                        //     PixelHeight = 960;<br>                        //     PixelWidth = 640;<br>                        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>                        //         DelayTime = &quot;0.4&quot;;<br>                        //         UnclampedDelayTime = &quot;0.4&quot;;<br>                        //     &#125;;<br>                        // &#125;<br>                        <br>                        NSDictionary *frameProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyPropertiesAtIndex(_imageSource, i, NULL);<br>                        NSDictionary *framePropertiesGIF = [frameProperties objectForKey:(id)kCGImagePropertyGIFDictionary];<br>                        <br>                        // 8、取出帧图片的展示时间<br>                        // Try to use the unclamped delay time; fall back to the normal delay time.<br>                        NSNumber *delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFUnclampedDelayTime];<br>                        if (!delayTime) &#123;<br>                            delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFDelayTime];<br>                        &#125;<br>                        // If we don&#x27;t get a delay time from the properties, fall back to `kDelayTimeIntervalDefault` or carry over the preceding frame&#x27;s value.<br>                        const NSTimeInterval kDelayTimeIntervalDefault = 0.1;<br>                        if (!delayTime) &#123;<br>                            if (i == 0) &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to default delay time for first frame %@ because none found in GIF properties %@&quot;, frameImage, frameProperties);<br>                                delayTime = @(kDelayTimeIntervalDefault);<br>                            &#125; else &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to preceding delay time for frame %zu %@ because none found in GIF properties %@&quot;, i, frameImage, frameProperties);<br>                                delayTime = delayTimesForIndexesMutable[@(i - 1)];<br>                            &#125;<br>                        &#125;<br>                        // Support frame delays as low as `kFLAnimatedImageDelayTimeIntervalMinimum`, with anything below being rounded up to `kDelayTimeIntervalDefault` for legacy compatibility.<br>                        // To support the minimum even when rounding errors occur, use an epsilon when comparing. We downcast to float because that&#x27;s what we get for delayTime from ImageIO.<br>                        if ([delayTime floatValue] &lt; ((float)kFLAnimatedImageDelayTimeIntervalMinimum - FLT_EPSILON)) &#123;<br>                            FLLog(FLLogLevelInfo, @&quot;Rounding frame %zu&#x27;s `delayTime` from %f up to default %f (minimum supported: %f).&quot;, i, [delayTime floatValue], kDelayTimeIntervalDefault, kFLAnimatedImageDelayTimeIntervalMinimum);<br>                            delayTime = @(kDelayTimeIntervalDefault);<br>                        &#125;<br>                        delayTimesForIndexesMutable[@(i)] = delayTime;<br>                    &#125; else &#123;<br>                        skippedFrameCount++;<br>                        FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because valid `CGImageRef` %@ did result in `nil`-`UIImage`.&quot;, i, frameImageRef);<br>                    &#125;<br>                    CFRelease(frameImageRef);<br>                &#125; else &#123;<br>                    skippedFrameCount++;<br>                    FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because failed to `CGImageSourceCreateImageAtIndex` with image source %@&quot;, i, _imageSource);<br>                &#125;<br>            &#125;<br>        &#125;<br>        //帧图片展示时间的数组<br>        _delayTimesForIndexes = [delayTimesForIndexesMutable copy];<br>        //GIF动画有多少帧图片<br>        _frameCount = imageCount;<br>        <br>        if (self.frameCount == 0) &#123;<br>            FLLog(FLLogLevelInfo, @&quot;Failed to create any valid frames for GIF with properties %@&quot;, imageProperties);<br>            return nil;<br>        &#125; else if (self.frameCount == 1) &#123;<br>            // Warn when we only have a single frame but return a valid GIF.<br>            FLLog(FLLogLevelInfo, @&quot;Created valid GIF but with only a single frame. Image properties: %@&quot;, imageProperties);<br>        &#125; else &#123;<br>            // We have multiple frames, rock on!<br>        &#125;<br>        // 9、GIF动画缓存策略<br>        // If no value is provided, select a default based on the GIF.<br>        if (optimalFrameCacheSize == 0) &#123;<br>            // Calculate the optimal frame cache size: try choosing a larger buffer window depending on the predicted image size.<br>            // It&#x27;s only dependent on the image size &amp; number of frames and never changes.<br>            // 图片的每行字节大小*高*图片数量/1M的字节 = GIF大小（M）<br>            // 根据GIF图的大小和缓存策略判断需要缓存的单帧图片数量<br>            <br>            //GIF动画的占用内存大小与FLAnimatedImageDataSizeCategory的方案比较，确认缓存策略<br>            CGFloat animatedImageDataSize = CGImageGetBytesPerRow(self.posterImage.CGImage) * self.size.height * (self.frameCount - skippedFrameCount) / MEGABYTE;<br>            if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryAll) &#123;<br>                _frameCacheSizeOptimal = self.frameCount;<br>            &#125; else if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryDefault) &#123;<br>                // This value doesn&#x27;t depend on device memory much because if we&#x27;re not keeping all frames in memory we will always be decoding 1 frame up ahead per 1 frame that gets played and at this point we might as well just keep a small buffer just large enough to keep from running out of frames.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeDefault;<br>            &#125; else &#123;<br>                // The predicted size exceeds the limits to build up a cache and we go into low memory mode from the beginning.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeLowMemory;<br>            &#125;<br>        &#125; else &#123;<br>            // Use the provided value.<br>            _frameCacheSizeOptimal = optimalFrameCacheSize;<br>        &#125;<br>        // In any case, cap the optimal cache size at the frame count.<br>        // _frameCacheSizeOptimal 不能大于 self.frameCount<br>        // 确认最佳的GIF动画的帧图片缓存数量<br>        _frameCacheSizeOptimal = MIN(_frameCacheSizeOptimal, self.frameCount);<br>        <br>        // Convenience/minor performance optimization; keep an index set handy with the full range to return in `-frameIndexesToCache`.<br>        _allFramesIndexSet = [[NSIndexSet alloc] initWithIndexesInRange:NSMakeRange(0, self.frameCount)];<br>        <br>        // See the property declarations for descriptions.<br>        //成为FLWeakProxy的代理<br>        _weakProxy = (id)[FLWeakProxy weakProxyForObject:self];<br>        <br>        // Register this instance in the weak table for memory notifications. The NSHashTable will clean up after itself when we&#x27;re gone.<br>        // Note that FLAnimatedImages can be created on any thread, so the hash table must be locked.<br>        @synchronized(allAnimatedImagesWeak) &#123;<br>            [allAnimatedImagesWeak addObject:self];<br>        &#125;<br>    &#125;<br>    return self;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 取UIImage对象<br>a、对索引位置进行判断，避免出现越界情况<br>b、记录当前取出的帧图片的索引位置<br>c、根据缓存策略判断接下来需要生产的帧图片索引，正常是当前显示帧图片之后的帧图片的索引。<br>d、根据需要生产的帧图片索引生产帧图片<br>e、取出对应的帧图片<br>f、根据缓存策略清缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// See header for more details.<br>// Note: both consumer and producer are throttled: consumer by frame timings and producer by the available memory (max buffer window size).<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index<br>&#123;<br>    // Early return if the requested index is beyond bounds.<br>    // Note: We&#x27;re comparing an index with a count and need to bail on greater than or equal to.<br>    // 1、索引位置判断<br>    if (index &gt;= self.frameCount) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Skipping requested frame %lu beyond bounds (total frame count: %lu) for animated image: %@&quot;, (unsigned long)index, (unsigned long)self.frameCount, self);<br>        return nil;<br>    &#125;<br>    <br>    // Remember requested frame index, this influences what we should cache next.<br>    // 2、记录当前要生产的帧图片在GIF动画中的索引位置<br>    self.requestedFrameIndex = index;<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>    if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImage:didRequestCachedFrame:)]) &#123;<br>        [self.debug_delegate debug_animatedImage:self didRequestCachedFrame:index];<br>    &#125;<br>#endif<br>    <br>    // Quick check to avoid doing any work if we already have all possible frames cached, a common case.<br>    // 3、判断GIF动画的帧图片的是否全部缓存下来了,因为有可能缓存策略是缓存所有的帧图片<br>    if ([self.cachedFrameIndexes count] &lt; self.frameCount) &#123;<br>        // If we have frames that should be cached but aren&#x27;t and aren&#x27;t requested yet, request them.<br>        // Exclude existing cached frames, frames already requested, and specially cached poster image.<br>        // 4、根据缓存策略得到接下来需要缓存的帧图片索引，<br>        NSMutableIndexSet *frameIndexesToAddToCacheMutable = [self frameIndexesToCache];<br>        // 5、除去已经缓存下来的帧图片索引<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.cachedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.requestedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndex:self.posterImageFrameIndex];<br>        NSIndexSet *frameIndexesToAddToCache = [frameIndexesToAddToCacheMutable copy];<br>        <br>        // Asynchronously add frames to our cache.<br>        if ([frameIndexesToAddToCache count] &gt; 0) &#123;<br>            // 6、生产帧图片<br>            [self addFrameIndexesToCache:frameIndexesToAddToCache];<br>        &#125;<br>    &#125;<br>    <br>    // Get the specified image.<br>    // 7、取出帧图片<br>    UIImage *image = self.cachedFramesForIndexes[@(index)];<br>    <br>    // Purge if needed based on the current playhead position.<br>    // 8、根据缓存策略清缓存<br>    [self purgeFrameCacheIfNeeded];<br>    <br>    return image;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他关键方法简单介绍</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// Only called once from `-imageLazilyCachedAtIndex` but factored into its own method for logical grouping.<br>// 生产帧图片<br>- (void)addFrameIndexesToCache:(NSIndexSet *)frameIndexesToAddToCache;<br><br>// 取出GIF动画的帧图片<br>- (UIImage *)imageAtIndex:(NSUInteger)index;<br><br>// Decodes the image&#x27;s data and draws it off-screen fully in memory; it&#x27;s thread-safe and hence can be called on a background thread.<br>// On success, the returned object is a new `UIImage` instance with the same content as the one passed in.<br>// On failure, the returned object is the unchanged passed in one; the data will not be predrawn in memory though and an error will be logged.<br>// First inspired by &amp; good Karma to: https://gist.github.com/steipete/1144242<br>// 解码图片<br>+ (UIImage *)predrawnImageFromImage:(UIImage *)imageToPredraw;<br><br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView接口"><a href="#FLAnimatedImageView接口" class="headerlink" title="FLAnimatedImageView接口"></a>FLAnimatedImageView接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C"><br>// FLAnimatedImageView是UIImageView的子类，完全兼容UIImageView的各个方法。<br><br>//  An `FLAnimatedImageView` can take an `FLAnimatedImage` and plays it automatically when in view hierarchy and stops when removed.<br>//  The animation can also be controlled with the `UIImageView` methods `-start/stop/isAnimating`.<br>//  It is a fully compatible `UIImageView` subclass and can be used as a drop-in component to work with existing code paths expecting to display a `UIImage`.<br>//  Under the hood it uses a `CADisplayLink` for playback, which can be inspected with `currentFrame` &amp; `currentFrameIndex`.<br>//<br>@interface FLAnimatedImageView : UIImageView<br><br>// Setting `[UIImageView.image]` to a non-`nil` value clears out existing `animatedImage`.<br>// And vice versa, setting `animatedImage` will initially populate the `[UIImageView.image]` to its `posterImage` and then start animating and hold `currentFrame`.<br>@property (nonatomic, strong) FLAnimatedImage *animatedImage;//设置GIF动画数据<br>@property (nonatomic, copy) void(^loopCompletionBlock)(NSUInteger loopCountRemaining);//GIF动画播放一次之后的回调Block<br><br>@property (nonatomic, strong, readonly) UIImage *currentFrame;//GIF动画当前显示的帧图片<br>@property (nonatomic, assign, readonly) NSUInteger currentFrameIndex;//GIF动画当前显示的帧图片索引<br><br>// The animation runloop mode. Enables playback during scrolling by allowing timer events (i.e. animation) with NSRunLoopCommonModes.<br>// To keep scrolling smooth on single-core devices such as iPhone 3GS/4 and iPod Touch 4th gen, the default run loop mode is NSDefaultRunLoopMode. Otherwise, the default is NSDefaultRunLoopMode.<br>@property (nonatomic, copy) NSString *runLoopMode;<br><br>@end<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView解析"><a href="#FLAnimatedImageView解析" class="headerlink" title="FLAnimatedImageView解析"></a>FLAnimatedImageView解析</h3><ul><li>关键方法 设置FLAnimatedImage对象解析<br>a、判断新旧FLAnimatedImage对象是否一致，一致就不需要继续操作了<br>b、设置GIF动画的封面帧图片，当前帧索引，GIF动画的循环播放次数，播放时间累加器<br>c、更新是否发起动画的标志位，判断是否启动GIF动画<br>d、刷新View的layer</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)setAnimatedImage:(FLAnimatedImage *)animatedImage<br>&#123;<br>    //新设置的GIF动画数据和当前的数据不一致<br>    if (![_animatedImage isEqual:animatedImage]) &#123;<br>        if (animatedImage) &#123;<br>            // Clear out the image.<br>            super.image = nil;<br>            // Ensure disabled highlighting; it&#x27;s not supported (see `-setHighlighted:`).<br>            super.highlighted = NO;<br>            // UIImageView seems to bypass some accessors when calculating its intrinsic content size, so this ensures its intrinsic content size comes from the animated image.<br>            //确保UIImageView的content size 大小来自 animated image<br>            [self invalidateIntrinsicContentSize];<br>        &#125; else &#123;<br>            // Stop animating before the animated image gets cleared out.<br>            // animatedImage为nil，需要清空当前动画图片<br>            [self stopAnimating];<br>        &#125;<br>        <br>        _animatedImage = animatedImage;<br>        <br>        self.currentFrame = animatedImage.posterImage;//GIF动画的封面帧图片<br>        self.currentFrameIndex = 0;//当前的帧图片索引<br>        //设置GIF动画的循环播放次数<br>        if (animatedImage.loopCount &gt; 0) &#123;<br>            self.loopCountdown = animatedImage.loopCount;<br>        &#125; else &#123;<br>            self.loopCountdown = NSUIntegerMax;<br>        &#125;<br>        //播放时间累加器<br>        self.accumulator = 0.0;<br>        <br>        // Start animating after the new animated image has been set.<br>        [self updateShouldAnimate];<br>        if (self.shouldAnimate) &#123;<br>            [self startAnimating];<br>        &#125;<br>        <br>        [self.layer setNeedsDisplay];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 设置CADisplayLink的frameInterval</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)startAnimating<br>&#123;<br>    //使用CADisplayLink来播放GIF动画<br>    if (self.animatedImage) &#123;<br>        // Lazily create the display link.<br>        if (!self.displayLink) &#123;<br>            // It is important to note the use of a weak proxy here to avoid a retain cycle. `-displayLinkWithTarget:selector:`<br>            // will retain its target until it is invalidated. We use a weak proxy so that the image view will get deallocated<br>            // independent of the display link&#x27;s lifetime. Upon image view deallocation, we invalidate the display<br>            // link which will lead to the deallocation of both the display link and the weak proxy.<br>            FLWeakProxy *weakProxy = [FLWeakProxy weakProxyForObject:self];<br>            self.displayLink = [CADisplayLink displayLinkWithTarget:weakProxy selector:@selector(displayDidRefresh:)];<br>            <br>            [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:self.runLoopMode];<br>        &#125;<br><br>        // Note: The display link&#x27;s `.frameInterval` value of 1 (default) means getting callbacks at the refresh rate of the display (~60Hz).<br>        // Setting it to 2 divides the frame rate by 2 and hence calls back at every other display refresh.<br>        const NSTimeInterval kDisplayRefreshRate = 60.0; // 60Hz<br>        // 1、frameInterval : Defines how many display frames must pass between each time the display link fires.<br>        // 2、先求出gif中每帧图片的播放时间，求出这些播放时间的最大公约数，<br>        // 3、将这个最大公约数*刷新速率，再与1比取最大值，该值作为frameInterval。<br>        // 4、将GIF动画的每帧图片显示时间除以帧显示时间的最大公约数，得到单位时间内GIF动画的每个帧显示时间的比例，然后再乘以屏幕刷新速率kDisplayRefreshRate作为displayLink.frameInterval,正好可以用displayLink调用刷新方法的频率来保证GIF动画的帧图片展示时间 frame delays的间隔比例，使GIF动画的效果能够正常显示。<br>        self.displayLink.frameInterval = MAX([self frameDelayGreatestCommonDivisor] * kDisplayRefreshRate, 1);<br><br>        self.displayLink.paused = NO;<br>    &#125; else &#123;<br>        [super startAnimating];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 播放GIF动画<br>该方法关键点在于accumulator累加器的使用和displayLink.frameInterval的计算，涉及一些简单的数学过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)displayDidRefresh:(CADisplayLink *)displayLink<br>&#123;<br>    // If for some reason a wild call makes it through when we shouldn&#x27;t be animating, bail.<br>    // Early return!<br>    if (!self.shouldAnimate) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Trying to animate image when we shouldn&#x27;t: %@&quot;, self);<br>        return;<br>    &#125;<br>    <br>    NSNumber *delayTimeNumber = [self.animatedImage.delayTimesForIndexes objectForKey:@(self.currentFrameIndex)];<br>    // If we don&#x27;t have a frame delay (e.g. corrupt frame), don&#x27;t update the view but skip the playhead to the next frame (in else-block).<br>    if (delayTimeNumber) &#123;<br>        NSTimeInterval delayTime = [delayTimeNumber floatValue];<br>        // If we have a nil image (e.g. waiting for frame), don&#x27;t update the view nor playhead.<br>        // 拿到当前要显示的图片<br>        UIImage *image = [self.animatedImage imageLazilyCachedAtIndex:self.currentFrameIndex];<br>        if (image) &#123;<br>            FLLog(FLLogLevelVerbose, @&quot;Showing frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>            //显示图片<br>            self.currentFrame = image;<br>            if (self.needsDisplayWhenImageBecomesAvailable) &#123;<br>                [self.layer setNeedsDisplay];<br>                self.needsDisplayWhenImageBecomesAvailable = NO;<br>            &#125;<br>            //frameInterval:Defines how many display frames must pass between each time the display link fires<br>            //duration :duration of the display frame<br>            <br>            //displayLink.duration * displayLink.frameInterval是每个display link fires之间的时间间隔<br>            self.accumulator += displayLink.duration * displayLink.frameInterval;<br>            <br>//从前面的startAnimating方法中displayLink.frameInterval的计算过程可以知道，<br>//GIF动画中的帧图片的展示时间都是delayTime都是displayLink.duration * displayLink.frameInterval的倍数关系，<br>//也就是说一个GIF动画帧图片的展示时间至少是一个display link fires的时间间隔。<br>//以下数据是使用FLAnimatedImage的Demo项目的第一个GIF动画的播放信息打印出来的。<br>//按照Demo中的打印数据来说，第0帧图片的展示时间是14个display link fires的时间间隔，而1，2，3帧图片都是只有一个display link fires的时间间隔。<br>//所以累加器self.accumulator的意义在于累加display link fires的时间间隔，并与帧图片的delayTime做比较，如果小于delayTime说明该帧图片还需要继续展示，否则该帧图片结束展示。<br>            <br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.100000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.150000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.200000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.250000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.300000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.350000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.400000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.450000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.500000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.550000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.600000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.650000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.700000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;1,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;2,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;3,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>            <br>            <br>            // While-loop first inspired by &amp; good Karma to: https://github.com/ondalabs/OLImageView/blob/master/OLImageView.m<br>            while (self.accumulator &gt;= delayTime) &#123;<br>                self.accumulator -= delayTime;<br>                self.currentFrameIndex++;<br>                <br>                if (self.currentFrameIndex &gt;= self.animatedImage.frameCount) &#123;<br>                    // 播放到结尾，循环次数减1<br>                    // If we&#x27;ve looped the number of times that this animated image describes, stop looping.<br>                    self.loopCountdown--;<br>                    if (self.loopCompletionBlock) &#123;<br>                        self.loopCompletionBlock(self.loopCountdown);<br>                    &#125;<br>                    // 循环次数为0，停止播放,退出方法<br>                    if (self.loopCountdown == 0) &#123;<br>                        [self stopAnimating];<br>                        return;<br>                    &#125;<br>                    //重置帧图片索引，继续从头开始播放gif动画<br>                    self.currentFrameIndex = 0;<br>                &#125;<br>                // Calling `-setNeedsDisplay` will just paint the current frame, not the new frame that we may have moved to.<br>                // Instead, set `needsDisplayWhenImageBecomesAvailable` to `YES` -- this will paint the new image once loaded.<br>                // 展示新图片<br>                self.needsDisplayWhenImageBecomesAvailable = YES;<br>            &#125;<br>        &#125; else &#123;<br>            FLLog(FLLogLevelDebug, @&quot;Waiting for frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>            if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImageView:waitingForFrame:duration:)]) &#123;<br>                [self.debug_delegate debug_animatedImageView:self waitingForFrame:self.currentFrameIndex duration:(NSTimeInterval)displayLink.duration * displayLink.frameInterval];<br>            &#125;<br>#endif<br>        &#125;<br>    &#125; else &#123;<br>        //取不到需要的信息直接开始下一张图片播放<br>        self.currentFrameIndex++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>FLAnimatedImage就是负责生产数据是生产者。</li><li>FLAnimatedImageView负责消费数据是消费者。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/">https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/</a><br><a href="http://engineering.flipboard.com/2014/05/animated-gif/">http://engineering.flipboard.com/2014/05/animated-gif/</a><br><a href="https://github.com/Flipboard/FLAnimatedImage">https://github.com/Flipboard/FLAnimatedImage</a><br><a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/">http://blog.ibireme.com/2015/11/02/ios_image_tips/</a><br><a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 网络框架－AFNetworking 3.1.0 源码解读</title>
    <link href="/2016/07/31/reading-source-code-of-AFNetworking/"/>
    <url>/2016/07/31/reading-source-code-of-AFNetworking/</url>
    
    <content type="html"><![CDATA[<h1 id="AFNetworking-解读"><a href="#AFNetworking-解读" class="headerlink" title="AFNetworking 解读"></a>AFNetworking 解读</h1><p>AFNetworking 基本是 iOS 开发中的网络第三方库标配,本文基于 <a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">AFNetworking3.1.0</a> 版本。废话不多说，这篇文章主要从使用的角度来介绍 AFNetworking 的发起 Get 请求的过程，偏重于解读过程，解读当你使用 AFNetworking 发起一个 Get 请求的时候，AFNetworking 内部的处理过程。而不是对 AFNetworking 源代码的各个类的代码进行深入解析，在源码深度解析方面，网络上已经有很多不错的文章，在文章的末尾我会给出参考链接。</p><h2 id="Get-请求流程图"><a href="#Get-请求流程图" class="headerlink" title="Get 请求流程图"></a>Get 请求流程图</h2><p>这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，我会逐个解读这个流程。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled.webp" class="" title="This is an example image"><h2 id="AFHTTPSessionManager-发起Get请求"><a href="#AFHTTPSessionManager-发起Get请求" class="headerlink" title="AFHTTPSessionManager 发起Get请求"></a>AFHTTPSessionManager 发起Get请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled1.webp" class="" title="This is an example image"><p>这个方法是 AFN 的 Get 请求的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 NSURLSessionDataTask 对象的实例,然后调用 NSURLSessionDataTask 的 resume 方法发起请求。</p><h2 id="创建-NSURLSessionDataTask"><a href="#创建-NSURLSessionDataTask" class="headerlink" title="创建 NSURLSessionDataTask"></a>创建 NSURLSessionDataTask</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled2.webp" class="" title="This is an example image"><p>这个方法是创建 NSURLSessionDataTask 对象实例并返回这个实例。首先创建一个 NSMutableURLRequest 对象的实例，然后配置。之后是使用 NSMutableURLRequest 对象的实例创建 NSURLSessionDataTask 对象实例，然后配置，可以选择性地传入各类 Block 回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。</p><h3 id="配置-NSMutableURLRequest-对象"><a href="#配置-NSMutableURLRequest-对象" class="headerlink" title="配置 NSMutableURLRequest 对象"></a>配置 NSMutableURLRequest 对象</h3><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled3.webp" class="" title="This is an example image"><p>在这个方法中先使用了url 创建了一个 NSMutableURLRequest 对象的实例,并且设置了 HTTPMethod 为 Get 方法（如果是 Post 方法，那么这里就是设置 Post 方法，以此类推）然后使用 KVC 的方法设置了 NSMutableURLRequest 的一些属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//设置 NSMutableURLRequest 的属性</span><br> <span class="hljs-function"><span class="hljs-type">static</span> NSArray * <span class="hljs-title">AFHTTPRequestSerializerObservedKeyPaths</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        <span class="hljs-comment">//allowsCellularAccess 允许使用数据流量</span><br>        <span class="hljs-comment">//cachePolicy 缓存策略</span><br>        <span class="hljs-comment">//HTTPShouldHandleCookies 处理Cookie</span><br>        <span class="hljs-comment">//HTTPShouldUsePipelining 批量请求</span><br>        <span class="hljs-comment">//networkServiceType 网络状态</span><br>        <span class="hljs-comment">//timeoutInterval 超时</span><br>        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(allowsCellularAccess)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(cachePolicy)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldHandleCookies)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldUsePipelining)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(networkServiceType)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(timeoutInterval))];<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;<br>&#125;```<br><br><br>![配置NSMutableURLRequest对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-a228e54cc99ab038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br>先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于 Get 操作来说，参数是直接拼接在请求地址后面。<br><br>### 配置 NSURLSessionDataTask 对象<br><br>![配置NSURLSessionDataTask对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-df139131c05cc9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>之后配置 NSMutableURLRequest 对象就需要配置 NSURLSessionDataTask 对象了。主要分为 <span class="hljs-number">2</span> 个步骤，第一个步骤是创建 NSURLSessionDataTask 对象实例，第二个步骤是给 NSURLSessionDataTask 对象实例设置 Delegate。用于实时了解网络请求的过程。<br><br><br>![给NSURLSessionDataTask对象实例设置Delegate](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-d75418e6972979c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>AFN 的代理统一使用 AFURLSessionManagerTaskDelegate 对象来管理，使用AFURLSessionManagerTaskDelegate 对象来接管 NSURLSessionTask 网络请求过程中的回调，然后再传入 AFN 内部进行管理。<br><br>```CPP<br>@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;<br></code></pre></td></tr></table></figure><p>如代码所示 AFURLSessionManagerTaskDelegate 接管了 NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 NSURLSessionTask 的 taskIdentifier 标识符对 delegate 进行管理，只要是用于识别该NSURLSessionTask 的代理，</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled4.webp" class="" title="This is an example image"><p>设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task添加暂停和恢复的通知</span><br>- (<span class="hljs-type">void</span>)addNotificationObserverForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];<br>&#125;<br></code></pre></td></tr></table></figure><p>监听 NSURLSessionTask 被挂起和恢复的通知</p><h2 id="网络请求开始"><a href="#网络请求开始" class="headerlink" title="网络请求开始"></a>网络请求开始</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)GET:(<span class="hljs-built_in">NSString</span> *)URLString<br>                   parameters:(<span class="hljs-type">id</span>)parameters<br>                     progress:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> * _Nonnull))downloadProgress<br>                      success:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="hljs-type">id</span> _Nullable))success<br>                      failure:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nullable, <span class="hljs-built_in">NSError</span> * _Nonnull))failure<br>&#123;<br><br>    <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask = [<span class="hljs-keyword">self</span> dataTaskWithHTTPMethod:<span class="hljs-string">@&quot;GET&quot;</span><br>                                                        URLString:URLString<br>                                                       parameters:parameters<br>                                                   uploadProgress:<span class="hljs-literal">nil</span><br>                                                 downloadProgress:downloadProgress<br>                                                          success:success<br>                                                          failure:failure];<br><br>    [dataTask resume];<br><br>    <span class="hljs-keyword">return</span> dataTask;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 NSURLSessionTask 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 resume方法，NSURLSessionTask 才会开始执行。</p><h2 id="网络请求回调"><a href="#网络请求回调" class="headerlink" title="网络请求回调"></a>网络请求回调</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled5.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled6.webp" class="" title="This is an example image"><p>AFN 里面有关 NSURLSessionDelegate 的回调方法非常的多，这里我们只调和<br> NSURLSessionTask 相关的部分方法和 KVO 处理来进行说明，其他的大家可以参考源码细看。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled7.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled8.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled9.webp" class="" title="This is an example image"><p>对于我们的 Get 请求来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//KVO监听的属性值发生变化</span><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([object isKindOfClass:[<span class="hljs-built_in">NSURLSessionTask</span> <span class="hljs-keyword">class</span>]] || [object isKindOfClass:[<span class="hljs-built_in">NSURLSessionDownloadTask</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesReceived))]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesReceived&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中已经收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToReceive&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中期待收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesSent))]) &#123;<br>             <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesSent&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经发送</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToSend&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待发送</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.downloadProgress]) &#123;<br>        <span class="hljs-comment">//下载进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.downloadProgressBlock(object);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.uploadProgress]) &#123;<br>        <span class="hljs-comment">//上传进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.uploadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.uploadProgressBlock(object);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//收到请求响应</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>          dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;收到请求响应&quot;</span>);<br>    <span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionResponseAllow</span>;<span class="hljs-comment">//允许继续加载</span><br><br><span class="hljs-comment">//是否有收到请求响应的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        disposition = <span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);<br>    &#125;<br><span class="hljs-comment">//是否有请求响应完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        completionHandler(disposition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//请求完成</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求完成&quot;</span>);<br><span class="hljs-comment">//取出该NSURLSessionTask的代理对象</span><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br><br>    <span class="hljs-comment">// delegate may be nil when completing a task in the background</span><br>    <span class="hljs-keyword">if</span> (delegate) &#123;<br><span class="hljs-comment">//若是该代理对象存在，那么将对应数据转给该代理对象处理</span><br>        [delegate URLSession:session task:task didCompleteWithError:error];<br><span class="hljs-comment">//NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象</span><br>        [<span class="hljs-keyword">self</span> removeDelegateForTask:task];<br>    &#125;<br><span class="hljs-comment">//是否有请求完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidComplete) &#123;<br><span class="hljs-comment">//若有调用改Block</span><br>        <span class="hljs-keyword">self</span>.taskDidComplete(session, task, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。</p><p>这个是我们的配置过程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task移除delegate</span><br>- (<span class="hljs-type">void</span>)removeDelegateForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    [delegate cleanUpProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> removeNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled10.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled11.webp" class="" title="This is an example image"><h2 id="关于-Post-请求"><a href="#关于-Post-请求" class="headerlink" title="关于 Post 请求"></a>关于 Post 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled12.webp" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - AFURLRequestSerialization</span><br><span class="hljs-comment">//设置Header和请求参数</span><br>- (<span class="hljs-built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                               withParameters:(<span class="hljs-type">id</span>)parameters<br>                                        error:(<span class="hljs-built_in">NSError</span> *__autoreleasing *)error<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(request);<br><br>    <span class="hljs-built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];<br>    [<span class="hljs-keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-type">id</span> field, <span class="hljs-type">id</span> value, <span class="hljs-type">BOOL</span> * __unused stop) &#123;<br>        <span class="hljs-comment">//判断header的field是否存在,如果不存在则设置，存在则跳过</span><br>        <span class="hljs-keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;<br>            <span class="hljs-comment">//设置 header</span><br>            [mutableRequest setValue:value forHTTPHeaderField:field];<br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-built_in">NSString</span> *query = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (parameters) &#123;<br>        <span class="hljs-comment">//用传进来的自定义block格式化请求参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.queryStringSerialization) &#123;<br>            <span class="hljs-built_in">NSError</span> *serializationError;<br>            query = <span class="hljs-keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);<br>            <span class="hljs-keyword">if</span> (serializationError) &#123;<br>                <span class="hljs-keyword">if</span> (error) &#123;<br>                    *error = serializationError;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.queryStringSerializationStyle) &#123;<br>                <span class="hljs-keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:<br>                    <span class="hljs-comment">//默认的格式化方式</span><br>                    query = AFQueryStringFromParameters(parameters);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;<br>       <span class="hljs-comment">//判断是否有参数</span><br>        <span class="hljs-keyword">if</span> (query &amp;&amp; query.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//拼接请求参数</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;query--&gt;%@&quot;</span>,query);<br>            mutableRequest.URL = [<span class="hljs-built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="hljs-string">@&quot;&amp;%@&quot;</span> : <span class="hljs-string">@&quot;?%@&quot;</span>, query]];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span><br>        <span class="hljs-keyword">if</span> (!query) &#123;<br>            query = <span class="hljs-string">@&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//参数带在body上，大多是POST PUT</span><br>        <span class="hljs-keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>]) &#123;<br>            <span class="hljs-comment">//设置Content-Type HTTP头，告诉服务端body的参数编码类型</span><br>            [mutableRequest setValue:<span class="hljs-string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>];<br>        &#125;<br>        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="hljs-keyword">self</span>.stringEncoding]];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mutableRequest;<br>&#125; <br></code></pre></td></tr></table></figure><p>如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 body 上，这个是 Post 和 Get 请求的最大区别了，其他过程和 Get 请求并没有太多区别。</p><h2 id="关于-HTTPS-请求"><a href="#关于-HTTPS-请求" class="headerlink" title="关于 HTTPS 请求"></a>关于 HTTPS 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled13.png" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled14.png" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Http认证处理</span><br><span class="hljs-comment">//认证处理</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *http://www.cnblogs.com/polobymulberry/p/5140806.html</span><br><span class="hljs-comment"> *web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。</span><br><span class="hljs-comment"> *这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</span><br><span class="hljs-comment"> *接收到挑战后，</span><br><span class="hljs-comment"> *客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential</span><br><span class="hljs-comment"> *（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。</span><br><span class="hljs-comment"> *最后调用completionHandler回应服务器端的挑战。</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-comment">//NSURLAuthenticationChallenge 挑战处理类型为 默认</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">//自定义方法，用来如何应对服务器端的认证挑战</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//服务端要求客户端提供证书</span><br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-comment">//客户端评估服务端的安全性</span><br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                <span class="hljs-comment">//客户端产生证书</span><br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>                <span class="hljs-keyword">if</span> (credential) &#123;<br>                    <span class="hljs-comment">//使用指定的证书</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//默认处理</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不处理服务端的认证要求</span><br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//如果没有实现方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *- (void)URLSession:(NSURLSession *)session</span><br><span class="hljs-comment"> *didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="hljs-comment"> *completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//那么URLSession会调用下面的方法进入认证处理</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是 HTTPS 请求的话，那么会先走上面的2个代理方法进行 HTTPS 认证，之后继续其他操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AFN 发起 Get 请求主要分为以下步骤：<br>1.创建 NSURLSessionDataTask<br>2.配置 NSURLSessionDataTask<br>3.设置 NSURLSessionDataTask 的 Delegate<br>4.调用 NSURLSessionDataTask 的 resume 方法开始请求<br>5.在 Delegate 的方法里面处理网络请求的各个过程<br>6.清理 NSURLSessionDataTask 的配置<br>其实也就是使用 NSURLSessionDataTask 的步骤，AFN 在这几个步骤加了一些封装，让整个请求过程更加好用，易用。</p><p>对于 AFN 这类几乎是 iOS 开发网络库标配的开源项目来说，肯定已经有许多非常优秀的源码解析文章了。所以这篇文章是着重讲解和介绍 AFN 的整个网络请求的处理流程而且很多的技术细节。相信如果对流程熟悉的话，那么要想找对应的细节处理过程也就比较简单的，再配合一些调试手段的话，基本上对于 AFN 的细节处理的理解也就不再话下了。由于个人水平有限，文章有不对之处恳请指出，我稍作修改，大家共同进步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://blog.cnbang.net/tech/2320/">http://blog.cnbang.net/tech/2320/</a><br><a href="http://blog.cnbang.net/tech/2371/">http://blog.cnbang.net/tech/2371/</a><br><a href="http://blog.cnbang.net/tech/2416/">http://blog.cnbang.net/tech/2416/</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a><br><a href="http://bugly.qq.com/bbs/forum.php">http://bugly.qq.com/bbs/forum.php</a>?<br><a href="http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6">http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6</a><br><a href="http://www.guokr.com/post/116169/">http://www.guokr.com/post/116169/</a><br><a href="http://www.guokr.com/blog/148613/">http://www.guokr.com/blog/148613/</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html">http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html</a><br><a href="http://www.cnblogs.com/polobymulberry/p/5140806.html">http://www.cnblogs.com/polobymulberry/p/5140806.html</a><br><a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">https://github.com/AFNetworking/AFNetworking/tree/3.1.0</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 图片加载框架－SDWebImage 解读</title>
    <link href="/2016/03/09/reading-source-code-of-SDWebImage/"/>
    <url>/2016/03/09/reading-source-code-of-SDWebImage/</url>
    
    <content type="html"><![CDATA[<h1 id="SDWebImage-解读"><a href="#SDWebImage-解读" class="headerlink" title="SDWebImage 解读"></a>SDWebImage 解读</h1><p>在 iOS 的图片加载框架中，<a href="https://github.com/rs/SDWebImage">SDWebImage</a> 可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的 UIImageView 控件或者 UIButton 控件。在项目中使用 SDWebImage 来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。</p><h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><p>1.提供了一个 UIImageView 的 category 用来加载网络图片并且对网络图片的缓存进行管理<br>2.采用异步方式来下载网络图片<br>3.采用异步方式，使用 memory＋disk 来缓存网络图片，自动管理缓存。<br>4.支持 GIF 动画<br>5.支持 WebP 格式<br>6.同一个 URL 的网络图片不会被重复下载<br>7.失效的 URL 不会被无限重试<br>8.耗时操作都在子线程，确保不会阻塞主线程<br>9.使用 GCD 和 ARC<br>10.支持 Arm64</p><h2 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h2><p>1.使用 ImageView+WebCache category 来加载 UITableView 中 cell 的图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>]];<br></code></pre></td></tr></table></figure><p>2.使用 block,采用这个方案可以在网络图片加载过程中得知图片的下载进度和图片加载成功与否</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>] completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="hljs-built_in">NSURL</span> *imageURL) &#123;<br>    <span class="hljs-comment">//... completion code here ... </span><br> &#125;];<br></code></pre></td></tr></table></figure><p>3.使用 SDWebImageManager,SDWebImageManager 为UIImageView+WebCache category 的实现提供接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SDWebImageManager *manager = [SDWebImageManager sharedManager] ;<br>[manager downloadImageWithURL:imageURL options:<span class="hljs-number">0</span> progress:^(<span class="hljs-built_in">NSInteger</span>   receivedSize, <span class="hljs-built_in">NSInteger</span> expectedSize) &#123; <br>      <span class="hljs-comment">// progression tracking code</span><br> &#125;  completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType,   <span class="hljs-type">BOOL</span> finished, <span class="hljs-built_in">NSURL</span> *imageURL) &#123; <br>   <span class="hljs-keyword">if</span> (image) &#123; <br>    <span class="hljs-comment">// do something with image</span><br>   &#125;<br> &#125;];<br></code></pre></td></tr></table></figure><p>4.加载图片还有使用 SDWebImageDownloader 和 SDImageCache 方式，但那个并不是我们经常用到的。基本上面所讲的3个方法都能满足需求。</p><h2 id="SDWebImage-流程"><a href="#SDWebImage-流程" class="headerlink" title="SDWebImage 流程"></a>SDWebImage 流程</h2><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled.webp" class="" title="This is an example image"><h2 id="SDWebImage-接口"><a href="#SDWebImage-接口" class="headerlink" title="SDWebImage 接口"></a>SDWebImage 接口</h2><p>SDWebImage 是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。</p><ol><li>给 UIImageView 设置图片的接口，SDWebImage 有提供多个给UIImageView 设置图片的接口，最终所有的接口都会调用下图的这个接口，这是大多数框架的做法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled1.webp" class="" title="This is an example image"><ol start="2"><li><p>获取 SDWebImage 的磁盘缓存大小,在项目中有时候会需要统计应用的磁盘缓存内容大小，那么获取图片的缓存大小就是使用这个接口来实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[SDImageCache sharedImageCache] getSize];<br></code></pre></td></tr></table></figure></li><li><p>清理内存缓存，清理内存中缓存的图片资源，释放内存资源。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearMemory];<br></code></pre></td></tr></table></figure></li><li><p>有了清理内存缓存，自然也有清理磁盘缓存的接口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearDisk];<br></code></pre></td></tr></table></figure></li></ol><h2 id="SDWebImage-解析"><a href="#SDWebImage-解析" class="headerlink" title="SDWebImage 解析"></a>SDWebImage 解析</h2><p>解析主要围绕着 SDWebImage 的图片加载流程来分析，介绍SDWebImage 这个框架加载图片过程中的一些处理方法和设计思路。</p><ol><li>给 UIImageView 设置图片，然后 SDWebImage 调用这个最终的图片加载方法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled2.webp" class="" title="This is an example image"><ol start="2"><li>开始加载之前图片先取消对应的 UIImageView 先前的图片下载操作。试想，如果我们给 UIImageView 设置了一张新的图片，那么我们还会在意该 UIImageVIew 先前是要加载哪一张图片么？应该是不在意的吧！那是不是应该尝试把该 UIImageView 先前的加载图片相关操作给取消掉呢?</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> sd_cancelCurrentImageLoad]<br></code></pre></td></tr></table></figure><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled3.webp" class="" title="This is an example image"><p>该方法经过周转，最后调用了以下方法，框架将图片对应的下载操作放到 UIView 的一个自定义字典属性 (operationDictionary) 中，取消下载操作第一步也是从这个 UIView 的自定义字典属性 (operationDictionary)中取出所有的下载操作，然后依次调用取消方法，最后将取消的操作从(operationDictionary) 字典属性中移除。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled4.webp" class="" title="This is an example image"><p>3.移除之前没用的图片下载操作之后就创建一个新的图片下载操作，然后设置到 UIView 的一个自定义字典属性 (operationDictionary) 中。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled5.webp" class="" title="This is an example image"><p>4.看看如何创建一个新的图片下载操作,框架保存了一个失效的 url 列表，如果 url 失效了就会被加入这个列表，保证不会重复多次请求失效的 url。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled6.webp" class="" title="This is an example image"><p>根据给定的 url 生成一个唯一的 key ,之后利用这个 key 到缓存中查找对应的图片缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled7.webp" class="" title="This is an example image"><p>5.读取图片缓存,根据 key 先从内存中读取图片缓存，若没有命中内存缓存则读取磁盘缓存，如果磁盘缓存命中，那么将磁盘缓存读到内存中成为内存缓存。如果都没有命中缓存的话，那么就在执行的 doneBlock中开始下载图片。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled8.webp" class="" title="This is an example image"><p>6.图片下载操作完成后会将图片对应的数据通过 completedBlock 进行回调</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled9.webp" class="" title="This is an example image"><p>在图片下载方法中，调用了一个方法用于添加创建和下载过程中的各类block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled10.webp" class="" title="This is an example image"><p>添加该 url 加载过程的状态回调 block<br> <img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled11.webp" class="" title="This is an example image"></p><p>如果该 url 是第一次加载的话，那么就会执行 createCallback 这个回调block ,然后在 createCallback 里面开始构建网络请求，在下载过程中执行各类进度 block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled12.webp" class="" title="This is an example image"><p>7.当图片下载完成之后会回到 done 的 block 回调中做图片转换处理和缓存操作</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled13.webp" class="" title="This is an example image"><p>回到 UIImageView 控件的设置图片方法 block 回调中，给对应的UIImageView 设置图片，操作流程到此完成。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled14.webp" class="" title="This is an example image"><p> 8.304 的处理<br>SDWebImage在加载图片网络请求的 NSURLConnection 的代理中对httpCode 做了判断，当 httpCode 为 304 的时候放弃下载，读取缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled15.webp" class="" title="This is an example image"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SDWebImage 作为一个优秀的图片加载框架，提供的使用方法和接口对开发者来说非常友好。其内部实现多是采用 block 的方式来实现回调，代码阅读起来可能没有那么直观。此文章旨在给大家讲解 SDWebImage 这个框架的图片大概加载流程，其中具体细节限于篇幅无法详细深究。能力有限，文章中难免有错误，若大家在阅读过程中有发现不合理或者错误的地方恳请在评论中指出，我会在第一时间进行修正,不胜感激。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>注释项目 <a href="https://github.com/junbinchencn/SDWebImage">https://github.com/junbinchencn/SDWebImage</a></li><li><a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS缓存框架－PINCache 解读</title>
    <link href="/2016/01/13/reading-source-code-of-PINCache/"/>
    <url>/2016/01/13/reading-source-code-of-PINCache/</url>
    
    <content type="html"><![CDATA[<h1 id="PINCache-解读"><a href="#PINCache-解读" class="headerlink" title="PINCache 解读"></a>PINCache 解读</h1><p>在项目中总是需要缓存一些网络请求数据以减轻服务器压力，业内也有许多优秀的开源的解决方案。通常的缓存方案都是由内存缓存和磁盘缓存组成的，内存缓存速度快容量小，磁盘缓存容量大速度慢可持久化。常见的内存缓存有 NSCache、<a href="https://github.com/tumblr/TMCache">TMMemoryCache</a>、<a href="https://github.com/pinterest/PINCache">PINMemoryCache</a>、<a href="https://github.com/ibireme/YYCache">YYMemoryCache</a>。常见的磁盘缓存有 TMDiskCache、PINDiskCache、SDWebImage。这次解读先从<a href="https://github.com/pinterest/PINCache">PINCache</a> 这个优秀的开源项目开始。PINCache 项目是在 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的基于 TMCache 的一个内存缓存，修复了 TMCache 存在的性能和死锁问题，可以说是有了一个较大的提升。</p><h3 id="PINCache-概论"><a href="#PINCache-概论" class="headerlink" title="PINCache 概论"></a>PINCache 概论</h3><p>PINCache 是多线程安全的，使用键值对来保存数据。PINCache 内部包含了 2 个类似的对象属性，一个是内存缓存 PINMemoryCache，另一个是磁盘缓存 PINDiskCache。PINCache 本身并没有过多的做处理缓存的具体工作，而是全部交给它内部的2个对象属性来实现，它只是对外提供了一些同步或者异步接口。在 iOS 中，当 App 收到内存警告或者进入后台的时候，PINCache 能够清理掉所有的内存缓存。</p><h3 id="PINCache-使用"><a href="#PINCache-使用" class="headerlink" title="PINCache 使用"></a>PINCache 使用</h3><p>采用 PINCache 项目的 Demo 来说明，这个是从服务器加载数据，再缓存下来，继而做业务逻辑处理，如果下次还需要同样的数据，要是缓存里面还有这个数据的话，那么就不需要再次发起网络请求了，而是直接使用这个数据。<strong>PINCache除了可以按键取值、按键存值、按键删值之外，还可以移除某个日期之前的缓存数据、删除所有缓存、限制缓存大小，限制缓存对象的存活时间等</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP">[[PINCache sharedCache] objectForKey:[url absoluteString]  block:^(PINCache *cache, NSString *key, id object) &#123;<br>                                     <span class="hljs-keyword">if</span> (object) &#123;<br>                                      <span class="hljs-comment">//有缓存，在这里做业务逻辑处理</span><br>                                         <span class="hljs-keyword">return</span>;<br>                                     &#125; <br>                                     <span class="hljs-comment">//没有缓存，那么去服务器加载数据，存入缓存，做业务逻辑处理</span><br>                                    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;cache miss, requesting %@&quot;</span>, url);<br>                                   [[PINCache sharedCache] setObject:data forKey:[url absoluteString]];<br>   &#125;];<br></code></pre></td></tr></table></figure><h3 id="PINCache-结构"><a href="#PINCache-结构" class="headerlink" title="PINCache 结构"></a>PINCache 结构</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled.webp" class="" title="This is an example image"><p>PINCache 的内部结构比较简单，最核心的就是 2 个缓存实现类，这里先给出一个大概的结构，让大家可以有个了解，下面就来讲讲详细的接口。</p><h3 id="PINCache-接口"><a href="#PINCache-接口" class="headerlink" title="PINCache 接口"></a>PINCache 接口</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled1.webp" class="" title="This is an example image"><p><strong>核心属性</strong><br>1.name 是 PINCache 的名字<br>2.concurrentQueue 是一个用来执行异步任务的并行队列<br>3.磁盘缓存<br>4.内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled2.webp" class="" title="This is an example image"><p><strong>初始化方法</strong><br>1.单例对象<br>2.使用名字初始化<br>3.使用名字和缓存路径来初始化</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled3.webp" class="" title="This is an example image"><p><strong>异步方法</strong><br>多数开源缓存框架的方法也就这么几个，大多类似。<br>1.异步按键取值，之后执行 Block<br>2.异步按键设值，之后执行 Block<br>3.异步按键删值，之后执行 Block<br>4.异步删除某个时间之后没有使用的缓存，之后执行 Block<br>5.异步删除所有缓存，之后执行 Block</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled4.webp" class="" title="This is an example image"><p><strong>同步方法</strong><br>这里的同步方法与异步方法的区别除了方法是否立即返回之外，还有一个区别就是异步方法可以传入一个 Block 参数<br>1.同步按键取值<br>2.同步按键设值<br>3.同步按键删值<br>4.同步删除某个时间之后没有使用的缓存<br>5.同步删除所有缓存</p><p><strong>PINCache 主要是包装 PINDiskCache 和 PINMemoryCache 的功能，具体的功能实现是交给对应的对象去实现</strong>。</p><p>###PINDiskCache 解析<br>PINDiskCache 涉及到磁盘缓存的具体实现，这里就不再一一列举所有的属性和方法了（具体的内容可以查看 PINCache 的文档），主要挑重要的取值方法，设值方法，还有删除方法来讲。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled5.webp" class="" title="This is an example image"><p>PINDiskCache 使用 semaphore 来做线程同步控制的，在写磁盘缓存的时候给 diskCache 对象加锁，写完之后解锁。在读磁盘缓存的时候也会给 diskCache 对象加锁，读完之后解锁。<em>读写过程都会加锁</em>。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled6.webp" class="" title="This is an example image"><p>写磁盘缓存的大概步骤是这样的，只是讲解一些思路，具体的详细信息需要大家查看源代码。<br>1.判断给的键值是否为空<br>2.加锁，保证多线程安全<br>3.把数据写入磁盘<br>4.更新缓存信息（包括但不限于保存磁盘缓存的总容量）<br>5.判断现在的磁盘缓存容量是否超过容量限制，若超出，按照缓存时间策略来删除对应的缓存，没有超过则不做操作<br>6.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled7.webp" class="" title="This is an example image"><p>读磁盘缓存相对简单一些，就是找到文件，然后读取。<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把数据从磁盘读到内存对象中<br>4.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled8.webp" class="" title="This is an example image"><p>移除缓存就是文件的删除操作<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把文件从磁盘中删除<br>4.解锁，让其他线程可以进入操作</p><h3 id="PINMemoryCache-解析"><a href="#PINMemoryCache-解析" class="headerlink" title="PINMemoryCache 解析"></a>PINMemoryCache 解析</h3><p>内存缓存相比磁盘缓存多了一个 App 收到内存警告或者 App 进入后台的时候清理缓存的功能。内存缓存的数据保存在字典里面。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled9.webp" class="" title="This is an example image"><p>1.收到系统内存警告通知，清理内存缓存<br>2.收到App进入后台的系统通知,清理内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled10.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.将数据存到缓存池，也就是字典里面<br>4.更新缓存对应的数据<br>5.解锁<br>6.判断内存缓存容量是否超出，超过删除部分</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled11.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.从字典里面取对应值<br>4.更新缓存对应的数据<br>5.解锁</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled12.webp" class="" title="This is an example image"><p>1.取出内存缓存值<br>2.加锁<br>3.更新内存缓存容量<br>4.删除内存缓存<br>5.更新内存缓存对应的数据<br>6.解锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存一般有 2 个部分组成，一个是内存缓存，一个是磁盘缓存。<br>1.对于<strong>内存缓存</strong>来说，一般使用字典来作为数据的缓存池，配合一个保存每个内存缓存数据的缓存时间的字典，一个保存每个内存缓存数据的缓存容量的字典，一个保存内存缓存总容量的变量。对于增删改查操作，基本也都是围绕着字典来的，需要重点注意的就是在这些个操作过程的多线程安全问题，还有同步和异步访问方法，以及异步方法中的 Block 参数的循环引用问题。<br>2.对于<strong>磁盘缓存</strong>来说，使用文件系统来保存缓存数据，配合设置文件的参数，比如文件的修改日期（访问一次即修改一次），文件的大小来管理着这个缓存数据。对缓存数据的增删改查，也就是转化成为对文件的读写删除操作。<br>3.不管是内存缓存还是磁盘缓存，在删除超过限制容量的缓存的时候总是有一个同样的策略。有优先删除缓存最久，最少使用的策略，也有优先删除，容量最大，最少使用的策略。没有什么最好的策略，只有适合你业务产品的策略。<br>最后感谢<a href="https://github.com/pinterest">PINCache的作者们</a>给我们提供了一个优秀的缓存开源框架。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://blog.ibireme.com/2015/10/26/yycache/">http://blog.ibireme.com/2015/10/26/yycache/</a><br><a href="https://github.com/pinterest/PINCache">https://github.com/pinterest/PINCache</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
