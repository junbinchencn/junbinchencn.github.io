<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>App 架构</title>
    <link href="/2022/06/07/app-architecture/"/>
    <url>/2022/06/07/app-architecture/</url>
    
    <content type="html"><![CDATA[<h1 id="App-架构"><a href="#App-架构" class="headerlink" title="App 架构"></a>App 架构</h1><p>App 架构是软件设计的一个分支，它关心如何设计一个 App 的结构。具体来说主要关注 2 个方面，一个方面是如何将 app 分解为不同的接⼝和概念层次部件，另一个方面是这些部件之间和⾃⾝的不同操作中所使⽤的控制流和数据流路径。</p><h2 id="App-的本质是反馈回路"><a href="#App-的本质是反馈回路" class="headerlink" title="App 的本质是反馈回路"></a>App 的本质是反馈回路</h2><p>在最⾼的层级上，app 架构其实就是⼀套分类，app 中不同的部件会被归纳到某个类型中去。我们将这些不同的种类叫做<strong>层次</strong>：⼀个层次指的是，遵循⼀些基本规则并负责特定功能的接⼝和其他代码的集合。Model 层和 View 层是这些分类中最为常⻅的两个。<strong>Model 层</strong>是 app 的内容，它不依赖于 (像 UIKit 那样的) 任何 app 框架。也就是说程序员对 model 层有完全的控制，Model 层通常包括 model 对象和协调对象 。<strong>View 层</strong>是依赖于 app 框架的部分，它使 model 层可⻅，并允许⽤⼾进⾏交互，从⽽将 model 层转变为⼀个 app。</p><p>由于 View 层和 model 层需要交流，所以两者之间需要存在连接。假设 view 层和 model 层是被清<br>晰地分开，⽽且不存在⽆法解耦的联结的话，两者之间的通讯就需要⼀些形式的翻译，如下图：</p><img src="/2022/06/07/app-architecture/Untitled.png" class="" title="example image"><p>每个 app 设计模式所⾯临的挑战是如何处理这张图表中箭头所包含的交流，依赖和变换。</p><p>⽤⼾发起的事件会导致 view 的响应，我们把由此引起的代码路径称为 <strong>view action</strong>，像是点击按钮或者选中 table view 中的某⼀⾏就属于 view action。当⼀个 view action 被送到 model 层时，它会被转变为 <strong>model action</strong> (或者说，让 model 对象执⾏⼀个 action 或者进⾏更新的命令)。将 view action 转变为 model action 的操作，以及路径上的其他逻辑被叫做<strong>交互逻辑</strong>。</p><p>⼀个或者多个 model 对象上状态的改变叫做 <strong>model 变更</strong>。Model 的变更通常会触发⼀个 <strong>model 通知</strong>，⽐如说从 model 层发出⼀个可观测的通知，它描述 model 层中什么内容发⽣了改变。当 view 依赖于 model 数据时，通知会触发⼀个 <strong>view 变更</strong>，来更改 view 层中的内容。这些通知可以以多种形式存在：Foundation 中的 Notiĩcation，代理，回调，或者是其他机制，都是可以的。将 model 通知和数据转变为 view 更改的操作，以及路径上的其他逻辑被叫做<strong>表现逻辑</strong>。</p><p>当任意的 view 对象或者中间层对象只能够通过 model 发出的通知来进⾏创建和更新 (换句话说，view 或者中间层不能通过捷径来更新⾃⾝或者其他的view) 时，这个模式通常就是单向的，app 设计模式的一个目标就是设计单向数据流。</p><h2 id="App-任务"><a href="#App-任务" class="headerlink" title="App 任务"></a>App 任务</h2><p>要让程序正常⼯作，view 必须依赖于 model 数据来⽣成和存在，我们配置 view，让它可以对<br>model 进⾏更改，并且能在 model 更新时也得到更新。</p><p>所以我们需要决定在 app 中如何执⾏下列任务：</p><ol><li><p><strong>构建</strong> — 谁负责构建 model 和 view，以及将两者连接起来？</p></li><li><p><strong>更新 model</strong> — 如何处理 view action？</p></li><li><p><strong>改变 view</strong> — 如何将 model 的数据应⽤到 view 上去？</p></li><li><p><strong>view state</strong> — 如何处理导航和其他⼀些 model state 以外的状态？</p></li><li><p><strong>测试</strong> — 为了达到⼀定程度的测试覆盖，要采取怎样的测试策略？</p></li></ol><p>对于上⾯五个问题的回答，是构成 app 设计模式的基础要件</p><p><strong>Model-View-Controller</strong></p><p>MVC 的核⼼思想是 controller 层负责将 model 层和 view 层撮合到⼀起⼯作。Controller 对<br>另外两层进⾏构建和配置，并对 model 对象和 view 对象之间的双向通讯进⾏协调。所以在<br>⼀个 MVC app 中，controller 层是作为核⼼来参与形成 app 的反馈回路的。下⾯是 MVC 模式的框图，它展⽰了⼀个 MVC app 的主要通讯路径：</p><img src="/2022/06/07/app-architecture/Untitled1.png" class="" title="example image"><p>图中的虚线部分代表运⾏时的引⽤，view 层和 model 层都不会直接在代码中引⽤ controller。<br>实线部分代表编译期间的引⽤，controller 实例知道⾃⼰所连接的 view 和 model 对象的接⼝。</p><h3 id="构建-MVC"><a href="#构建-MVC" class="headerlink" title="构建 MVC"></a>构建 MVC</h3><ol><li><strong>构建</strong> — 谁负责构建 model 和 view，以及将两者连接起来？</li></ol><p>App 对象负责创建最顶层的 view controller，这个 view controller 将加载 view，并且知道应<br>该从 model 中获取哪些数据，然后把它们显⽰出来。Controller 要么显式地创建和持有 model<br>层，要么通过⼀个延迟创建的 model 单例来获取 model。</p><ol start="2"><li><strong>更新 model</strong> — 如何处理 view action？</li></ol><p>在 MVC 中，controller 主要通过 target&#x2F;action 机制和 delegate 来接收 view 事件。Controller 知道⾃⼰所连接的 view，但是 view 在编译期间却没有关于 controller 接⼝的信息。当⼀个 view 事件到达时，controller 有能⼒改变⾃⾝的内部状态，更改 model、或者直接改变 view 层级。</p><ol start="3"><li><strong>改变 view</strong> — 如何将 model 的数据应⽤到 view 上去？</li></ol><p>在我们所理解的 MVC 中，当⼀个更改 model 的 view action 发⽣时，controller 不应该直接去<br>操作 view 层级。正确的做法是，controller 去订阅 model 通知，并且在当通知到达时再更改<br>view 层级。这样⼀来，数据流就可以单向进⾏：view action 被转变为 model 变更，然后<br>model 发送通知，这个通知最后被转为 view 变更。</p><ol start="4"><li><strong>view state</strong> — 如何处理导航和其他⼀些 model state 以外的状态？</li></ol><p>View state 可以按需要被 store 在 view 或者 controller 的属性中。相对于影响 model 的 view<br>action，那些只影响 view 或 controller 状态的 action 则不需要通过 model 进⾏传递。</p><ol start="5"><li><strong>测试</strong> — 为了达到⼀定程度的测试覆盖，要采取怎样的测试策略？</li></ol><p>在 MVC 中，view controller 与 app 的其他部件紧密相连。边界的缺失使得为 controller 编写<br>单元测试和接⼝测试⼗分困难，集成测试是余下的为数不多的可⾏测试⼿段之⼀。在集成测试<br>中，我们构建相连接的 view、model 和 controller 层，然后操作 model 或者 view，来测试是<br>否能得到我们想要的结果。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p><strong>第⼀个问题是 model 和 view 的同步可能失效</strong>。当围绕 model 的观察者模式没有被完美执⾏<br>时，这个问题就会发⽣。常⻅的错误是，在构建 view 时读取了 model 的值，⽽没有对后续的<br>通知进⾏订阅。另⼀个常⻅错误是在变更 model 的同时去更改 view 层级，这种做法假设了变<br>更的结果，⽽没有等待 model 进⾏通知，如果 model 拒绝了这个变更的话，就会发⽣错误。这<br>类错误会使得 view 和 model 不同步，奇怪的⾏为也随之⽽来</p><p><strong>第二个问题是这个模式经常会造成 view controller 臃肿</strong>。View controller 需要负责处理 view 层 (设置 view 属性，展⽰ view 等)，但是它同时也负责 controller 层的任务 (观察 model 以及更新 view)，最后，它还要负责 model 层 (获取数据，对其变形或者处理)。结合它在架构中的中⼼⻆⾊，这使得我们很容易在不经意间把所有的职责都赋予 view controller，从⽽迅速让程序变得难以管理。</p><h3 id="改进方式"><a href="#改进方式" class="headerlink" title="改进方式"></a>改进方式</h3><p>针对 <strong>model 和 view 的同步可能失效</strong>的问题。我们选择使⽤ Foundation 的 NoticationCenter 来进⾏ model 通知的⼴播。</p><p>针对 <strong>view controller 臃肿的问题，有更多的改进方式：</strong></p><ol><li>解决这个问题的最佳途径就是主动地将尽可能多的功能移动到 model 层中。⽐如排序，数据获取和处理等⽅法，因为不是 app 的存储状态的⼀部分，所以通常会被放到 controller 中。但是它们依然与 app 的数据和专⽤逻辑相关，把它们放在 model 中会是更好的选择。</li><li>在 view controller 中使⽤扩展共享代码。在多个 view controller 中都出现的⽅法有时候能够被添加到 UIViewController 的扩展中去。这样⼀来，所有的 view controller 就都能获取这个⽅法了。⽐如，我们可以为 UIViewController 添加⼀个显⽰⽂本警告的简便⽅法。</li><li>Child view controller 是在 view controller 之间共享代码的另⼀种选项。</li><li>将遵守协议的代码抽离到单独的对象中，可以有效减少 view controller 的代码量。⽐如 view controller 中遵守 UITableViewDataSource 的部分，⽐较适合被提取为 DataSourceController。通常⽤来遵守某个协议的代码⽐较适合被提取为⼀个可重⽤的 controller 对象，我们称这个对象为调解 controller 。</li></ol><h2 id="Model-View-ViewModel"><a href="#Model-View-ViewModel" class="headerlink" title="Model-View-ViewModel"></a>Model-View-ViewModel</h2><p>Model-View-ViewModel (MVVM) 是⼀种基于 MVC 进⾏改进的模式，它将所有 model 相关的<br>任务 (包括更新 model，观察变更，将 model 变形为可以显⽰的形式等) 从 controller 层抽离出<br>来，放到新的叫做 view-model 的⼀层对象中。在通常的 iOS 实现中，view-model 位于 model<br>和 controller 之间：</p><img src="/2022/06/07/app-architecture/Untitled2.png" class="" title="example image"><p>MVVM 架构加入加⼊⼀层新的 view-model 层的⽬的有两个原因：</p><ol><li>⿎励将 model 和 view 之间的关系构建为⼀系列的变形管道。</li><li>提供⼀套独⽴于 app 框架的接⼝，但是它在相当程度上代表了 view 应该展⽰的状态。</li></ol><p>两者结合起来，对 MVC 中两个最⼤的被⼈诟病的地⽅进⾏了修正：</p><ol><li>第⼀项通过把 model 相关的观察和变形从 controller 层移除出去，减少了 controller 所需要承担的责任。</li><li>第⼆项为场景的 view state 提供了⼀套⼲净的接⼝，让它可以独⽴于 app 框架进⾏测试，而不需要使用 MVC 的集成测试。</li></ol><p>MVVM 为了保持 view 与 view-model 的同步，MVVM 强制使⽤某种形式的绑定，也就是说需要⼀种保证⼀个对象上的属性与另⼀个对象上的属性同步的⽅式。在 iOS 上通常使用响应式编程的方式来实现绑定。</p><h3 id="构建-MVVM"><a href="#构建-MVVM" class="headerlink" title="构建 MVVM"></a>构建 MVVM</h3><ol><li><strong>构建</strong> — 谁负责构建 model 和 view，以及将两者连接起来？</li></ol><p>对于 model 的创建和 MVC 中的保持不变，通常它是⼀个顶层 controller 的职责。不过单独<br>的 model 对象现在属于 view-model，⽽不属于 view controller。</p><p>初始的 view 层级的创建和 MVC 中的⼀样，通过 storyboard 或者代码来完成。和 MVC 不同的<br>是，view controller 不再直接为每个 view 获取和准备数据，它会把这项⼯作交给 view-model。<br>View controller 在创建的时候会⼀并创建 view-model，并且将每个 view 绑定到 view-model<br>所暴露出的相应属性上去</p><ol start="2"><li><strong>更新 model</strong> — 如何处理 view action？</li></ol><p>在 MVVM 中，view controller 接收 view 事件的⽅式和 MVC 中⼀样 (在 view 和 view<br>controller 之间建⽴连接的⽅式也相同)。不过，当⼀个 view 事件到达时，view controller 不会<br>去改变⾃⾝的内部状态、view state、或者是 model。相对地，它⽴即调⽤ view-model 上的⽅<br>法，再由 view-model 改变内部状态或者 model。</p><ol start="3"><li><strong>改变 view</strong> — 如何将 model 的数据应⽤到 view 上去？</li></ol><p>和 MVC 不同，view controller 不监听 model。View-model 将负责观察 model，并将 model<br>的通知转变为 view controller 可以理解的形式。View controller 订阅 view-model 的变更，这<br>通常通过⼀个响应式编程框架来完成，但也可以使⽤任意其他的观察机制。当⼀个<br>view-model 事件来到时，由 view controller 去更改 view 层级。</p><p>为了实现单向数据流，view-model 总是应该将变更 model 的 view action 发送给 model，并<br>且仅仅在 model 变化实际发⽣之后再通知相关的观察者。</p><ol start="4"><li><strong>view state</strong> — 如何处理导航和其他⼀些 model state 以外的状态？</li></ol><p>View state 要么存在于 view ⾃⾝之中，要么存在于 view-model ⾥。和 MVC 不同，view<br>controller 中不存在任何 view state。View-model 中的 view state 的变更，会被 controller 观<br>察到，不过 controller ⽆法区分 model 的通知和 view state 变更的通知。当使⽤协调器时，<br>view controller 层级将由协调器进⾏管理。</p><ol start="5"><li><strong>测试</strong> — 为了达到⼀定程度的测试覆盖，要采取怎样的测试策略？</li></ol><p>因为 view-model 和 view 层与 controller 层是解耦合的，所以可以使⽤接⼝测试来测试<br>view-model，⽽不需要像 MVC ⾥那样使⽤集成测试。接⼝测试要⽐集成测试简单得多，因为<br>不需要为它们建⽴完整的组件层次结构。<br>为了让接⼝测试尽可能覆盖更多的范围，view controller 应当尽可能简单，但是那些没有被移<br>出 view controller 的部分仍然需要单独进⾏测试。</p><h3 id="MVVM-存在的问题"><a href="#MVVM-存在的问题" class="headerlink" title="MVVM 存在的问题"></a>MVVM 存在的问题</h3><p>MVVM 对响应式编程技术的依赖成为了使⽤该模式的⼀种遏制因素，响应式编程框架有着陡峭的学习曲线，⽽且需要花上⼀段时间才能调整到这种编程⻛格。虽然响应式编程在概念上来说⼗分优雅，但是由于响应式编程框架依赖⾼度抽象的变形以及⼤量的类型，对它们的大量应用会极大降低代码的可读性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="%5Bhttps://objccn.io/products/app-architecture%5D(https://objccn.io/products/app-architecture)">App 架构</a> 读书笔记</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 那些事儿</title>
    <link href="/2022/06/06/TCP-protocol/"/>
    <url>/2022/06/06/TCP-protocol/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a><strong>TCP 与 UDP</strong></h2><p>TCP 为了通过 IP 数据报实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。<br>TCP 通过 CheckSum、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。<br>TCP 的适用场景主要面向于在传输层有必要实现可靠性传输的场景</p><p>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。换句话说它将部分控制转移给应用程序去处理，自己却只提供作为传输层协议的最基本功能。<strong>UDP 是一种在收到应用程序发来的数据的那一刻，立即按照原样发送到网络上的机制。</strong>即使是出现网络拥堵的情况下，UDP 也<strong>无法进行流量控制等避免网络拥塞的行为，</strong>传输途中即使<strong>出现丢包，UDP 也不负责重发，</strong>甚至当出现<strong>包的到达顺序乱掉时也没有纠正</strong>的功能。</p><p>UDP 适用场景：</p><ol><li>包总量较少的通信（DNS、SNMP等）</li><li>视频、音频等多媒体通信（即时通信）</li><li>限定于 LAN 等特定网络中的应用通信</li><li>广播通信（广播、多播）</li></ol><h2 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a><strong>通过序列号与确认应答提高可靠性</strong></h2><p>如下图：发送端主机发送数据，接收端主机确认消息</p><img src="/2022/06/06/TCP-protocol/Untitled.png" class="" title="image"><p>如下图：发送端主机丢失数据</p><img src="/2022/06/06/TCP-protocol/Untitled1.png" class="" title="image"><p>如下图：发送端主机没有接收到 ACK 消息</p><img src="/2022/06/06/TCP-protocol/Untitled2.png" class="" title="image"><p><strong>问题场景：</strong>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（ACK），源发送主机没有收到确认应答会按照机制重发数据，对于目标主机来说，它会反复收到相同的数据，这简直是一种”灾难”。</p><p><strong>解决方案：</strong>引入一种机制，<strong>它能够识别数据是否已经接收，又能够判断数据是否需要接收，</strong>这些<strong>确认应答处理、重发控制、重复控制等功能都可以通过序列号实现，</strong>序列号是按顺序给发送数据的每一个字节都标上号码的编号。接收端<strong>查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。</strong>通过序列号和确认应答号，TCP 可以实现可靠传输。</p><p>如下图：TCP 发送数据的过程</p><img src="/2022/06/06/TCP-protocol/Untitled3.png" class="" title="image"><h2 id="重发超时如何确认"><a href="#重发超时如何确认" class="headerlink" title="重发超时如何确认"></a>重发超时如何确认</h2><p><strong>问题场景</strong>：网络环境不可信赖，发送端主机发送的数据可能在传输过程中丢失，接收端主机的确认应答消息也可以在回送过程丢失。</p><p><strong>解决方案</strong>：<strong>设定超时时间</strong>。最初的数据包还不知道往返时间，<strong>所以其重发超时一般设置为 6 秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以 2 倍、4 倍的指数函数延长。当然数据也不会被无限、反复地重发</strong>。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。</p><p>如下图：往返时间的计算与重发超时的时间推移，在 BSD 的 Unix 以及 Windows 系统中，<strong>超时都以0.5 秒为单位进行控制，重发超时都是 0.5 秒的整数倍。偏差的设小值也是 0.5 秒。因此最小的重发时间至少是 1 秒。</strong></p><img src="/2022/06/06/TCP-protocol/Untitled4.png" class="" title="image"><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a><strong>连接管理</strong></h2><p><strong>问题场景</strong>：TCP 提供面向连接的通信传输，面向连接是指在数据通信开始之前先做好通信两端之间的准备工作，在通信结束时会进行断开连接处理。那么在多变的网络环境中如何进行连接管理？</p><p><strong>解决方案</strong>：<strong>三次握手，四次挥手</strong>。发送一个 SYN 包作为建立连接的请求等待确认应答，如果对端发来确认应答，则认为可以进行数据通信，如果对端的确认应答未能到达，就不会进行数据通信。在通信结束时发送 FIN 包进行断开连接处理。<strong>可以使用 TCP 首部用于控制的字段来管理 TCP 连接，一个连接的建立与断开，正常过程至少需要来回发送 7 个包才能完成。</strong></p><p>如下图：TCP 的三次握手，四次挥手</p><img src="/2022/06/06/TCP-protocol/Untitled5.png" class="" title="image"><h2 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h2><p><strong>问题场景</strong>：怎么在各类不同性能的网络线路中确定自己的包大小？</p><p><strong>解决方案</strong>：使用最大消息长度（MSS∶Maximum Segment Size） 的机制。在建立 TCP 连接的同时，也可以确定发送数据包的单位，最理想的情况是，最大消息长度正好是 IP 包中不会被分片处理的最大数据长度。</p><p><strong>实现机制</strong>：TCP在传送大量数据时，是以 MSS 的大小将数据进行分割发送，进行重发时也是以 MSS 为单位。MSS 是在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小，然后会在两者之间选择一个较小的值投入使用。</p><p>如下图：建立连接的时候计算 MSS</p><img src="/2022/06/06/TCP-protocol/Untitled6.png" class="" title="image"><h2 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h2><p><strong>问题场景：</strong>发送端主机每发送一个段，都需要等待接收端主机回送一个确认应答消息，这会造成一个问题，段的往返时间越长通信性能就越低。</p><p><strong>解决方案：</strong>为解决这个问题，TCP 引入了窗口概念，<strong>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值，在这个窗口内的数据即便没有收到确认应答也可以发送出去</strong>。即使在往返时间较长的情况下，它也能控制网络性能的下降。确认应答不再是以每个分段而是以更大的单位进行确认时，转发时间将会被大幅度的缩短。也就是说发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。</p><p><strong>滑动窗口控制机制：</strong>通过使用缓冲区对窗口中的多个段进行同时确认，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。当数据发出后，若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。在滑动窗口以外尚未发送的数据，这部分数据不需要保存在缓冲区。</p><p>如下图：发送端主机发送段消息，接收确认应答消息</p><img src="/2022/06/06/TCP-protocol/Untitled7.png" class="" title="image"><p>如下图： 使用窗口机制发送消息</p><img src="/2022/06/06/TCP-protocol/Untitled8.png" class="" title="image"><p>如下图：滑动窗口控制机制</p><img src="/2022/06/06/TCP-protocol/Untitled9.png" class="" title="image"><h2 id="窗口控制与重发控制"><a href="#窗口控制与重发控制" class="headerlink" title="窗口控制与重发控制"></a><strong>窗口控制与重发控制</strong></h2><p><strong>问题场景</strong>：通过滑动窗口控制这个机制来控制网络性能，如果出现了段丢失应该怎么处理？</p><p><strong>解决方案</strong>：发送端主机如果连续 3  次收到同一个确认应答，就会将其所对应的数据进行重发，这种机制被称作高速重发控制。</p><p><strong>实现机制</strong>：我们先考虑确认应答未能返回的情况，在这种情况下由于数据已经到达对端，这个时候是不需要再进行重发的。然而在没有使用窗口控制的时候，没有收到确认应答的数据都会被重发。而使用了窗口控制，如下图所示，某些确认应答即便丢失也无需重发。</p><img src="/2022/06/06/TCP-protocol/Untitled10.png" class="" title="image"><p>接收主机如果收到一个自己应该接收的序号以外的数据时，会针对<strong>之前收到的数据</strong>返回确认应答，不过即使接收端主机收到的包序号并不连续，也<strong>不会将数据丢弃而是暂时保存至缓冲区中</strong>。</p><p>如下图所示，当某一报文段丢失后，发送端会一直收到序号为 1001 的确认应答，这个确认应答好像在提醒发送端” 我想接收的是从 1001 开始的数据”。<strong>因此在窗口比较大又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断地返回</strong>。</p><img src="/2022/06/06/TCP-protocol/Untitled11.png" class="" title="image"><h2 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h2><p><strong>问题场景</strong>：发送端根据自己的实际情况发送数据。但是接收端在此时可能收到了一个其他毫无关系的数据包，也有可能在处理其他问题上花费时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本应该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。</p><p><strong>解决思路</strong>：为了防止这种现象的发生，<strong>解决接收端主机的接收问题。</strong>TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的<strong>流控制</strong>。<strong>它的具体操作是接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，该大小限度就被称作窗口大小。</strong></p><p><strong>实现机制：</strong>如下图所示，当接收端收到从 3001 号开始的数据段后其缓冲区即满，不得不暂时停止接收数据。之后在收到发送窗口更新通知后通信才得以继续进行，如果这个窗口的更新通知在传送途中丢失，可能会导致无法继续通信。为避免此类问题的发生，<strong>发送端主机会时不时的发送一个叫做窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息</strong>。</p><img src="/2022/06/06/TCP-protocol/Untitled12.png" class="" title="image"><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>问题场景：</strong>一般来说主机都处在一个共享的网络环境，因此有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。</p><p><strong>解决方案：</strong>为了在发送端调节所要发送数据的量，定义了一个叫做“拥塞窗口”的概念。在通信一开始时就会通过一个叫做<strong>慢启动的算法</strong>得出的数值对发送数据量进行控制。</p><p>实现机制：<strong>在慢启动的时候，</strong>将这个拥塞窗口的大小设置为 1 个数据段（1 MSS），发送数据之后每收到一次确认应答（ACK），拥塞窗口的值就加 1 。在发送数据包时将<strong>拥塞窗口的大小</strong>与<strong>接收端主机通知的窗口大小</strong>做比较，然后按照它们当中较小那个值，发送比其还要小的数据量。具体操作如下图所示：</p><img src="/2022/06/06/TCP-protocol/Untitled13.png" class="" title="image"><p><strong>如果数据发送超时，那么就采用超时机制，</strong>拥塞窗口的初始值可以设置为 1 以后再进行慢启动修正。有了上述这些机制，就可以有效地减少通信开始时连续发包导致的网络拥堵，还可以避免网络拥塞情况的发生。不过，随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况激增甚至导致网络拥塞的发生。为了防止这些拥堵状况，引入了<strong>慢启动阀值</strong>的概念。<strong>只要拥塞窗口的值超出这个阀值，在每收到一次确认应答时，只允许这种比例放大拥塞窗口。如下图所示：</strong></p><img src="/2022/06/06/TCP-protocol/Untitled14.png" class="" title="image"><p>TCP 的通信开始时，并没有设置相应的慢启动阀值。在<strong>超时重发</strong>时，才会把<strong>慢启动阀值设置为当时拥塞窗口一半的大小</strong>。<strong>重复确认应答</strong>要求至少 3  次的确认应答数据段到达发送方主机后才会触发，重复确认应答机制相比超时重发机制，网络的拥堵要轻一些。而由重复确认应答机制进行高速重发控制时，<strong>慢启动阀值的大小被设置为当时窗口大小的一半，</strong>然后将<strong>窗口的大小设置为该慢启动阀值 + 3个数据段的大小</strong>。当TCP 通信开始以后，网络吞吐量会逐渐上升，但是随着网络拥堵的发生吞吐量也会急速下降。于是会再次进入吞吐量慢慢上升的过程。因此所谓 <strong>TCP 的吞吐量的特点就好像是在逐步占领网络带宽的感觉。如下图所示：</strong></p><img src="/2022/06/06/TCP-protocol/Untitled15.png" class="" title="image"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/24737674/">图解 TCP&#x2F;IP </a> 读书总结</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层的作用</title>
    <link href="/2022/06/06/transport-layer/"/>
    <url>/2022/06/06/transport-layer/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a>传输层的作用</h1><p><strong>TCP 提供可靠的通信传输，而 UDP 则常被用于让广播和细节控制交给应用的通信传输。</strong></p><p>TCP&#x2F;IP的众多应用协议大多以客户端&#x2F;服务端的形式运行。客户端类似于客户的意思，是请求的发起端。而服务端则表示提供服务的意思，是请求的处理端。另外，作为服务端的程序有必要提前启动，准备接收客户端的请求。否则即使有客户端的请求发过来，也无法做到相应的处理。</p><img src="/2022/06/06/transport-layer/Untitled.png" class="" title="this is an example image"><p>这些服务端程序在UNIX 系统当中叫做<strong>守护进程</strong>。例如 HTTP 的服务端程序是 httpd（HTTP 守护进程），而 ssh 的服务端程序是 sshd（SSH 守护进程）。在 <strong>UNIX 中并不需要将这些守护进程逐个启动，而是启动一个可以代表它们接收客户端请求的 inetd（互联网守护进程）服务程序即可。它是一种超级守护进程。该超级守护进程收到客户端请求以后会创建（fork）新的进程并转换（exec）为 sshd 等各个守护进程</strong>。确认一个请求究竟发给的是哪个服务端（守护进程），可以通过所收到数据包的目标端口号轻松识别。当收到 TCP 的建立连接请求时，如果目标端口为 22，则转给 sshd，如果是 80 则转给 httpd。然后，这些守护进程会继续对该连接上的通信传输进行处理。传输协议 TCP、UDP 通过接收数据中的目标端口号识别目标处理程序。以上图为例，传输协议的数据将被传递给 HTTP、TELNET 以及 FTP 等应用层协议。</p><h2 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h2><p><strong>TCP 是面向连接的、可靠的流协议</strong>。流就是指不间断的数据结构，你可以把它想象成排水管道中的水流。当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。</p><p>TCP 是一种提供了<strong>可靠性传输，实行”顺序控制”或”重发控制” 的机制</strong>。</p><p>此外还具备<strong>流量控制、拥塞控制、提高网络利用率</strong>等众多功能。</p><h2 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h2><p>UDP 是<strong>不具有可靠性的数据报协议</strong>。<strong>细微的处理交给上层的应用去完成</strong>。在 UDP 的情况下，虽然<strong>可以确保发送消息的大小，却不能保证消息一定会到达</strong>。因此，应用有时会根据自己的需要进行重发处理。</p><h2 id="TCP-和-UDP-区分"><a href="#TCP-和-UDP-区分" class="headerlink" title="TCP 和 UDP 区分"></a><strong>TCP 和 UDP 区分</strong></h2><p>可能有人会认为，鉴于 TCP 是可靠的传输协议，那么它一定优于 UDP。其实不然，TCP 与 UD P的优缺点无法简单地、绝对地去做比较。那么对这两种协议应该如何加以区分使用呢? 对此问题做一简单说明。</p><p><strong>TCP用于在传输层有必要实现可靠传输的情况</strong>。由于它是面向有连接并具备<strong>顺序控制、重发控制</strong>等机制的，所以它可以为应用提供可靠传输。而在一方面，<strong>UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信</strong>。</p><p>我们举一个通过 <strong>IP 电话进行通话</strong>的例子。如果使用 TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用 UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p><strong>数据链路的地址</strong>指的是 MAC 地址，用来识别同一链路中不同的计算机。</p><p><strong>网络层的地址</strong>指的是 IP 地址，用来识别 TCP&#x2F;IP 网络中互连的主机和路由器。</p><p><strong>传输层的地址指的是端口号，用来识别同一台计算机中进行通信的不同应用程序。</strong></p><img src="/2022/06/06/transport-layer/Untitled1.png" class="" title="this is an example image"><p>TCP&#x2F;IP 或 UDP&#x2F;IP 通信中通常采用 5 个信息来识别一个通信。它们是”源 IP 地址”、”目标 IP 地址”、”协议号”、”源端口号”、”目标端口号”。只要其中某一项不同，则被认为是不同的通信。</p><img src="/2022/06/06/transport-layer/Untitled2.png" class="" title="this is an example image"><p>UDP 首部格式：</p><img src="/2022/06/06/transport-layer/Untitled3.png" class="" title="this is an example image"><p>TCP 首部格式：</p><img src="/2022/06/06/transport-layer/Untitled4.png" class="" title="this is an example image"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/24737674/">图解 TCP&#x2F;IP </a> 读书总结</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构</title>
    <link href="/2022/05/30/software-architecture/"/>
    <url>/2022/05/30/software-architecture/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h2><p>可能你一直认为软件架构设计的目标应该是让一个系统能够正确的工作，然而一个软件系统的架构质量和该系统是否能正常工作的关系并不大。毕竟世界上还是有非常多架构设计糟糕但是工作正常的软件系统，真正的麻烦往往会出现再这个软件系统的开发，部署以及后续的持续迭代开发中。</p><p>软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解，易于修改，方便维护，并且能轻松部署。软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。</p><h2 id="软件架构的解耦"><a href="#软件架构的解耦" class="headerlink" title="软件架构的解耦"></a>软件架构的解耦</h2><p>基本上所有的软件系统都可以降解为策略和细节这两种主要原色，策略体现的是软件中所有的业务规则，它是软件系统的真正价值所在。而细节指的是哪些让操作该系统的人，其他系统以及程序员们与业务规则进行交互，但是又不会影响到策略本身的行为，百科 I&#x2F;O 设备，数据库，Web 系统，服务器，框架，交互协议等。</p><p>一个设计良好的软件架构必须支持系统的用例正常运行，系统的维护，系统的开发，系统的部署。架构师可以通过采用单一职责（SRP）和共同闭包（CCP），以及既定的系统设计意图来隔离哪些变更原因不同的部分，集成变更原因相同的部分。</p><p>这样一来，我们发现可以把一个系统解耦成若干个水平分层 - UI 层，业务层，数据库等，在水平分层的基础上，我们还可以根据系统的用例来做垂直切片，通过这种方式来实现解耦。</p><p>举个购物车的例子，添加新订单和删除订单的用例在发生变更的原因上应该不一致，而且发生的频率也应该不一样。为了实现解耦，我们应该将添加新订单这个用例的 UI 与 删除订单用例的 UI 分开，而且对业务逻辑部分，数据库部分也同样要做分开。</p><p>只要系统按照其水平分层和用例进行了恰当的解耦，整个系统的架构就可以支持多团队开发，不管团队的组织形式是分功能开发、分组件开发、分层开发、还是按照其他的变量分工都可以。</p><p>按水平分层和用例垂直切分一个系统有很多种方式，比如在源代码层面解耦，在二进制层面解耦。</p><ol><li>源码层面，可以控制源代码模块之间的依赖关系，以此来实现一个模块的变更不会导致其他模块也需要变更或者重现编译。在这种解耦模式下，系统所有的组件都在同一个地址空间内执行，组件之间的交互可以通过简单的函数调用来实现。这类系统在运行时是作为一个执行文件被加载到计算机内存中的，这种模式被称为单体结构</li><li>部署层面，可以控制部署单元（jar，dll，共享库）之间的依赖关系，以此来实现一个模块的变更不会导致其他的模块重现构建和部署</li></ol><p>当然一个设计良好的系统应该允许从一个单体结构开始，以单一文件的形式部署，然后逐渐成长为一组互相独立的可部署单元，甚至是独立的独立或者微服务，然后还能随着情况的变化，允许系统逐渐退回到单体结构。</p><h2 id="软件架构的边界"><a href="#软件架构的边界" class="headerlink" title="软件架构的边界"></a>软件架构的边界</h2><p>前面提到架构师追求的目标是最大限度降低构建和维护一个系统所需要的人力资源，那么一个在一个系统中最消耗人力资源的是什么呢？答案是系统中存在的耦合。为了解决这个问题，我们就需要划分边界，利用边界把软件分割成各种元素，以便约束边界两侧之间的依赖关系。</p><p>应该在何时，何处划分边界呢？边界线应该画在不相干的事情中间，比如业务逻辑与数据库无关，所以两者之间应该有一条边界线。</p><p>如下图所示，BusinessRules 是 通过 Database Interface 来加载和保存数据的。而 DatabaseAccess 则负责实现该接口，并与实际 Database 交互。那么这里的边界线应该穿过继承关系，在 Database Interface 之下。DatabaseAccess 类有两个对外箭头，这两个箭头都指向了远离 DatabaseAccess 类的方向，这意味着它们所指向的两个类都不知道 DatabaseAccess 的存在。把抽象程度拉高一些，Database 组件可以被替换为多种实现，BusinessRules组件并不需要这个事情，数据库可以使用 MySQL，Oracle ,甚至大文件来实现都可以。</p><img src="/2022/05/30/software-architecture/Untitled.png" class="" title="This is an example image"><p>进一步来分析由于 GUI 能够被直观的感受到，GUI 很容易被开发者当成了系统本身，这个是错误的视角，I&#x2F;O 应该是无关紧要的，GUI 也是 I&#x2F;O 的一部分。所以如下图所示，GUI 和 BusinessRules 之间应该也要有一条边界线，通过边界线和箭头方向，我们可以得出 GUI 可以使用任何一种其他形式的界面来代替，BusinessRules 组件不需要了解这些细节，这就是插件式架构。</p><img src="/2022/05/30/software-architecture/Untitled1.png" class="" title="This is an example image"><h2 id="软件架构的业务"><a href="#软件架构的业务" class="headerlink" title="软件架构的业务"></a>软件架构的业务</h2><p>所有的软件都是一组业务逻辑的集合。整体的业务逻辑正常都可以被拆解为多组更小的业务逻辑。一部分业务逻辑可能用于描述计算部分，一部分业务逻辑可能描述计算报告的格式，可能还有另外一部分业务逻辑用于描述输入数据的校验。软件架构设计的工作重心之一就是将这些业务逻辑彼此分离，然后将它们按照变更的方式进行重新分组。在一个设计良好的架构中，依赖关系的方向通常取决于它们所管理的组件层次，一般来说，低层组件被设计为依赖于高层组件。这里的层次是严格按照“输入与输入之间的距离”来定义的，也就是说业务逻辑距离系统的输入&#x2F;输入越远，它所属的层次就越高。而直接管理输入&#x2F;输出的业务逻辑在系统中的层次最低。</p><img src="/2022/05/30/software-architecture/Untitled2.png" class="" title="This is an example image"><p>如上图所示，这个是一个简单加密程序的数据流向图，留意被虚线框起来的 Encrypt 类，CharReader 接口和 CharWriter 接口。Encrypt 类的所有的依赖关系都指向边界内部，这说明它是该系统中最高层次的组件。ConsoleReader 和 ConsoleWriter 都属于具体类，由于它们和输入&#x2F;输出最近，因此属于低层组件。</p><p>值得注意的是这个架构将高层的加密逻辑与低层的输入&#x2F;输出逻辑解耦了，也就是说当输入输出发生变化了，它们不太可能会影响高层加密组件的业务逻辑。通过将业务逻辑隔离，并让源码中的依赖方向都统一调整为指向高层业务逻辑，我们可以大幅度降低系统变更所带来的影响。因为一些针对系统低层组件的小修改基本不会影响系统中更高级，更重要的组件。</p><h2 id="整洁的软件架构"><a href="#整洁的软件架构" class="headerlink" title="整洁的软件架构"></a>整洁的软件架构</h2><p>一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以在脱离框架、工具以及使用环境的情况下完整的描述用例，并且尽可能的允许用户推迟和延后决定采用什么框架，数据库，Web 服务以及其他与环境相关的工具。这样的话，我们就可以在不依赖任何框架的情况下对这些用例进行单元测试。</p><p>那么一个良好的架构设计应该是怎么样的呢？一个良好的架构设计通常具备如下特点：</p><ol><li>独立于框架，可以把框架当成工具来使用，但是不需要让系统适应框架</li><li>可以被测试，业务逻辑可以脱离 UI，数据库，Web 服务以及其他的外部元素来进行测试</li><li>独立于 UI，系统的 UI 变更很简单，不需要修改其他的系统部分</li><li>独立于数据库，可以轻易替换系统使用的数据库</li><li>独立于任何外部系统，系统的业务逻辑并不需要知道任何其他外部接口的存在</li></ol><p>这个是整洁架构的示意图，同心圆分别代表了软件系统中的不同层次，越靠近中心，其所在的软件层次就越高。外层圆表示的是机制，内层圆表示的是业务逻辑，这其中有一条贯穿整个架构设计的规则即依赖规则，源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层业务逻辑。换句话说，内层圆中的代码不应该涉及外层圆的代码，尤其是内层圆中的代码不应该引用外层圆中代码所声明的名字，包括函数、类、变量等。</p><img src="/2022/05/30/software-architecture/Untitled3.png" class="" title="This is an example image"><ul><li>业务实体，这一层封装的是整个系统的关键业务逻辑，一个业务实体可以理解为一个带有方法的对象。这一层是可以被其他不同的应用复用的。</li><li>用例，包含的是特定应用场景下的业务逻辑，它封装并实现了系统的所有用例。这些用例引导数据在业务实体之间的流入和流出，并指挥着业务实体利用其中的关键业务逻辑来实现用例的设计目标。</li><li>接口适配器，接口适配器层通常是一组适配器，可以将数据从用例和业务实体最方便的格式转换为最适合某些外部系统（如数据库或Web）的格式。例如，这层将完全包含 GUI 的 MVC 体系结构。展示器（presenters)，视图（views）和控制器（controllers）都属于接口适配器层。模型部分应该由控制器传递给用例，再由用例返回到展示器和视图。</li><li>框架与驱动程序，最外层通常由框架和工具（如数据库和Web框架）组成，包含了所有的实现细节，Web 是一个实现细节，数据库也是一个实现细节。这些细节在最外层，它们就很难影响到其他层了。</li></ul><p>不同层之间会有数据交换，一般来说，会跨越边界的数据在数据结构上都是比较简单的。最重要的是这个跨边界传输的对象应该有一个独立、简单的数据结构，不要使用业务实体或者数据库记录对象。</p><h2 id="软件架构的测试"><a href="#软件架构的测试" class="headerlink" title="软件架构的测试"></a>软件架构的测试</h2><h3 id="测试也是一种组件"><a href="#测试也是一种组件" class="headerlink" title="测试也是一种组件"></a>测试也是一种组件</h3><p>和程序代码一样，测试应该也是系统的一部分，甚至于测试代码优势在系统架构中的地位还有比其他部分更独特一些。</p><p>究其本质而言，测试组件也要遵守依赖关系原则的。因为测试组件总是充满了各种细节信息，非常具体，所以它始终都是向内依赖于被测试部分的代码，所以我们可以将测试组件视为系统架构最外圈的程序。它们始终都是向内依赖的，而且系统中没有其他组件依赖它们。</p><h3 id="可测试性设计"><a href="#可测试性设计" class="headerlink" title="可测试性设计"></a>可测试性设计</h3><p>测试代码的关键之处在于耦合，如果测试代码与系统是强耦合的，它就必须随着系统变更而变更。哪怕只是系统中的组件一个小变化，都可能会导致许多与之相耦合的测试出现问题，需要做出相应的变更。修改一个通用的系统组件可能会导致成百上千个测试出现问题，我们通常将这类问题称为脆弱的测试问题。要想解决这个问题，就必须在设计中考虑到系统的可测试性。</p><p>软件设计很重要的一个原则，不管为了可测试性还是其他什么东西 ，” 是不变的，就不要依赖于多变的东西 “，比如 GUI 往往是多变的，因此通过 GUI 来验证系统的测试一定是脆弱的。因此，我们在系统设计与测试设计时，应该让业务逻辑不通过 GUI 也可以被测试。</p><h3 id="测试专用-API"><a href="#测试专用-API" class="headerlink" title="测试专用 API"></a>测试专用 API</h3><p>专门为验证业务逻辑的测试创建一个 API，这个 API 允许测试代码忽视安全限制，绕过成本高昂的资源（比如数据库），强制将系统设置到某种可以测试的状态中。总而言之，测试 API 应该成为用户界面所用到的交互器与接口适配器的一个超集。</p><p>结构耦合是测试耦合中最强，最隐蔽的形式之一。设想一个测试套件，它对每个产品类都有一个测试类，对每个产品方法都有一套测试方法。这样的测试套件与应用程序的结构紧密相关。当这些产品方法或类之一改变时，大量的测试也必须改变。因此这些测试是脆弱的，它们会让产品代码变得非常死板。测试专用 API 的作用就是将应用程序与测试代码解耦。这样我们的产品代码就可以在不影响测试的情况下进行重构和演进。同样的，这种设计也允许测试代码在不影响生成的情况下进行重构和演进。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。为了达到这个目标，在软件设计中需要关注业务解耦，关注组件边界，封装核心业务逻辑。通过前人不断的经验总结，摸索出了一个整洁结构的设计方法论。除了关注业务代码，还需要关注测试代码的设计，它也是系统的一部分。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件耦合</title>
    <link href="/2022/05/28/component-dependencies/"/>
    <url>/2022/05/28/component-dependencies/</url>
    
    <content type="html"><![CDATA[<h1 id="组件耦合"><a href="#组件耦合" class="headerlink" title="组件耦合"></a>组件耦合</h1><p>前面讲了怎么利用三个原则<a href="https://junbinchencn.github.io/2022/05/28/component-aggregation/">构建组件</a> ，现在利用接下来的三个原则来组织组件之间的关系。</p><h2 id="无依赖环原则（ADP）"><a href="#无依赖环原则（ADP）" class="headerlink" title="无依赖环原则（ADP）"></a>无依赖环原则（ADP）</h2><p>在项目中经常出现有人修改了你依赖的某个组件导致你的程序出错的这类型场景。为了解决这个类型的问题逐渐演化出了两种解决方案，第一种是“每周构建”， 第二种是“无依赖环原则” 。</p><p>每周构建比较容易理解，就是每周五要求所有人将自己所有的更改提交，进行统一构建，把一些问题集中解决掉。</p><p><strong>无依赖环原则认为组件依赖关系图中不应该出现环。</strong>必须控制好组件之间的依赖结构，绝对不能允许该结构中存在着循环依赖关系。当有人或者团队完成某个组件的某个版本的时候，给这个组件打一个版本号，然后放入共享目录，并通知其他程序员，这样依赖每个程序员都可以依赖于这个组件公开发布的版本来进行开发，而组件的拥有者则可以继续去修改自己的私有版本。</p><img src="/2022/05/28/component-dependencies/Untitled.png" class="" title="this is image"><p>如上图，这个是一个程序的组件结构图。该组件依赖结构就是一个有向图，图中的每个节点都是一个项目组件，依赖关系就是有向图中的边。不管我们从哪个组件开始，沿着哪条边走，最终都不会回到起始点。假如 Presenters 组件要发布新版本，根据组件依赖结构，我们很容易判断出 View 和 Main 组件会受这次变更影响。假如是 Main 组件发布新版本，我们也可以知道不会有组件受影响。</p><p>如下图，红色框内的组件依赖关系违反了无依赖环原则，这种情况下要怎么打破循环依赖呢？</p><img src="/2022/05/28/component-dependencies/Untitled1.png" class="" title="this is image"><ul><li><strong>应用依赖反转原则（DIP）</strong></li></ul><p>假设 Entities 组件中的 User 类依赖的是 Authorizer 组件中的 Permissions 类。</p><img src="/2022/05/28/component-dependencies/Untitled2.png" class="" title="this is image"><p>我们可以使用 DIP 原则来解决这个问题，将 Entities 与 Authorizer 组件之间的依赖关系反转。在 Entities 组件内部增加一个 Permissions 接口，User 类直接使用该接口， Authorizer 组件的 Permissions 类实现 Permissions 接口。这样一来，Entities 组件就不再依赖 Authorizer 组件，而 Authorizer 组件依赖 Entities 组件。</p><img src="/2022/05/28/component-dependencies/Untitled3.png" class="" title="this is image"><ul><li><strong>创建一个新组件</strong></li></ul><p>把 Authorizer 组件中被依赖的 Permissions 类拿出来，单独成为一个组件，Entities 组件和 Authorizer 组件同时依赖它。</p><img src="/2022/05/28/component-dependencies/Untitled4.png" class="" title="this is image"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>程序的组件结构图的一个重要的目标就是指导我们如何隔离频繁的变更，我们不希望频繁变更的组件影响到本来应该稳定的组件。</p><h2 id="稳定依赖原则（SDP）"><a href="#稳定依赖原则（SDP）" class="headerlink" title="稳定依赖原则（SDP）"></a>稳定依赖原则（SDP）</h2><p>这原则指导我们依赖关系必须要指向更稳定的方向。任何一个预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也会变得难以修改。</p><p>如下图所示，有三个组件依赖这 X，所以 X 有三个不应该被修改的原因，同时 X 不依赖于任何组件，不会有任何原因导致 X 需要被修改，所以 X 是一个稳定的组件。</p><img src="/2022/05/28/component-dependencies/Untitled5.png" class="" title="this is image"><p>如下图所示，Y 依赖三个组件，所以 Y 有三个来自外部的变化源，所以 Y 依赖的，是一个不稳定的组件。 </p><img src="/2022/05/28/component-dependencies/Untitled6.png" class="" title="this is image"><h2 id="稳定抽象原则-（SAP）"><a href="#稳定抽象原则-（SAP）" class="headerlink" title="稳定抽象原则 （SAP）"></a>稳定抽象原则 （SAP）</h2><p>一个组件的抽象化程度应该与其稳定性一致。如果一个组件要成为稳定组件，那么它就应该由接口和抽象类组成，这样将来可以做拓展。SAP 原则告诉我们依赖关系应该指向更抽象的方向。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无环依赖原则，稳定依赖原则，稳定抽象原则关注的是组件之间的关系。在应用这些原则的时候，作为架构师应该需要在研发能力和逻辑设计之间的冲突做权衡，影响组件结构的不仅仅有技术水平同时还有团队的组织架构。在组件耦合背后需要各种用于依赖关系管理的指标，可以用来量化分析软件设计与优秀设计之间的契合度。当然不同团队的指标是不一致的，这个需要团队摸索出适合自己的指标。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件聚合</title>
    <link href="/2022/05/28/component-aggregation/"/>
    <url>/2022/05/28/component-aggregation/</url>
    
    <content type="html"><![CDATA[<h1 id="组件聚合"><a href="#组件聚合" class="headerlink" title="组件聚合"></a>组件聚合</h1><p>软件的构建过程和建筑物修建很类似，都是由一个一个小组件组成。如果说 SOLID 原理是用于指导我们如何将砖块砌成墙与房间，那么组件构建原则就是用来指导我们如何将这些房间组合成房子的。在软件的构建过程中，组件就是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体。对 Java 来说，组件就是 jar，对 Android 来说，组件就是一个 aar，对 iOS 来说，组件就是一个 framework。聚合原则主要讨论哪些类可以组合成一个组件。</p><h3 id="复用-x2F-发布等同原则-（REP-The-Reuse-x2F-Release-Equivalence-Principle）"><a href="#复用-x2F-发布等同原则-（REP-The-Reuse-x2F-Release-Equivalence-Principle）" class="headerlink" title="复用&#x2F;发布等同原则 （REP: The Reuse&#x2F;Release Equivalence Principle）"></a>复用&#x2F;发布等同原则 （<strong>REP</strong>: The Reuse&#x2F;Release Equivalence Principle）</h3><p>软件复用的最小粒度应等同于其发布的最小粒度，从软件设计的角度看，REP 原则就是指组件中的类与模块必须是密切相关的，它们之间应该有一个共同的主题。</p><h3 id="共同闭包原则-（CCP-The-Common-Closure-Principle）"><a href="#共同闭包原则-（CCP-The-Common-Closure-Principle）" class="headerlink" title="共同闭包原则 （CCP: The Common Closure Principle）"></a>共同闭包原则 （<strong>CCP</strong>: The Common Closure Principle）</h3><p>我们应该将哪些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将哪些不会同时修改，并且不会为了相同目的而修改的哪些类放到不同的组件中。CCP 的主要作用是提示我们要将所有可能会被一起修改的类集中在一起成为同一个组件，通过遵守 CCP 原则可以有效降低因软件发布，验证以及部署带来的工作压力。</p><p><strong>CCP 原则其实是 SRP 原则在组件构建层面的体现</strong>。SRP 原则指导我们把不同变更原因的函数放入不同的类，而 CCP 原则指导我们将变更原因不同的类放入不同的组件中。</p><p><strong>CCP 和 OCP 开闭原则也是紧密关联的，2 个原则都有讨论闭包</strong>。OCP 原则认为一个类应该便于扩展而抗拒修改，完全闭包是不可能的，我们可以有选择性的闭包。CCP 则进一步指导我们将某一类变更所涉及的类聚合在一起，以最大限度减少该组件变更造成的影响。</p><h3 id="共同复用原则-（CRP-The-Common-Reuse-Principle）"><a href="#共同复用原则-（CRP-The-Common-Reuse-Principle）" class="headerlink" title="共同复用原则 （CRP: The Common Reuse Principle）"></a>共同复用原则 （<strong>CRP</strong>: The Common Reuse Principle）</h3><p>不要强迫一个组件的用户依赖它们不需要的东西，CRP 原则指导我们将经常共同复用的类和模块放在同一个组件中。举一个常见的例子，容器类 Collection 和其相关的遍历类 Iterator 通常都放置同一个组件中。CRP 更像是在实际上指导我们，不是紧密相连的类不应该被放在同一个组件里。</p><p><strong>CRP 原则其实是 ISP 原则在组件构建层面的体现</strong>，ISP 原则指导不要依赖带有不需要函数的类，而 CRP 则是指导我们不要依赖带有不需要的类的组件。</p><h3 id="组件聚合张力图"><a href="#组件聚合张力图" class="headerlink" title="组件聚合张力图"></a>组件聚合张力图</h3><img src="/2022/05/28/component-aggregation/Untitled.png" class="" title="this is an example image"><p><strong>这是组件构建原则中最有价值的一张图，REP 原则是为了复用性而组合类，CRP 原则是为了避免不必要的发布而拆分，CCP 原则是为了维护性而组合。</strong>在 REP 和 CRP 原则用力过度，会造成太多组件变更。在 REP 和 CCP 原则用力过度，会造成太多不必要的发布。在 CRP 和 CCP 原则用力过度，会造成复用困难。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个项目在三角张力区域的哪个位置是随着时间推移而动态调整的，在项目的早期，为了能够快速上线，会牺牲项目的复用性，项目的重心会从三角区域的右侧开始。随着项目的逐渐成熟，其他项目会开始对其产生依赖，项目的重心会逐渐向三角区域的左侧滑动。在构建组件时，必须要考虑到研发型和复用性之间的矛盾关系，同时也必须平衡项目的成本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计原则</title>
    <link href="/2022/05/27/solid/"/>
    <url>/2022/05/27/solid/</url>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>想要构建一个好的软件系统，首先应该从写整洁的代码开始做起。软件设计如同建筑一样，SOLID 指导我们如何将砖头砌成墙与房间。它的主要作用是告诉我们如何将数据和函数组织成类，以及如何将这些类链接起来成为程序，SOLID 原则主要适应于模块级别的编程。</p><h2 id="单一职责原则-（SRP，Single-Responsibility-Principle"><a href="#单一职责原则-（SRP，Single-Responsibility-Principle" class="headerlink" title="单一职责原则 （SRP，Single Responsibility Principle)"></a>单一职责原则 （SRP，Single Responsibility Principle)</h2><p>SRP 原则指的是任何一个软件模块都应该只对某一类行为者负责。这里的软件模块可以理解为一个源代码文件，某一类行为者可以理解成对软件模块有相似变更原因的一类人。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><img src="/2022/05/27/solid/Untitled.png" class="" title="This is an example image"><img src="/2022/05/27/solid/Untitled1.png" class="" title="This is an example image"><p>举个工资管理程序例子，如上图。Employee 这个类有三个函数，三个函数分别对应的是三个不同的行为者，违反了 SRP 原则。calculatePay() 函数是财务部门制定的，向 CFO 汇报。reportHours() 函数是人力资源部门制定的，向 COO 汇报。save() 函数是 DBA 制定的，向 CTO 汇报。这三个函数被放在同一个类中，这样做相当于把三个不同的行为者耦合在一起了，这有可能导致 CFO 团队的行为影响了 COO 团队的行为。在这里 calculatePay() 函数和 reportHours() 函数使用同样的逻辑来计算正常的工作时数，并将这个算法单独实现成 regularHours() 函数。</p><p>假设接下来 CFO 团队需要修改工作时长的计算方法 ，负责修改的程序员按照新的变更需求修改了regularHours() 函数实现，而 COO 团队不需要修改  regularHours() 函数实现，那么这个时候就会出问题了。作为程序员，类似的问题肯定经历的不少，总结一下这类问题的原因就是我们把不同行为者所依赖的代码凑到了一起，而 <strong>SRP 原则强调这类代码一定要分开</strong>。</p><p>要解决上面的问题最简单的方法就是把数据与函数分离，设计三个类共同使用一个只包含数据的 EmployeeData 类，每个类只包含与之相关的函数，这样就不存在互相依赖的情况。</p><img src="/2022/05/27/solid/Untitled2.png" class="" title="This is an example image"><p>上面的方案也有一个缺点，我们需要在程序里处理三个类，更近一步的解决方案是使用 Facade 设计模式来解决这个问题，这样一来我们只需要关注 EmployeeFacade 类里面的少量代码了。</p><img src="/2022/05/27/solid/Untitled3.png" class="" title="This is an example image"><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SRP原则主要讨论的是函数和类之间的关系，强调将服务不同行为者的代码进行切分</p><h2 id="开闭原则（OCP，Open-Closed-Principle）"><a href="#开闭原则（OCP，Open-Closed-Principle）" class="headerlink" title="开闭原则（OCP，Open Closed Principle）"></a>开闭原则（OCP，Open Closed Principle）</h2><p>OCP 原则认为设计良好的计算机软件应该易于拓展，同时抗拒修改。OCP 原则是架构设计中的主导原则，主要目标就是让系统易于拓展，同时要限制其每次被修改所影响的范围。</p><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>假设要设计一个在 Web 页面上展示财务数据的系统，同时该系统可以根据需要形成一个报表，该报表可以使用打印机打印。</p><p>设计思路是这样的，我们根据 SRP 原则先将满足不同需求的代码分组，然后再根据 DIP 原则来调整这些分组之间的依赖关系。</p><img src="/2022/05/27/solid/Untitled4.png" class="" title="This is an example image"><p>根据 SRP 原则，我们梳理出了数据流。先用一段<strong>财务分析程序</strong>处理原始的财务数据，形成<strong>财务报表数据结构</strong>，最后再用 2 个不同的<strong>报表生成器</strong>来生成报表。这里的核心就是把生成过程和展示过程拆分开了。</p><img src="/2022/05/27/solid/Untitled5.png" class="" title="This is an example image"><p>接下来，我们修改源代码之间的依赖关系了，这样的目的是保证其中一个操作被修改之后不会影响到另外的一个操作。同时我们所构建的代码组织形式应该保证该程序后续在行为上的拓展都无需修改现有代码。如上图所示，我们将程序划分为不同的组件，包括 Controller，Presenter，View，Interactor，Database 组件。图中的开放箭头表示的是使用关系，图中的箭头都指向那些我们不想经常更改的组件，所有的组件的依赖关系都是单向的。</p><p><strong>这里有一个设计原则，如果 A 组件不想被 B 组件上发生的修改所影响，那么就应该让 B 组件依赖于 A 组件</strong>。我们不想让发生在 Presenter 上的修改影响到 Controller，不想让发生在 View 上面的修改影响到 Presenter ,最关键的是不想让任何修改影响到 Interactor。在这个设计中 Interactor 是最符合 OCP 原则的，发生在 Controller，Presenter，View，Database 组件上的修改都不会影响 Interactor。</p><p>这里我们根据组件离输入输出端的远近来定义组件的层级，比如 View 组件就是输出端，所以在最低层级，Presenter 组件 比 View 层级更高，Controller 组件比 Presenter 和 View 层级更高，而 Interactor 组件离输入输出端最远，为最高层级组件。</p><p>进一步思考，为什么 Interactor 组件要放在这种重要的位置上呢？因为它是整个软件的核心业务逻辑所在，包含了最高层次的应用策略，是最高层的抽象，其他组件都是辅助逻辑，所以 Interactor 需要被保护得最严密。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>OCP 原则在软件架构层次上的应用，先根据相关函数的修改原因，修改方式以及修改时间来对其进行分组隔离，这些互相隔离的函数分组整理成组件，将这些组件间的依赖关系按层次结构进行组织，使得高层级组件不会因为低层级组件被修改而受到影响。</p><h2 id="里氏替换原则（LSP，Liskov-Substitution-principle）"><a href="#里氏替换原则（LSP，Liskov-Substitution-principle）" class="headerlink" title="里氏替换原则（LSP，Liskov Substitution principle）"></a>里氏替换原则（LSP，Liskov Substitution principle）</h2><p>LSP 原则认为子类对象可以在程序中代替其基类对象，LSP 原则不仅仅是指导我们如何使用继承关系的一种方法，更是一种更广泛的，指导接口与其实现方式的设计原则。</p><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><img src="/2022/05/27/solid/Untitled6.png" class="" title="This is an example image"><p>上图所示，我们有一个 License 类，该类有一个 calcFee() 的方法，该方法被 Billing 程序调用。License 类有 2 个子类，它们会用不同的算法来计算授权费用。这个设计是符合 LSP 原则的，因为 Billing 程序的行为不依赖于使用的任何一个具体的衍生类，也就是说这 2 个子类是可以用来替换 License 类对象的。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>软件设计中应该更多依赖于接口，并且实现该接口的类之间能具有可替换性。</p><h2 id="接口隔离原则（ISP-Interface-Segregation-Principles）"><a href="#接口隔离原则（ISP-Interface-Segregation-Principles）" class="headerlink" title="接口隔离原则（ISP,Interface Segregation Principles）"></a>接口隔离原则（ISP,Interface Segregation Principles）</h2><p>ISP 原则认为客户不应被迫使用对其而言无用的方法或功能</p><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><img src="/2022/05/27/solid/Untitled7.png" class="" title="This is an example image"><p>有多个用户需要使用 OPS 类，User1 只需要使用 op1 接口，User2 只需要使用 op2 接口，User3 只需要使用 op3 接口。但是显然 User1 不需要使用 op2 和 op3，但是在源代码层面上也会与它们形成依赖关系，这种依赖关系导致我们在 OPS 中对 op2 做任何的修改，即使不会影响 User1 的功能，也会导致它需要重新编译和部署。</p><img src="/2022/05/27/solid/Untitled8.png" class="" title="This is an example image"><p>通过将不同的操作隔离成不同的接口可以解决上面的问题，现在 User1 的源代码只会依赖 U1Ops 和 op1 但不会依赖于 OPS。这样一来，以后关于 OPS 的修改只要不会影响到 User1 的功能，User1 就不需要重新编译和部署了。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>ISP 原则告诉我们，任何层次的软件设计如果依赖了它并不发需要的东西，就会带来意料之外的麻烦</p><h2 id="依赖反转原则（DIP，Dependency-Inversion-Principle）"><a href="#依赖反转原则（DIP，Dependency-Inversion-Principle）" class="headerlink" title="依赖反转原则（DIP，Dependency Inversion Principle）"></a>依赖反转原则（DIP，Dependency Inversion Principle）</h2><p>DIP 原则告诉我们，如果想要设计一个灵活的系统，在源代码层级的依赖关系中应该多使用抽象类型而非具体实现。</p><p>将 DIP 原则归纳成具体的编码规则：</p><ul><li>应在代码中多使用抽象接口，尽量避免使用哪些多变的具体实现类，对象的创建过程需要受到严格限制，通常可以使用抽象工厂这个设计模式</li><li>不要在具体实现类上创建衍生类。在静态类型的编程语言中，依赖关系是所有一切源代码中依赖关系最强的，最难以被修改的，所以我们对继承的使用要格外小心</li><li>不要 override 包含具体实现的函数，调用包含具体实现的函数也就意味着引入了源代码界别的依赖，即使 override 了这些函数，我们也无法消除继承中的依赖关系。应该创建一个抽象函数，为这个抽象函数提供多种具体实现</li><li>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物名字</li></ul><h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><img src="/2022/05/27/solid/Untitled9.png" class="" title="This is an example image"><p>对象的创建操作都免不了在源代码上依赖于对象的具体实现，在大部分的面向对象编程语言中，我们都可以选择用抽象工厂模式来解决源码依赖的问题。</p><ol><li>Application 类通过 Service 接口来使用 ConcreteImpl ,然而 Application 还需要构造 Concrete Impl 类的实例。</li><li>Application 类为了避免在源代码层次上引入对 ConcreteImpl 类具体实现的依赖，现在 Application 类调用 ServiceFactory 接口的 makeSvc 方法，这个方法由 ServiceFactoryImpl 类来提供具体实现。</li><li>ServiceFactoryImpl 类的 makeSvc 方法的具体实现就是初始化一个 ConcreteImpl 类的实例，并且将其以 Service 类型返回。</li></ol><p>如上图所示，中间的曲线代表了软件架构中的抽现层与实现层的边界</p><ol><li>所有跨越这条边界的源代码级别的依赖都是单向的，即具体实现层依赖抽象层。</li><li>曲线将系统划分成 2 个部分的组件，抽象接口和具体实现。抽象接口包含应用的高阶业务逻辑，具体实现这包含业务规则的具体操作。</li><li>程序控制流跨越架构边界的方向与源代码依赖关系跨越架构边界的方向正好相反，即源代码依赖方向永远是控制流方向的反转，这就是 DIP 被称为依赖反转原则的原因。</li><li>在软件系统中不可能完全消除违反 DIP 原则的情况，通常只需要把它们集中于少部分具体实现组件中，将其与其他部分隔离即可。ServiceFactoryImpl 对 ConcreteImpl 的依赖就是这样的情况。</li></ol><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>在应用 DIP 时，我们也不必考虑稳定的操作系统和平台设计，因为这些系统接口变动很少。如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。我们需要花费很大的精力来设计接口，以减少未来对其进行改动。我们主要应该关注软件系统内部哪些会经常发生变动的具体实现模块。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.m.wikipedia.org/zh-hans/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)">https://zh.m.wikipedia.org/zh-hans/SOLID_(面向对象设计)</a> </li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">https://zh.m.wikipedia.org/zh-hans/单一功能原则</a> </li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">https://zh.m.wikipedia.org/zh-hans/开闭原则</a> </li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">https://zh.m.wikipedia.org/zh-hans/里氏替换原则</a> </li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99">https://zh.m.wikipedia.org/zh-hans/接口隔离原则</a> </li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99">https://zh.m.wikipedia.org/zh-hans/依赖反转原则</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客迁移</title>
    <link href="/2022/05/26/blog-note/"/>
    <url>/2022/05/26/blog-note/</url>
    
    <content type="html"><![CDATA[<p>以前的一些博客平台写着写着就停更了，转而使用封闭的笔记软件进行总结。恰巧这几天有时间，把部分文章从简书平台 <a href="https://www.jianshu.com/u/cea4fc286dd3">要上班的斌哥</a> 迁移到这里来，同时也把自己的过往的一些笔记进行整理分享。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>结构化编程 &amp; 函数式编程</title>
    <link href="/2022/05/25/functional-procedural-programming/"/>
    <url>/2022/05/25/functional-procedural-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="结构化编程-amp-函数式编程"><a href="#结构化编程-amp-函数式编程" class="headerlink" title="结构化编程 &amp; 函数式编程"></a>结构化编程 &amp; 函数式编程</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><ul><li>计算机科学家 dijkstra 认为 goto 语句的无限制跳转会损坏程序的整体结构，应该使用 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句来替代跳转语句。简而言之结构化编程对程序控制权的直接转移进行了限制和规范。</li><li>函数式编程语言中的变量是不可变的，函数式编程是对程序中的赋值操作进行限制。</li></ul><h2 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h2><ul><li><strong>结构化编程的诞生</strong></li></ul><p>dijkstra 提出为了能够证明程序的正确性，就必须把程序模块递归拆分成更小的，可以被证明的单元，dijkstra 经过研究发现，goto 语句可能会导致大模块无法被进一步拆分成更小的，可被证明的单元，同时 goto 语句的用法与 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句的作用又没有明显的区别，所以 goto 是可以被替代的。</p><p>另外一个证明是代码中使用了顺序结构，分支结构，循环结构，那么代码是一定可以被拆解成更小的，可证明的单元，而且程序员可以用顺序结构，分支结构，循环结构这 3 类结构构造出任何程序。到这里有个发现很重要，构建可被证明的模块所需要的控制单元和构建所有程序所需要的控制单元的最小集合是一样的，结构化编程就这样诞生了！！！</p><p>结构化编程范式可以将模块递归降解成可以被推导的单元，这意味着可以把模块按功能进行分解，更进一步说可以把一个大型问题拆分成一系列高级函数组合，而高级函数又可以进一步被拆分为一系列低级函数，每个被拆分出来的函数都可以使用结构化编程范式来构造程序。然后再编写相关的测试来证明这些函数程序是错误的，如果无法证明这些函数代码是错误的，那么我们就可以直接认为这些函数代码是正确的，推导到整个程序是正确的。</p><ul><li><strong>结构化编程的价值</strong></li></ul><p>结构化编程范式中最有价值的点赋予了我们创造可证伪程序单元的能力。延伸到架构设计领域，功能性拆解仍然是验证程序正确性的最佳实践之一。</p><p>我近几年来都是在接触代码重构相关的事情，项目涉及的业务多种多样，但是项目都存在一个明显的问题就是功能模块互相依赖的问题，因为依赖太多导致变更带来非常多的不确定性，同时变更带来的测试成本大无法接受的地步。另外功能模块互相依赖还会带来一个明显部署问题，由于互相依赖，模块无法单独部署，需要所有的模块一起部署。随之而来的还有编译问题，互相依赖过多，一旦被依赖方发生变动，所有的依赖方都必须重新编译，这个最明显的是很多项目中的 common 模块。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><strong>函数式编程的价值</strong></li></ul><p>函数式编程对变量可变性进行限制，而不可变性正是软件架构设计中需要考虑的重点。为什么软件架构设计中需要考虑可变性呢？因为所有的竞争问题，死锁问题，并发更新问题都是由变量的可变性造成的，如果变量永远不会被改变，那么就不会产生竞争或者并发问题。如果锁的状态是不可变的，那么就不会产生死锁问题。在软件架构设计中需要对并发问题保持高度关注，在实际应用中不可变性这个特点是否具备可行性呢？</p><ul><li><strong>可变性隔离</strong></li></ul><p>可变性隔离一种常见的方式是把应用程序的内部服务进行划分，划分为可变的和不可变的组件。不可变组件用纯函数来执行任务，期间不能修改任何的状态，不可变组件将通过非函数式组件通信的方式来修改变量的状态，由于修改变量的状态会产生一系列编发问题，所以通常采用某种事务型内存来保护可变变量，避免并发和死锁问题。</p><p>一个设计良好的软件架构中应该将状态修改的部分和不需要修改状态的部分分别隔离成单独的组件，然后用合适的机制来保护可变量，所以在架构设计中应该致力于将大部分处理逻辑都归纳到不可变组件中，可变状态组件的逻辑越少越好。</p><ul><li><strong>事件溯源</strong></li></ul><p>随着存储和计算能力的大幅提升，我们有可能做到只存储事务记录，不存储具体状态，当需要具体状态是，我们只要从头开始计算所有的事务即可，这样的设计看起来是很美好，不过实用性是差一些。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结笔记</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/过程式编程</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98">https://zh.m.wikipedia.org/zh-hans/事务内存</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/函数式编程</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/24/object-oriented-programming/"/>
    <url>/2022/05/24/object-oriented-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>现在软件开发当中，面向对象编程已经成为一个黄金标准，那究竟什么是面向对象？对于这个问题有很多回答，一种回答是 “数据与函数的组合”，另一种回答是对真实世界进行建模的方式，还有另外一种回答是涉及到封装，继承，多态，也就是说面向对象是这三项的组合。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装这个特性因为在面向对象编程用的多了，导致不少人经常会认为它就是面向对象的一部分，其实不是这样的。C 语言中的 struct 结构体就是支持完整的封装，在引入 point.h 文件的程序中是没有 Point 这个结构体的内部访问权限的，只能调用 makePoint 和 distance 函数，但是不清楚函数内部的具体实现细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// point.h </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span>;<br><br><span class="hljs-comment">// point.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-comment">// 构造 Point</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span> &#123;<br>    <span class="hljs-comment">// 计算距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 作为一个面向对象编程语言，在封装的完整性反而不如 C 语言。稍微改造一下上面的 Point 例子，虽然编译器会禁止外部 x,y 这 2 个变量的范围，但是调用者都知道了它们的存在。不过 C++ 在语法层面引入了 public，private，protected 这些访问控制的关键词，在一定程度上维护了封装性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一个面向对象编程语言 Java 则彻底抛弃了头文件和实现文件分离的编程方式，这也是破坏封装完整性的表现，因为我们无法区分一个类的声明和定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>      <span class="hljs-comment">// 构造 Point</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(Point p1, Point p2)</span> &#123;<br>      <span class="hljs-comment">// 计算距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们基本可以得出强封装并不是面向对象编程的必要条件。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的主要作用是让程序员可以在某个作用域内对外部定义的一组变量与函数进行覆盖。但是实际上 C 语言也可以做到，不仅仅是面向对象编程语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// namedPoint.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span>;</span><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// namedPoint.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>    <span class="hljs-type">char</span>* name;<br>&#125;<br><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-comment">// 构造 NamedPoint</span><br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">orgin</span> =</span> makeNamedPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">upperRight</span> =</span> makeNamedPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;upperRight&quot;</span>);<br><br>distance((<span class="hljs-keyword">struct</span> Point *)orgin, (<span class="hljs-keyword">struct</span> Point *)upperRight);<br></code></pre></td></tr></table></figure><p>看 main.c 里面的代码，因为 NamedPoint 和 Point 结构体的前 2 个成员顺序一致，所以 NamedPoint 可以被伪装成 Point 来使用，在程序中必须显式把 NamedPoint 强制转换为 Point 类型。通过上面的案例，我们可以了解到继承的特性在面向对象被发明之前就已经在使用了。但是在面向对象编程语言中，这种向上的类型转换是隐式，虽然面向对象编程在继承性上没有突破，但是至少在数据类型的转换上提供了便利。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象编程涉及到封装，继承，多态这 3 个特性，前面提到了封装和继承都不是面向对象编程独有特性，那么多态是不是面向对象编程独有的呢？答案也是否定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getchar()) != EOF) &#123;<br>        <span class="hljs-built_in">putchar</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getchar() 负责从 STDIN 读数据，putchar() 负责往 STDOUT 写数据，那么 STDIN 和 STDOUT 又具体表示哪些设备呢？显然 getchar 和 putchar 这类函数就具有多态性，因为他们的行为依赖于 STDIN 和 STDOUT 的具体实现。</p><p>以 Unix 为例，每个 IO 设备的驱动程序都要提供 open,close,read,write,seek 这 5 个标准函数实现。在 FILE 数据结构体中也包含了这 5 个标准函数对于的函数指针，这些函数指针用于指向 IO 设备驱动提供标准函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FILE 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br>    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode)<br>    <span class="hljs-type">void</span> (*close)();<br>    <span class="hljs-type">int</span> (*read)();<br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br>    <span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode);<br>&#125;<br><br><span class="hljs-comment">// 设备驱动程序实现</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// open 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*close)() &#123;<br>    <span class="hljs-comment">// close 实现</span><br>&#125;<br><span class="hljs-type">int</span> (*read)() &#123;<br>    <span class="hljs-comment">// read 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>) &#123;<br>    <span class="hljs-comment">// write 实现</span><br>&#125;<br><br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// seek 实现</span><br>&#125;<br><br><span class="hljs-comment">//getchar 函数的大致实现</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span>* <span class="hljs-title">STDIN</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> STDIN-&gt;read()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的程序中看，getchar 函数本质上是使用了 STDIN 来调用保存在 FILE 结构中的 read 函数指针所指向的函数实现。说到底，多态其实就是函数指针的一种应用。用函数指针实现多态的最大问题就是函数指针的危险性了，因为函数指针的调用依赖于程序员的约定，程序员必须严格遵守规则按照函数指针的类型来初始化函数指针，并严格按照函数指针的类型来使用函数指针。在编程中可以确定计算机能够遵守规则，但是无法确定程序员会遵守规则。</p><p>同继承一样，面向对象编程本质上还是没有在多态上进行创新，面向对象编程语言为程序员消除了人工遵守规则的必要，它让多态变得更安全，更便于使用了。<strong>结构化编程对程序控制权的直接转移进行了限制和规范，而面向对象编程其实是对程序的间接控制权的转移进行了限制，具体一些就是原来多态的调用只要函数类型一致就可以使用函数指针进行调用，而不需要有什么其他额外关系，但是现在面向对象编程在这个基础上加上了一些数据类型的限制。</strong></p><h3 id="带来的价值"><a href="#带来的价值" class="headerlink" title="带来的价值"></a>带来的价值</h3><ul><li>插件式架构</li></ul><p>Unix 系统将 IO 设备设计成插件式架构，随后在多个操作系统都有应用，即使知道多态有如此多的优点，但是碍于函数指针是一项及其危险的技术，大部分程序员还是不敢将插件式架构引入系统。但是面向对象编程的出现使得插件式架构可以安全地被应用在任何地方。</p><ul><li>依赖反转</li></ul><p>在安全和便利的多态技术出现之前，软件的典型调用树是这样的，HightLayer 模块要调用 MiddleLayer 模块，HightLayer 模块必须要依赖 MiddleLayer 模块 ，程序的源代码依赖不可避免的需要跟随程序的控制流。这让我们这些程序员在软件架构上没有什么其他多余的选择，软件的系统行为决定了程序的控制流，而控制流则决定了源代码依赖关系。</p><p>依赖关系和控制关系如下图所示，实线表示源代码依赖关系，虚线表示控制流关系。</p><img src="/2022/05/24/object-oriented-programming/Untitled.png" class="" title="This is an example image"><p>现在利用面向对象编程语言提供的安全便利的多态实线，无论我们面对怎么样的源代码依赖，我们都可以将其反转（源代码依赖方向和控制流方向相反）。如下图所示，模块 HightLayer 调用模块 MiddleLayer 中的 function 函数，这里的调用在是通过源代码界别的 interface 来实现的，在程序的实际运行过程中，interface 这个概念是不存在的，HightLayer 会直接调用 MiddleLayer 中的 function 函数。</p><img src="/2022/05/24/object-oriented-programming/Untitled01.png" class="" title="This is an example image"><p>延伸一下，这种能力在实际的软件架构设计中有什么作用呢？看下图，我们可以让用户界面和数据库都依赖业务逻辑，业务逻辑不需要引入用户界面和数据库的依赖，这样用户界面和数据库就成为业务逻辑的插件。这样一来，用户界面，业务逻辑，数据库就可以成为 3 个独立的组件，可以单独编译和部署，同时用户界面或者数据库的修改就不会对业务逻辑产生任何的影响。进一步说，当某个组件需要修改是，仅仅需要重新编译和部署该组件，不需要更改其他的组件，这就是独立部署能力。再进一步说，如果组件可以独立部署，那么就意味着组件可以由不同的团队并行开发，这就是架构的独立开发能力，也是架构和团队组织互相影响。</p><img src="/2022/05/24/object-oriented-programming/Untitled02.png" class="" title="This is an example image"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">https://zh.wikipedia.org/wiki/面向对象程序设计</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈软件架构的价值</title>
    <link href="/2022/05/23/talking-about-the-value-of-architecture/"/>
    <url>/2022/05/23/talking-about-the-value-of-architecture/</url>
    
    <content type="html"><![CDATA[<p>一个业务功能，新手和高手同样都可以实现，为什么还要招聘高手呢？在项目预算支持的情况下，通常会招聘更多有经验的程序员来进行开发。</p><p>软件行业中，确实是普遍存在上述的这类现象。 调试并实现一个业务功能并不需要非常高深的知识，甚至一名初入行的实习生都可以做到，将需求文档转换为能够实际上线运行的代码也不会多难，实习生写出来的代码可能不够优雅，但是确实能够正常工作。</p><p>在系统运作一段时间之后，新手可能需要 007 疯狂加班来实现需求。高手因为丰富的架构设计经验，提前做好软件架构设计，系统能够适应各类变化，新需求只需要很少的时间就能够上线。</p><h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>回想我自己的从业经历，确实经历不少这样的场景。某个软件历史悠久，各个组件互相依赖，到处充满了垃圾代码。即使是小改动，也是牵一发而动全身，让整个项目的产品，设计，开发，测试人员充满痛苦。每逢这个时候就会臆想，这个软件要是采用了好的架构设计，可以大大节省软件的开发和测试成本，每次变更都能控制最小影响范围，用最小的成本满足功能性需求。</p><p>好的架构设计具有这么大的魅力，那究竟什么才是软件架构？类比建筑，软件架构就是软件的组织架构，它关注组件，类，函数，模块，层级的设计。</p><h3 id="软件架构有什么用"><a href="#软件架构有什么用" class="headerlink" title="软件架构有什么用"></a>软件架构有什么用</h3><p>正如前面所提，它的目标就是用最小的人力成本来满足构建和维护系统的需求。软件架构具有 2 个方面的价值，一个价值是架构价值，一个价值是行为价值。</p><p>行为价值比较直观，就是程序员把需求文档转换为上线运行的代码，给用户创造价值，同时获取利润。</p><p>对于架构价值的理解可能比较抽象，提一些具体场景，正常来说第一个版本的系统通常都是没有经过什么设计，匆匆忙忙被构建起来。后面业务有了一定的发展，为了加快发布的速度，团队开始招聘新人，同时迫于业务压力，对代码质量提升和软件架构设计存在长期忽视。团队经常加班，拼命工作，团队中的个人不管投入多少个人时间，救了多少火，产出始终上不去。团队的时间大部分都消耗在对现有系统的修复上，新功能的实现投入时间并没有多少，陷入恶性循环。软件架构的价值之一就是要解决类似这个场景的问题，良好的软件架构设计能够避免系统陷入混乱，让软件容易被修改，新增需求或者变更需求，随之所需的软件变更可以简单而方便的实现。</p><h3 id="坚持软件架构的价值"><a href="#坚持软件架构的价值" class="headerlink" title="坚持软件架构的价值"></a>坚持软件架构的价值</h3><p>软件架构设计是一个重要但不紧急的事情。在业务迭代中，技术团队经常容易陷入不重要但紧急的需求旋涡中。对于技术 leader 来说，就是要坚持架构设计的价值，同时也要说服其他人相信架构设计的价值，这也是技术 leader 的价值之一， 只有这样才有可能在紧凑的业务迭代周期中预留部分架构设计和代码 review 时间，以尽量延长软件的生命时间，降低软件的变更成本，让技术团队能够更愉悦的工作。</p><p>参考</p><ol><li><a href="https://book.douban.com/subject/30333919/">https://book.douban.com/subject/30333919/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑思维</title>
    <link href="/2021/07/10/logic-note/"/>
    <url>/2021/07/10/logic-note/</url>
    
    <content type="html"><![CDATA[<p>一直认为能够有逻辑的交流，或者有逻辑的解决问题是一个优秀工程师的必备品质，所以在内部做了一次关于逻辑思维方面的分享，得到不少积极的反馈。</p><div class="row">    <embed src="./logic-note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
    <tags>
      
      <tag>效率工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash 快捷键</title>
    <link href="/2019/04/26/bash-hot-keys/"/>
    <url>/2019/04/26/bash-hot-keys/</url>
    
    <content type="html"><![CDATA[<h1 id="Bash-快捷键"><a href="#Bash-快捷键" class="headerlink" title="Bash 快捷键"></a>Bash 快捷键</h1><p><strong>标签</strong></p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 &#x2F; command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p><strong>操作</strong></p><ul><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>清除当前行：ctrl + u</li><li>删除到文本末尾：ctrl + k</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>前进后退：ctrl + f&#x2F;b (相当于左右方向键)</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li><li>交换光标处文本：ctrl + t</li><li>清屏1：command + r</li><li>清屏2：ctrl + l</li></ul><p><strong>分屏</strong></p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 command + [ 或 command + ]</li><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>效率工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS Ping 框架 - SimplePing 源码解读</title>
    <link href="/2018/03/21/reading-source-code-of-SimplePing/"/>
    <url>/2018/03/21/reading-source-code-of-SimplePing/</url>
    
    <content type="html"><![CDATA[<h1 id="SimplePing-解读"><a href="#SimplePing-解读" class="headerlink" title="SimplePing 解读"></a>SimplePing 解读</h1><p>ping 程序对于开发人员来说应该是不会陌生的, ping 通常用来探测主机到主机之间是否可以通信。如果可以 ping 通，意味着可以和该主机建立网络连接，就像这样的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">➜  ~<span class="hljs-built_in"> ping </span>www.qq.com<span class="hljs-built_in"></span><br><span class="hljs-built_in">PING </span>www.qq.com (182.254.34.74): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=0 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=22.996 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=36.688 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=25.390 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=25.516 ms<br></code></pre></td></tr></table></figure><p>如果不能 ping 通，那就意味着无法和该主机建立网络连接，就像下面这样的。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">➜  ~ ping www.google.com<br>PING www.google.com (<span class="hljs-number">66.220</span><span class="hljs-number">.147</span><span class="hljs-number">.47</span>): <span class="hljs-number">56</span> data bytes<br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">0</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">1</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">2</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">3</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Apple 的 <a href="https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html#//apple_ref/doc/uid/DTS10000716">SimplePing</a> 封装了 ping 的功能，它利用 resolve host，create socket(send &amp; recv data), 解析 ICMP 包验证 checksum 等实现了 ping 功能。并且支持 iPv4 和 iPv6。</p><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><p>ping 功能使用是 ICMP 协议（Internet Control Message Protocol），ICMP 协议定义了一组错误信息，当路由器或者主机无法成功处理一个IP 封包的时候，能够将错误信息回送给来源主机，ICMP 常见的错误如下。</p><ol><li>传输线路或者节点故障导致无法到达目的地主机</li><li>路由器封包重组失败</li><li>封包存活时间（Time To Live,TTL）变成 0 (防止封包在网络中永无止境得绕圈)</li><li>IP 首部的错误检查码发现错误</li></ol><h3 id="iOS-SimplePing-的使用"><a href="#iOS-SimplePing-的使用" class="headerlink" title="iOS SimplePing 的使用"></a>iOS SimplePing 的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1. 利用 HostName 创建 SimplePing</span><br>SimplePing *pinger = [[SimplePing alloc] initWithHostName:<span class="hljs-string">@&quot;www.apple.com&quot;</span>];<br><span class="hljs-keyword">self</span>.pinger = pinger;<br><span class="hljs-comment">// 2. 指定 IP 地址类型</span><br><span class="hljs-keyword">if</span> (isIpv4 &amp;&amp; !isIpv6) &#123;<br>    pinger.addressStyle = SimplePingAddressStyleICMPv4;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isIpv6 &amp;&amp; !isIpv4) &#123;<br>    pinger.addressStyle = SimplePingAddressStyleICMPv6;<br>&#125;<br><span class="hljs-comment">// 3. 设置 delegate,用于接收回调信息</span><br>pinger.delegate = <span class="hljs-keyword">self</span>;<br><span class="hljs-comment">// 4. 开始 ping</span><br>[pinger start];<br></code></pre></td></tr></table></figure><p>SimplePing 的使用还是非常简单的，</p><ol><li>利用 HostName 创建 SimplePing</li><li>指定 IP 地址类型</li><li>设置 delegate,用于接收回调信息</li><li>开始 ping</li></ol><p>delegate 的回调方法体现了 ping 的过程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 解析 HostName 拿到 ip 地址之后，发送封包</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didStartWithAddress:(<span class="hljs-built_in">NSData</span> *)address<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;pinging %@&quot;</span>, displayAddressForAddress(address));<br>    [<span class="hljs-keyword">self</span> sendPing];<br>&#125;<br><span class="hljs-comment">// ping 功能启动失败</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didFailWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;failed: %@&quot;</span>, shortErrorFromError(error));<br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><span class="hljs-comment">// ping 成功发送封包</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didSendPacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u sent&quot;</span>, sequenceNumber);<br>&#125;<br><span class="hljs-comment">// ping 发送封包失败</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didFailToSendPacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber error:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u send failed: %@&quot;</span>, sequenceNumber,shortErrorFromError(error));<br>&#125;<br><span class="hljs-comment">// ping 发送封包之后收到响应</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u received, size=%zu&quot;</span>, sequenceNumber, packet.length);<br>&#125;<br><span class="hljs-comment">// ping 接收响应封包发生异常</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(<span class="hljs-built_in">NSData</span> *)packet<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;unexpected packet, size=%zu&quot;</span>, packet.length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SimplePing-的流程"><a href="#SimplePing-的流程" class="headerlink" title="SimplePing 的流程"></a>SimplePing 的流程</h3><img src="/2018/03/21/reading-source-code-of-SimplePing/Untitled.webp" class="" title="image"><p>上图是 SimplePing 执行一次 ping IPv4 地址的流程图，<br>ping 的实现并不负责，一共有以下几个步骤</p><ol><li>解析传入的 HostName，获取第一个可用 IP 地址</li><li>创建传输&#x2F;接收数据的 socket</li><li>发送数据，封装一个 ICMP 包</li><li>解析目标 IP 传回的 ICMP 包</li></ol><h3 id="HostName-的解析"><a href="#HostName-的解析" class="headerlink" title="HostName 的解析"></a>HostName 的解析</h3><p>关于 HostName 的解析，SimplePing 采用 CFHost 这个异步 API 方案，通过CFHost解析主机名主要有以下几个步骤：</p><ol><li>通过调用 CFHostCreateWithName 创建一个 CFHostRef 对象。</li><li>调用 CFHostSetClient 并且提供一个上下文对象和回调函数，这个回调函数在解析结束的时候会被调用。</li><li>调用 CFHostScheduleWithRunLoop 用于在 RunLoop 中执行具体的解析操作。</li><li>调用 CFHostStartInfoResolution 来告诉解析器开始解析，把它的第二个参数设置为 kCFHostAddresses 表明你想要返回一个 IP 地址。</li><li>等待解析器调用你的回调函数，通过你的回调函数，调用 CFHostGetAddressing 函数来获取解析结果。这个函数返回 CFDataRef 对象的一个数组，其中的每一个都包含一个 POSIX 的 sockaddr 结构体。</li></ol><p>下面的这段代码执行的是 1 - 4  过程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)start &#123;<br>    Boolean             success;<br>    <span class="hljs-built_in">CFHostClientContext</span> context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-built_in">CFStreamError</span>       streamError;<br>    <br>    assert(<span class="hljs-keyword">self</span>.host == <span class="hljs-literal">NULL</span>);<br>    assert(<span class="hljs-keyword">self</span>.hostAddress == <span class="hljs-literal">nil</span>);<br><br>    <span class="hljs-keyword">self</span>.host = (<span class="hljs-built_in">CFHostRef</span>) <span class="hljs-built_in">CFAutorelease</span>( <span class="hljs-built_in">CFHostCreateWithName</span>(<span class="hljs-literal">NULL</span>, (__bridge <span class="hljs-built_in">CFStringRef</span>) <span class="hljs-keyword">self</span>.hostName) );<br>    assert(<span class="hljs-keyword">self</span>.host != <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-built_in">CFHostSetClient</span>(<span class="hljs-keyword">self</span>.host, HostResolveCallback, &amp;context);<br>    <br>    <span class="hljs-built_in">CFHostScheduleWithRunLoop</span>(<span class="hljs-keyword">self</span>.host, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode);<br>    <br>    success = <span class="hljs-built_in">CFHostStartInfoResolution</span>(<span class="hljs-keyword">self</span>.host, kCFHostAddresses, &amp;streamError);<br>    <span class="hljs-keyword">if</span> ( ! success ) &#123;<br>        [<span class="hljs-keyword">self</span> didFailWithHostStreamError:streamError];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在系统解析 HostName 成功之后会调用 HostResolveCallback 这个回调，这个回调的作用相当于重定向，将内容从 c 转成适当的 Objective-C 内容。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> HostResolveCallback(<span class="hljs-built_in">CFHostRef</span> theHost, <span class="hljs-built_in">CFHostInfoType</span> typeInfo, <span class="hljs-keyword">const</span> <span class="hljs-built_in">CFStreamError</span> *error, <span class="hljs-type">void</span> *info) &#123;<br>    <span class="hljs-comment">// This C routine is called by CFHost when the host resolution is complete. </span><br>    <span class="hljs-comment">// It just redirects the call to the appropriate Objective-C method.</span><br>    SimplePing *    obj;<br>    obj = (__bridge SimplePing *) info;<br>    assert([obj isKindOfClass:[SimplePing <span class="hljs-keyword">class</span>]]);<br>    <span class="hljs-comment">// 省略代码 ......</span><br>    <span class="hljs-keyword">if</span> ( (error != <span class="hljs-literal">NULL</span>) &amp;&amp; (error-&gt;domain != <span class="hljs-number">0</span>) ) &#123;<br>        [obj didFailWithHostStreamError:*error];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 在这个方法获取 HostName 对应的地址</span><br>        [obj hostResolutionDone];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 CFHostGetAddressing 函数来获取解析结果，这个函数返回一个数组，从这个数组中取得 HostName 对应的 IP。从服务端的角度来说，为了实现负载均衡，一个域名是可以对应多个 IP 的，但是从客户端的角度来说，一个域名就是对应一个 IP。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)hostResolutionDone &#123;<br>    Boolean     resolved;<br>    <span class="hljs-built_in">NSArray</span> *   addresses;<br>    <br>    <span class="hljs-comment">// Find the first appropriate address.</span><br>    <br>    addresses = (__bridge <span class="hljs-built_in">NSArray</span> *) <span class="hljs-built_in">CFHostGetAddressing</span>(<span class="hljs-keyword">self</span>.host, &amp;resolved);<br>    <span class="hljs-keyword">if</span> ( resolved &amp;&amp; (addresses != <span class="hljs-literal">nil</span>) ) &#123;<br>        resolved = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSData</span> * address <span class="hljs-keyword">in</span> addresses) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr * addrPtr;<br>            <br>            addrPtr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *) address.bytes;<br>            <span class="hljs-keyword">if</span> ( address.length &gt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr) ) &#123;<br>                <span class="hljs-keyword">switch</span> (addrPtr-&gt;sa_family) &#123;<br>                    <span class="hljs-keyword">case</span> AF_INET: &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.addressStyle != SimplePingAddressStyleICMPv6) &#123;<br>                            <span class="hljs-keyword">self</span>.hostAddress = address;<br>                            resolved = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> AF_INET6: &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.addressStyle != SimplePingAddressStyleICMPv4) &#123;<br>                            <span class="hljs-keyword">self</span>.hostAddress = address;<br>                            resolved = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolved) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// We&#x27;re done resolving, so shut that down.</span><br>    <br>    [<span class="hljs-keyword">self</span> stopHostResolution];<br>    <br>    <span class="hljs-comment">// If all is OK, start the send and receive infrastructure, otherwise stop.</span><br>    <br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>        [<span class="hljs-keyword">self</span> startWithHostAddress];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        [<span class="hljs-keyword">self</span> didFailWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:(<span class="hljs-built_in">NSString</span> *)kCFErrorDomainCFNetwork code:kCFHostErrorHostNotFound userInfo:<span class="hljs-literal">nil</span>]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Socket-操作"><a href="#Socket-操作" class="headerlink" title="Socket 操作"></a>Socket 操作</h3><p>HostName 解析成功拿到对应的 IP 之后，SimplePing 调用startWithHostAddress 创建 socket 。</p><ol><li>使用 CFSocketCreateWithNative 创建一个 CFSocket</li><li>使用 CFSocketCreateRunLoopSource 为 CFSocket 创建一个 CFRunLoopSourceRef，</li><li>使用 CFRunLoopAddSource 将 CFRunLoopSourceRef 添加到 RunLoop 的 kCFRunLoopDefaultMode 模式中。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)startWithHostAddress &#123;<br> <span class="hljs-comment">// 省略代码 ......</span><br>        <span class="hljs-built_in">CFSocketContext</span>         context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>        <span class="hljs-built_in">CFRunLoopSourceRef</span>      rls;<br>        <span class="hljs-type">id</span>&lt;SimplePingDelegate&gt;  strongDelegate;<br>        <br>        <span class="hljs-comment">// Wrap it in a CFSocket and schedule it on the runloop.</span><br>        <br>        <span class="hljs-keyword">self</span>.socket = (<span class="hljs-built_in">CFSocketRef</span>) <span class="hljs-built_in">CFAutorelease</span>( <span class="hljs-built_in">CFSocketCreateWithNative</span>(<span class="hljs-literal">NULL</span>, fd, kCFSocketReadCallBack, SocketReadCallback, &amp;context) );<br>        assert(<span class="hljs-keyword">self</span>.socket != <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-comment">// The socket will now take care of cleaning up our file descriptor.</span><br>        <br>        assert( <span class="hljs-built_in">CFSocketGetSocketFlags</span>(<span class="hljs-keyword">self</span>.socket) &amp; kCFSocketCloseOnInvalidate );<br>        fd = <span class="hljs-number">-1</span>;<br>        <br>        rls = <span class="hljs-built_in">CFSocketCreateRunLoopSource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">self</span>.socket, <span class="hljs-number">0</span>);<br>        assert(rls != <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), rls, kCFRunLoopDefaultMode);<br>    <br>        <span class="hljs-built_in">CFRelease</span>(rls)；<br> <span class="hljs-comment">// 省略代码 ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 CFSocketCreateWithNative 的官方文档描述中有提到，CFSocketCreateWithNative 在创建 socket 的时候是有一个复用机制的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">The <span class="hljs-built_in">new</span> CFSocket <span class="hljs-keyword">object</span>, <span class="hljs-keyword">or</span> `<span class="hljs-keyword">NULL</span>` <span class="hljs-keyword">if</span> an error occurred. <br><span class="hljs-keyword">If</span> a CFSocket <span class="hljs-keyword">object</span> already <span class="hljs-keyword">exists</span> <span class="hljs-keyword">for</span> `sock`, <br>the <span class="hljs-keyword">function</span> <span class="hljs-keyword">returns</span> the pre-existing <span class="hljs-keyword">object</span> <span class="hljs-keyword">instead</span> <span class="hljs-keyword">of</span> creating a <span class="hljs-built_in">new</span> <span class="hljs-keyword">object</span>; <br></code></pre></td></tr></table></figure><h3 id="封装-ICMP-包"><a href="#封装-ICMP-包" class="headerlink" title="封装 ICMP 包"></a>封装 ICMP 包</h3><p>在 socket 创建完成之后，接下来就要开始组装 IP 封包并发送了。组装 IP 封包并发送的过程需要我们手动在这个回调方法触发。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didStartWithAddress:(<span class="hljs-built_in">NSData</span> *)address<br>&#123;<br><span class="hljs-comment">// 调用 - (void)sendPingWithData:(NSData *)data </span><br>&#125;<br></code></pre></td></tr></table></figure><p>sendPingWithData 这个方法做的操作是组装 IP 封包然后发送封包，调用这个过程对应的回调方法。发送封包的过程是调用 sendto 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sendPingWithData:(<span class="hljs-built_in">NSData</span> *)data &#123;<br>    <span class="hljs-comment">// 省略代码 ......</span><br><br>    <span class="hljs-comment">// Send the packet.</span><br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.socket == <span class="hljs-literal">NULL</span>) &#123;<br>        bytesSent = <span class="hljs-number">-1</span>;<br>        err = EBADF;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bytesSent = sendto(<br>            <span class="hljs-built_in">CFSocketGetNative</span>(<span class="hljs-keyword">self</span>.socket),<br>            packet.bytes,<br>            packet.length, <br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-keyword">self</span>.hostAddress.bytes, <br>            (socklen_t) <span class="hljs-keyword">self</span>.hostAddress.length<br>        );<br>        err = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (bytesSent &lt; <span class="hljs-number">0</span>) &#123;<br>            err = errno;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 省略代码 ......</span><br></code></pre></td></tr></table></figure><p>组装 IP 封包是调用下面这个方法来完成，这个方法把数据按照 ICMPHeader 结构体的格式进行初始化并返回 IP 封包，关于 ICMPHeader 的结构这里就不再累赘，通过 ICMPHeader 结构体的定义就可以明白。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSData</span> *)pingPacketWithType:(uint8_t)type <br>                   payload:(<span class="hljs-built_in">NSData</span> *)payload <br>                  requiresChecksum:(<span class="hljs-type">BOOL</span>)requiresChecksum ；<br></code></pre></td></tr></table></figure><h3 id="解析-ICMP-包"><a href="#解析-ICMP-包" class="headerlink" title="解析 ICMP 包"></a>解析 ICMP 包</h3><p>完成了发送操作之后，接下来就是等待 ping 的响应了。当 socket 收到 ping 响应的时候回调 SocketReadCallback ，这个回调的作用相当于重定向，将内容从 c 转成适当的 Objective-C 内容，SocketReadCallback 里面调用了 readData 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> SocketReadCallback(<span class="hljs-built_in">CFSocketRef</span> s, <span class="hljs-built_in">CFSocketCallBackType</span> type, <span class="hljs-built_in">CFDataRef</span> address, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">void</span> *info) <br></code></pre></td></tr></table></figure><p>在  readData 方法里面做的工作就是读取响应数据，验证响应的数据正确性，执行相应的回调方法。与sendto对应，读取数据使用的是 recvfrom 方法。验证响应数据调用的是下面的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)validatePing4ResponsePacket:(<span class="hljs-built_in">NSMutableData</span> *)packet sequenceNumber:(uint16_t *)sequenceNumberPtr <br></code></pre></td></tr></table></figure><p>这个方法接收 ping 响应数据的时候，会对 ICMP 包进行校验，会跳过 IP 头，毕竟 IP 首部对于 ping 功能来说并不重要，重要的是 ICMP 协议的内容，其中主要验证的字段是 checksum 和 sequenceNumber（iPv6 只需要验证 sequenceNumber）。<br>停止 ping 的时候需要做一些清理工作，包括 socket 和 CFHost 对应的销毁。<br>到这里，整个 ping 的基本流程就结束了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ICMP 协议规定，目的主机必须返回 ICMP 回送应答消息给源主机，如果源主机在一定时间内收到应答，则认为主机可达，而 ping 功能使用的是 ICMP 协议。<br>SimplePing 实现 ping 操作的原理步骤是这样的，先解析出 HostName 对应的 IP 地址，这个才知道数据包要发送给哪个目的主机，接着构造符合 ICMP 协议格式的数据包并发送，等待目的主机响应。一段时间过后，目的主机响应数据到达源主机，源主机接收响应数据包，验证数据包，然后去掉数据包的 IP 首部，拿到 ICMP 数据。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/ResolvingDNSHostnames.html#//apple_ref/doc/uid/TP40012543-SW1">https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/ResolvingDNSHostnames.html#//apple_ref/doc/uid/TP40012543-SW1</a></li><li><a href="https://github.com/iOS-Developer-Documents-Chinese/iOS-Developer-Documents-Chinese/blob/master/Socket/DNS%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E8%A7%A3%E6%9E%90.md">https://github.com/iOS-Developer-Documents-Chinese/iOS-Developer-Documents-Chinese/blob/master/Socket/DNS%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E8%A7%A3%E6%9E%90.md</a></li><li><a href="https://www.cnblogs.com/cuihongyu3503319/archive/2012/07/09/2583129.html">https://www.cnblogs.com/cuihongyu3503319/archive/2012/07/09/2583129.html</a></li><li><a href="http://blog.163.com/qhj4433210@126/blog/static/165975282201592251248584/">http://blog.163.com/qhj4433210@126/blog/static/165975282201592251248584/</a></li><li><a href="http://blog.csdn.net/inject2006/article/details/2139149">http://blog.csdn.net/inject2006/article/details/2139149</a></li><li><a href="https://zhaoxinyu.me/2017-04-12-simple-ping/">https://zhaoxinyu.me/2017-04-12-simple-ping/</a></li><li><a href="https://en.wikipedia.org/wiki/IPv4_header_checksum">https://en.wikipedia.org/wiki/IPv4_header_checksum</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解存储器层次结构</title>
    <link href="/2017/10/01/operating-system-storage/"/>
    <url>/2017/10/01/operating-system-storage/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于一个简单的计算机系统模型，我们可以将存储器系统看做是一个线性的字节数组，而 CPU 能够在一个常数时间内访问每个存储器的位置。实际上，存储器系统（memory system）是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的小的、快速的高速缓存存储器（cache memory）做为一部分存储在相对慢速的主存储器（main memory）中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而磁盘常常作为存储在通过网络连接的其他机器的磁盘的缓存。</p><h3 id="Cache-基本模型"><a href="#Cache-基本模型" class="headerlink" title="Cache 基本模型"></a>Cache 基本模型</h3><img src="/2017/10/01/operating-system-storage/Untitled.webp" class="" title="image"><p>CPU 通过总线从主存取指令和数据，完成计算之后再将结果写回内存。这个模型的瓶颈在于 CPU 的超级快的运算速度和主存相对慢的多的运算速度无法匹配，导致大量的时间都浪费在内存上。既然内存比较慢那么就尽量减少 CPU 对内存的访问，于是在 CPU 和 主存之间增加一层 Cache，如下图所示。</p><img src="/2017/10/01/operating-system-storage/Untitled1.webp" class="" title="image"><p>在计算机中，Cache 就是访问速度快的计算机内存被用来保存频繁访问或者最近访问的指令和内存。通常 Cache 的造价比较高，所以相对 Memory 来说，容量比较小,保存的数据也有限。总而言之，由于 CPU 和内存之间的指令和数据访问存在瓶颈，所以增加了一层 Cache，用来尽力消除 CPU 和内存之间的瓶颈。这个模型如下图所示。</p><img src="/2017/10/01/operating-system-storage/Untitled2.webp" class="" title="image"><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>你可能会问为什么在CPU 和内存之间增加一层 Cache，就可以尽力消除 CPU 和内存之间的瓶颈呢？</p><img src="/2017/10/01/operating-system-storage/Untitled3.webp" class="" title="image"><p>如上图所示，是局部性原理（principle of locality）让 Cache 更好的工作。一个编写良好的计算机程序通常都具有良好的局部性（locality）,程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性被称作局部性原理。局部性通常有 2 种不同的形式：时间局部性（temporal locality）和空间局部性 (spatial locality)。在一个具有良好时间局部性的程序中，被引用过一次的内存地址很可能在不远的将来会再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来会引用附近的一个内存位置。</p><p>程序是如何利用这个局部性原理呢？</p><img src="/2017/10/01/operating-system-storage/Untitled4.webp" class="" title="image"><p>从数据方面来说，</p><ol><li>sum 变量在每次循环迭代的时候都会被访问，符合时间局部性。</li><li>采用步长为 1 的方式访问数组 a ，符合空间局部性。</li></ol><p>从指令方面来说，</p><ol><li>循环迭代，符合时间局部性</li><li>线性执行指令，符合空间局部性</li></ol><p>对于程序员来说，编写具有良好的局部性的程序是让程序运行更快的方法之一。</p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><img src="/2017/10/01/operating-system-storage/Untitled5.webp" class="" title="image"><p>上图展示了一个典型的存储器层次结构。一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高层是少量快速的<br> CPU 寄存器，CPU 可以再一个时钟周期内访问它们。接下来是一个或者多个小型到中型的基于 SRAM 的高速缓存存储器，可以再几个 CPU 时钟周期内访问它们。然后是一个大的基于 DRAM 的主存，可以在几十或者几百个时钟周期内访问它们。接下来是慢速但是容量很大的本地磁盘。最后有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们，例如网络文件系统（Network File System,NFS）这样的分布式文件系统，允许程序访问存储在远程的网络服务器上的文件。</p><p>存储器层次结构的核心是，对于每个 k , 位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。也就是说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出文件的缓存，以此类推知道 CPU 寄存器。</p><img src="/2017/10/01/operating-system-storage/Untitled6.webp" class="" title="image"><p>上图展示了存储器层次结构中缓存的一般性概念。第 k+1 层的存储器被划分成连续的数据对象组块（chunk）,称为块（block）。每个块都有一个唯一的名字或者地址以区别其他的块。例如第 k+1 层存储器被划分成 16 个大小固定的块，编号为 0 ~ 15。第 k 层的存储器被划分成较少的块的集合，每个块的大小与 k+1 层的块的大小一样。在任何时刻，第 k 层的缓存包含了第 k+1 层块的一个子集的副本。例如，第 k 层的缓存有 4 个块的控件，当前包含了 8，9，14，3 的副本。</p><p>数据总是以块大小为传输单元在第 k 层 和 第 k+1 层之间来回复制的，虽然在层次结构总任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。例如 L1 和 L2 之间的传送通常使用的是几十个个字大小的块，而 L5 和 L4 之间的传送用的是大小为几百或者几千字节的块。一般而言，层次结构中较低层（离 CPU 较远）的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p><img src="/2017/10/01/operating-system-storage/Untitled7.webp" class="" title="image"><p>当程序需要第 k+1 层的某个数据对象 d 时，它首先会在当前存储在第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层，那么就是缓存命中。该程序直接从第 k 层读取 d，根据存储器层次结构的性质，从 k 层读取数据显然比从 k+1 层读取数据更快。如上图所示，一个具有良好时间局部性的程序可以从块 14 中读出一个数据对象，得到一个对 k 层的缓存命中 。</p><img src="/2017/10/01/operating-system-storage/Untitled8.webp" class="" title="image"><p>如果第 k 层中没有缓存数据对象 d，那么就是我们所说的缓存不命中 （cache miss）。当发生缓存不命中时，第 k 层的缓存从第 k+1 层缓存中取出包含 d 的那个块，如果第 k 层的缓存已经满了，那么可能会覆盖现存的一个块。覆盖一个现存的一个块的过程称为替换或者驱逐。被替换的块有时也称作牺牲块。决定替换哪个块是由缓存的替换策略来控制的，替换策略有随机替换和最近最少被使用（LRU）替换策略。</p><h3 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h3><p>早期的计算机系统的存储器结构只有三层： CPU 寄存器， DRAM 主存，磁盘。由于 CPU 和主存之间逐渐增大的速度差距，系统设计者在 CPU 和 主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。随着 CPU 和主存之间逐渐增大的速度差距，系统设计者在 L1 和 主存之间插入了一个更大的 SRAM 高速缓存存储器，称为 L2 高速缓存。</p><img src="/2017/10/01/operating-system-storage/Untitled9.webp" class="" title="image"><p>假设一个计算机系统，其中每个存储器地址 m 位，形成 M &#x3D; 2^m 个不同的地址。如下图所示。一个机器的高速缓存被组织成一个有 S &#x3D; 2^s 个高速缓存组（cache set）的数组。每个组包含 E 个高速缓存行（cache line）,每个行由一个 B &#x3D; 2^b 字节的数据块组成，一个有效位（valid bit）指明这个行是否有效，t &#x3D; m -（s+b）个标记位（tab bit），他们唯一地标识存储在这个高速缓存行中的块。</p><img src="/2017/10/01/operating-system-storage/Untitled10.webp" class="" title="image"><p>根据每个组的高速缓存行数 E，高速缓存可以被分为不同的类，每个组只有一行（E &#x3D; 1）的高速缓存成为直接映射高速缓存。下面我们以直接映射高速缓存来讲解。</p><img src="/2017/10/01/operating-system-storage/Untitled11.webp" class="" title="image"><p>假设有这么一个系统，它有一个 CPU，一个寄存器文件，一个 L1 高速缓存和一个主存。当 CPU 执行一条读内存字 w 的指令，它向 L1 请求这个字，如果 L1 有 w 的副本，那么 L1 高速缓存命中，高速缓存取出 w，返回给 CPU。若是不命中，当 L1 向主存请求包含 w 的块的副本时，CPU 必须等待。当被请求的块从内存到达 L1 时，L1 将这个块存放在它的一个高速缓存行里面，然后取出 w,返回给 CPU 。高速缓存上面的工作过程分为 3 个步骤：</p><ol><li>组选择</li><li>行匹配</li><li>字抽取</li></ol><p>第一步，直接映射高速缓存的组选择。高速缓存从 w 中取出 s 个组索引位。例子中的组索引位 00001 定位到组 1。</p><img src="/2017/10/01/operating-system-storage/Untitled12.webp" class="" title="image"><p>第二步，直接映射高速缓存的行匹配。由于只有一个高速缓存行，而且有效位也设置了，所以这个行是有用的，从 w 中取出标记位 t ，与高速缓存行中的标记位相匹配，所以缓存命中。</p><img src="/2017/10/01/operating-system-storage/Untitled13.webp" class="" title="image"><p>第三步，直接映射高速缓存的字选择。一旦缓存命中，那么我们就知道 w 就在这个块中的某个位置。我们把块看成一个字节的数组，而字节偏移是到这个数组的索引。所以最后一步是确定所需要的字在块中的偏移位置。例子中的块偏移是 100，它说明了 w 的副本是从块中的字节 4 开始的（假设字长为 4 字节）。</p><p>第四步，直接映射高速缓存不命中的行替换。如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在一个高速缓存行中。对于直接映射高速缓存来说，每个组只要一个行，替换策略就是用新取出的行替换当前的行。</p><h3 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h3><p>确保代码高速缓存友好的基本方法有 2 种，</p><ol><li>让最常见的情况运行的快。</li><li>尽量减少每个循环内部的缓存不命中数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sumvec</span><span class="hljs-params">(<span class="hljs-type">int</span> v[n])</span><br>&#123;<br>  <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>  &#123;<br>      sum += v[i];<br>  &#125; <br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对于局部变量 i 和 sum，循环体有良好的时间局部性。对数组 v 的步长为 1 的引用，对 v[0] 的引用会不命中，而对应的 v[0] ~ v[3] 的块会被从内存加载到高速缓存中，因此接下来的三个引用都会命中，以此类推，四个引用中，三个会命中，这个是我们能做到的最好的情况了，具有良好的空间局部性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为一个程序员需要理解存储器的结构层次，因为它对应用程序的性能有巨大的影响。如果你的程序需要的数据是存储在 CPU 寄存器中的，那么在指令的执行期间，在 0 个周期内就可以访问到它们，如果在高速缓存中，需要 4 ~ 75 个周期。如果存储在主存中，需要上百个周期，如果存储在磁盘上，大约需要几千万个周期。如果理解了系统是如何将数据再存储器层次结构中上上下下移动的，那么就可以在编写自己的应用程序的时候使得他们的数据项存储在结构层次中较高的地方，以便 CPU 可以更快的访问到它们。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://courses.cs.washington.edu/courses/cse351/17wi/videos.html">The Hardware &#x2F; Software Interface</a> 课程笔记</li><li><a href="https://book.douban.com/subject/26912767/">https://book.douban.com/subject/26912767/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 网络监控框架 - Reachability 源码解读</title>
    <link href="/2017/09/23/reading-source-code-of-Reachability/"/>
    <url>/2017/09/23/reading-source-code-of-Reachability/</url>
    
    <content type="html"><![CDATA[<h1 id="Reachability-解读"><a href="#Reachability-解读" class="headerlink" title="Reachability 解读"></a>Reachability 解读</h1><p>Reachability 项目是 Apple 提供的一个官方 Demo， 用于演示如何使用 System Configuration framework 来监控 iOS 设备的网络状态。值得注意的是 Reachability 仅仅能检测到数据包是否可以离开本设备，而不能检测到数据包是否能达到目的地。也就是说不能把它当成 Ping 来使用。Reachability 使用起来也特别的简单，接下来我们来看看如何使用 Reachability。</p><h3 id="Reachability-使用"><a href="#Reachability-使用" class="headerlink" title="Reachability 使用"></a>Reachability 使用</h3><p>设置欲检测的域名，启动网络状态监控，Reachability 会在设备的网络状态发生变化的时候会发出一个名为 kReachabilityChangedNotification 的通知，我们可以通过接收这个通知，然后根据设备的网络状态做业务应对处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 接收 kReachabilityChangedNotification 通知</span><br>[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(reachabilityChanged:) name:kReachabilityChangedNotification object:<span class="hljs-literal">nil</span>];<br><br><span class="hljs-comment">// 检测某个域名是否可达</span><br><span class="hljs-keyword">self</span>.hostReachability = [Reachability reachabilityWithHostName:remoteHostName];<br><br><span class="hljs-comment">// 开始监控</span><br>[<span class="hljs-keyword">self</span>.hostReachability startNotifier];<br><br><span class="hljs-comment">// 收到 kReachabilityChangedNotification 通知</span><br>- (<span class="hljs-type">void</span>) reachabilityChanged:(<span class="hljs-built_in">NSNotification</span> *)note<br>&#123;<br>Reachability* curReach = [note object];<br><span class="hljs-built_in">NSParameterAssert</span>([curReach isKindOfClass:[Reachability <span class="hljs-keyword">class</span>]]);<br>      <span class="hljs-comment">// 做业务应对处理 </span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="Reachability-的组成"><a href="#Reachability-的组成" class="headerlink" title="Reachability 的组成"></a>Reachability 的组成</h3><p>Reachability 项目仅仅由一个 Reachability.h 和 Reachability.m 文件组成。麻雀虽小，五脏俱全。Reachability 也是这样的。Reachability 的接口提供了以下的能力：</p><ol><li>检测一个域名是否可达，使用  reachabilityWithHostName:  方法。</li><li>检测一个 IP 是否可达，使用 reachabilityWithAddress: 方法。</li><li>检测设备网络的可到达性，使用 reachabilityForInternetConnection 方法。</li><li>开始监控网络状况，使用 startNotifier 方法。</li><li>停止监控网络状况，使用 stopNotifier 方法。与 startNotifier 方法配合使用。</li><li>获取当前的网络连接方式，使用 currentReachabilityStatus 方法。</li><li>判断设备的网络是否是按需连接方式，使用 connectionRequired 方法。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Reachability</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Use to check the reachability of a given host name.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithHostName:(<span class="hljs-built_in">NSString</span> *)hostName;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Use to check the reachability of a given IP address.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithAddress:(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *)hostAddress;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Checks whether the default route is available. Should be used by applications that do not connect to a particular host.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityForInternetConnection;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Start listening for reachability notifications on the current run loop.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">BOOL</span>)startNotifier;<br>- (<span class="hljs-type">void</span>)stopNotifier;<br><br>- (NetworkStatus)currentReachabilityStatus;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * WWAN may be available, but not active until a connection has been established. WiFi may require a connection for VPN on Demand.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">BOOL</span>)connectionRequired;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="Reachability-的实现"><a href="#Reachability-的实现" class="headerlink" title="Reachability 的实现"></a>Reachability 的实现</h3><p>Reachability 的实现依赖于系统的 SCNetworkReachability 类，SCNetworkReachability 允许应用程序获取当前系统的网络配置情况，也可以用来判断一个 target host 的可达性。值得注意的是，当应用程序可以将一个 data packet 发送到 network stack,并且该 data packet 可以离开本地设备，这个时候 SCNetworkReachability 就会判断网络是可达的。正是由于这个原因，Reachability 不能保证 data packet 会被送到 target host 。SCNetworkReachability 的使用分为<strong>同步模式和异步模式</strong>。</p><h4 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h4><p>我们先从异步模式开始解读，这毕竟是比较常用的模式！</p><p>第一步<br>我们从  startNotifier 方法开始。把 SCNetworkReachabilityRef 放到当前 runloop 的 kCFRunLoopDefaultMode 模式，当网络连接状态发生变化，SCNetworkReachabilityRef 会执行通过 SCNetworkReachabilitySetCallback 方法设定好的 ReachabilityCallback 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)startNotifier<br>&#123;<br><span class="hljs-type">BOOL</span> returnValue = <span class="hljs-literal">NO</span>;<br><span class="hljs-built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilitySetCallback</span>(_reachabilityRef, ReachabilityCallback, &amp;context))<br>&#123;<br>        <span class="hljs-comment">//把 SCNetworkReachabilityRef 放到当前 runloop 的 kCFRunLoopDefaultMode 模式</span><br>        <span class="hljs-comment">//当 SCNetworkReachabilityRef 判断到网络状态发生变化，会执行 ReachabilityCallback 回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(_reachabilityRef, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode))<br>&#123;<br>returnValue = <span class="hljs-literal">YES</span>;<br>&#125;<br>&#125;<br>    <br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步<br>接下来看 ReachabilityCallback 回调方法，在这里主要是发送一个  名为 kReachabilityChangedNotification 通知，并将 Reachability 对象作为参数，将网络连接状态通知应用程序。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> ReachabilityCallback(<span class="hljs-built_in">SCNetworkReachabilityRef</span> target, <span class="hljs-built_in">SCNetworkReachabilityFlags</span> flags, <span class="hljs-type">void</span>* info)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unused (target, flags)</span><br><span class="hljs-built_in">NSCAssert</span>(info != <span class="hljs-literal">NULL</span>, <span class="hljs-string">@&quot;info was NULL in ReachabilityCallback&quot;</span>);<br><span class="hljs-built_in">NSCAssert</span>([(__bridge <span class="hljs-built_in">NSObject</span>*) info isKindOfClass: [Reachability <span class="hljs-keyword">class</span>]], <span class="hljs-string">@&quot;info was wrong class in ReachabilityCallback&quot;</span>);<br>    <span class="hljs-comment">// 发送 kReachabilityChangedNotification 通知，并将 Reachability 作为参数</span><br>    Reachability* noteObject = (__bridge Reachability *)info;<br>    <span class="hljs-comment">// Post a notification to notify the client that the network reachability changed.</span><br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName: kReachabilityChangedNotification object: noteObject];<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步<br>startNotifier 和 stopNotifier 方法是配合使用的。stopNotifier 的主要任务是对 startNotifier 做的操作进行逆向处理。把 SCNetworkReachabilityRef 从当前 runloop 的 kCFRunLoopDefaultMode 模式移除。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)stopNotifier<br>&#123;<br><span class="hljs-keyword">if</span> (_reachabilityRef != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(_reachabilityRef, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步<br>上面主要是主流程解读，解读 Reachability 开始网络监控，网络状态发生变化处理，到停止网络监控的流程。这过程 Reachability 都<br> 依赖于 SCNetworkReachabilityRef 的对象，接下来我们来说说 Reachability 怎么创建  SCNetworkReachabilityRef 对象。SCNetworkReachabilityRef 对象的创建依赖于 IP 或者域名。依赖于域名使用 SCNetworkReachabilityCreateWithName 方法，依赖于 IP 使用 SCNetworkReachabilityCreateWithAddress 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 通过域名创建 SCNetworkReachabilityRef 对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithHostName:(<span class="hljs-built_in">NSString</span> *)hostName<br>&#123;<br>Reachability* returnValue = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">SCNetworkReachabilityRef</span> reachability = <span class="hljs-built_in">SCNetworkReachabilityCreateWithName</span>(<span class="hljs-literal">NULL</span>, [hostName UTF8String]);<br><span class="hljs-keyword">if</span> (reachability != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue= [[<span class="hljs-keyword">self</span> alloc] init];<br><span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue-&gt;_reachabilityRef = reachability;<br>&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">CFRelease</span>(reachability);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br><br><span class="hljs-comment">// 通过 IP 创建 SCNetworkReachabilityRef 对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithAddress:(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *)hostAddress<br>&#123;<br><span class="hljs-built_in">SCNetworkReachabilityRef</span> reachability = <span class="hljs-built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, hostAddress);<br><br>Reachability* returnValue = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (reachability != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue = [[<span class="hljs-keyword">self</span> alloc] init];<br><span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue-&gt;_reachabilityRef = reachability;<br>&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">CFRelease</span>(reachability);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是异步模式的解读，Reachability 的异步模式顾名思义就是网络连接发生了变化，Reachability 发通知告知应用程序。而同步模式呢？ 那就是应用程序主动找 Reachability 获取当前的网络连接状态。</p><h4 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h4><p>应用程序主动找 Reachability 获取当前的网络连接状态，使用 currentReachabilityStatus 方法。Reachability 能够实现同步模式依赖于 SCNetworkReachabilityRef 的 SCNetworkReachabilityGetFlags 方法。SCNetworkReachabilityGetFlags 方法使用同步模式获取设备的网络连接状态。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (NetworkStatus)currentReachabilityStatus<br>&#123;<br><span class="hljs-built_in">NSAssert</span>(_reachabilityRef != <span class="hljs-literal">NULL</span>, <span class="hljs-string">@&quot;currentNetworkStatus called with NULL SCNetworkReachabilityRef&quot;</span>);<br>NetworkStatus returnValue = NotReachable;<br><span class="hljs-built_in">SCNetworkReachabilityFlags</span> flags;<br>        <span class="hljs-comment">// 同步模式获取网络连接状态</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilityGetFlags</span>(_reachabilityRef, &amp;flags))<br>&#123;<br>        returnValue = [<span class="hljs-keyword">self</span> networkStatusForFlags:flags];<br>&#125;<br>    <br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Reachability 可以用来检测网络状态变化和网络的可达性的一个框架。但是 Reachability 仅仅能检测到数据包是否可以离开本设备，而不能检测到数据包是否能达到目的地，也就是说不能把它当成 Ping 来使用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>Reachability 的代码和 Demo<br> <a href="https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html">https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html</a></li><li>SCNetworkReachability 参考<br><a href="https://developer.apple.com/documentation/systemconfiguration/scnetworkreachability-g7d">https://developer.apple.com/documentation/systemconfiguration/scnetworkreachability-g7d</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出虚拟内存机制</title>
    <link href="/2017/09/23/operating-system-memory/"/>
    <url>/2017/09/23/operating-system-memory/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>现代操作系统了提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供了一个非常大的，一致的和私有的地址空间。虚拟内存提供了以下的三个关键能力：</p><ol><li>它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</li><li>它为内阁进程提供了一致的地址空间,简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ol><span id="more"></span><h3 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h3><p>计算机的主存可以看做是一个由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址（Physical Address,PA）。第一个字节的地址为 0，接下来的地址为 1，以此类推。CPU 访问内存的最简单的方式是使用物理寻址（physical addressing）。</p><img src="/2017/09/23/operating-system-memory/Untitled.webp" class="" title="image"><p>该图例的上下文是一条加载指令，塔读取从物理地址 4 处开始的 4 字节字。CPU 在执行这条指令的时候，生成一个有效物理地址，通过内存总线，把这个物理地址传递给主存，主存取出从物理地址4处开始的 4 个字节字，然后将它返回给 CPU，CPU 将它存放在一个寄存器里。早期使用物理寻址的系统通常都比较简单，比如数字信号处理器，计算器等嵌入式设备。</p><img src="/2017/09/23/operating-system-memory/Untitled1.webp" class="" title="image"><p>现在处理器采用的是一个程序虚拟寻址（virtual addressing）的寻址方式，如上图所示。CPU 通过生成一个虚拟地址（virtual address,VA）来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做地址翻译（address translation），地址翻译需要 CPU 硬件和操作系统之间的配合。 CPU 芯片上叫做内存管理单元（Menory Management Unit, MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间（address space）是一个非负整数 <strong>地址</strong> 的有序合集：{0，1，2，… }</p><img src="/2017/09/23/operating-system-memory/Untitled2.webp" class="" title="image"><p>在一个带虚拟内存的系统中，CPU 从一个有 N&#x3D; 2 的 n 次方 个地址的地址空间中生成虚拟地址，这个地址空间就称为虚拟地址空间：<br>{0，1，2，3，…., N-1}。<br>一个系统还有一个地理地址空间，对应于系统中物理内存的 M 个字节： {0，1，2，3，…, M-1}。<br>一个地址空间的大小通常是由表示最大地址所需要的位数来描述的，比如，一个包含 N &#x3D; 2 的 n 次方 个地址的虚拟地址空间就叫做一个 n 位地址空间，现代操作系统通常支持 32 位或者 64 位虚拟地址空间。</p><h3 id="虚拟内存做为缓存的工具"><a href="#虚拟内存做为缓存的工具" class="headerlink" title="虚拟内存做为缓存的工具"></a>虚拟内存做为缓存的工具</h3><p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。主存作为虚拟内存的缓存。</p><p>虚拟内存（VM）系统将虚拟内存分割成称为虚拟页（Virtual Page,VP）的大小固定的块，每个虚拟页的大小为 P &#x3D; 2 的 p 次方 字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为 P 字节（物理页也称作页帧（page frame））。</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ol><li>未分配的，VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存空间。</li><li>缓存的，当前已缓存在物理内存中的已分配页。</li><li>未缓存的，未缓存在物理内存中的已分配页。</li></ol><img src="/2017/09/23/operating-system-memory/Untitled3.webp" class="" title="image"><p>上图展示了在一个有 8 个虚拟内存的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被分配了，但是当前并没有缓存在主存中。</p><h4 id="DRAM-缓存的组织结构"><a href="#DRAM-缓存的组织结构" class="headerlink" title="DRAM 缓存的组织结构"></a>DRAM 缓存的组织结构</h4><img src="/2017/09/23/operating-system-memory/Untitled4.webp" class="" title="image"><p>我们使用 SRAM 缓存来表示位于 CPU 和 主存之间的  L1, L2 和 L3 高速缓存，使用 DRAM 缓存来表示虚拟内存系统中的缓存，也就是主存。</p><p>在存储器层次结构中， DRAM 比 SRAM 慢个大约 10x 倍，磁盘比 DRAM 慢大约 10, 000x 倍。因此 DRAM 缓存的不命中比 SRAM 缓存中的不命中要昂贵的多，因为 DRAM 缓存不命中需要和磁盘传送数据，而 SRAM 缓存不命中是和 DRAM 传送数据。</p><p>归根到底， DRAM 缓存的组织结构是由巨大的不命中开销驱动的。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><img src="/2017/09/23/operating-system-memory/Untitled5.webp" class="" title="image"><p>VA 是通过什么方式转成 PA 呢 ？<br>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟也是否缓存在 DRAM 的某个地方。如果命中缓存，那么虚拟内存系统还必须确认这个虚拟页存在哪个物理页中。如果没有命中缓存，那么虚拟内存系统必须判断虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM，替换这个牺牲页。</p><p>这些功能由软硬件联合提供，包括操作系统软件，MMU 中的地址翻译硬件和一个存放在物理内存中叫页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。</p><img src="/2017/09/23/operating-system-memory/Untitled6.webp" class="" title="image"><p>上图展示了一个页表的基本结构，页表就是一个页表条目（Page Table Entry,PTE）的数组。虚拟地址空间中的每个页在页表中都有一个 PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 DRAM 中。如果有效位为 1，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页缓存了该虚拟页。如果有效位为 0，那么一个 null 地址表示这个虚拟页还未被分配，否则对应的这个地址就指向该虚拟页在磁盘上的起始位置。</p><p>上图所示中一共有 8 个虚拟页和 4 个物理页的页表，4 个虚拟页 VP1, VP2, VP4, VP7 当前被缓存在 DRAM 中，VP0 和 VP5 还未被分配，而剩下的 VP3 和 VP6 已经被分配了，但是当前未被缓存。</p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><img src="/2017/09/23/operating-system-memory/Untitled7.webp" class="" title="image"><p>当 CPU 想要读取 VP2 中的虚拟内存中的一个字时，地址翻译硬件将虚拟地址作为一个索引来定位到 PTE2, 并从主存中读取它。因为 PTE2 设置了有效位，所以 VP2 是缓存在主存中的，所以地址翻译硬件使用 PTE 中的物理内存地址构造出这个字的物理地址。</p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><img src="/2017/09/23/operating-system-memory/Untitled8.webp" class="" title="image"><p>在虚拟内存中，DRAM 缓存不命中称为缺页（page fault）。如上图所示，CPU 引用了 VP3 中的一个字， VP3 并未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE3, 从有效位判断出 VP3 未被缓存，并且触发了一个缺页异常。缺页异常会调用内核的缺页异常处理程序，该程序会选择一个牺牲页。如下图所示，在这个案例中就是存放在 PP3 中的 VP4。</p><img src="/2017/09/23/operating-system-memory/Untitled9.webp" class="" title="image"><p>此时如果 VP4 已经被修改了，那么内核程序会将它复制回磁盘。接下来，内核程序从磁盘赋值 VP3 到内存中的 PP3并更新 PTE3。随后返回用户进程。当异常处理程序返回时，它会重启执行导致缺页的指令，该指令会将导致缺页的虚拟地址重新发送到地址翻译硬件。如下图所示，现在 VP3 已经在主存中了，那么就是页命中了。</p><img src="/2017/09/23/operating-system-memory/Untitled10.webp" class="" title="image"><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>当我们了解了虚拟内存的运作机制之后，是不是觉得虚拟内存的效率会很低呢？因为页面没有命中的代价非常大。是不是担心虚拟内存会影响程序的性能呢？其实虚拟内存运作的非常好。它充分利用了局部性（ locality ）的原理。</p><img src="/2017/09/23/operating-system-memory/Untitled11.webp" class="" title="image"><p>在程序整个运作过程中，程序引用的不同页面的总数可能超出了物理内存的总大小，但是局部性原则可以保证在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合被称作工作集（working set）或者常驻集合（resident set）。在程序初始开销之后也就是将工作集页面调入主存，接下来对这个工作集的访问会产生命中，这样就不会产生额外的磁盘消耗。<br>如果程序有良好的时间局部性，那么虚拟内存将工作的非常好。如果程序没有良好的时间局部性也就是工作集的大小超出了主存的大小，那么程序将会进入一个称作 抖动（thrashing）的状态，这个时候页面将不断地换进换出，程序会出现性能问题。</p><h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><p>虚拟内存大大简化了内存管理，操作系统为每个进程提供了一个独立的虚拟地址空间。</p><img src="/2017/09/23/operating-system-memory/Untitled12.webp" class="" title="image"><p>在上图中，进程 1 的页表将 VP1 映射到 PP2, VP2 映射到 PP6。进程 2 的页表将 VP1 映射到 PP8, VP2 映射到 PP6。在这里可以看到多个虚拟页面可以映射到同一个共享的物理页面上。</p><p>按需页面调度和独立的虚拟地址空间的结合，让 虚拟内存简化了链接和加载，代码和数据共享，以及应用程序的内存分配。</p><ul><li>简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</li><li>简化加载。虚拟内存使得容易向内存中加载可执行文件和共享对象文件。将一组连续的虚拟页面映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供了一个 nmap 的系统调用，允许应用程序自己做内存映射。</li><li>简化共享。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般情况下，每个进程都有自己私有的代码、数据、堆栈。这些内容不与其他进程共享。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</li><li>简化内存分配。虚拟内存向用户进程提供一个简单的分配额外内存的机制。当一个用户程序要求额外的堆空间时候，操作系统分配 k 个适当的连续的虚拟内存页面，并且将他们映射到物理内存的中的 k 个任意页面，操作系统没有必要分配 k 个连续的物理内存页面。</li></ul><h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><p>虚拟内存大大简化了内存管理，操作系统提供独立的地址空间使得区分不同进程的私有内存变得容易，但是地址翻译机制可以使用一种自然的方式拓展到提供更好的访问控制。每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE ，通过在 PTE 上添加一些额外的控制位来控制对一个虚拟页面内容的访问。</p><img src="/2017/09/23/operating-system-memory/Untitled13.webp" class="" title="image"><p>在上图中，每个 PTE 添加了三个控制位， SUP 位表示进程是否必须运行在超级用也就是内核模式下才能访问该页，WRITE 位控制页面的写访问， EXRC 位控制页面的执行。如果有指令违反了这些控制条件，那么 CPU 会触发一个一般保护故障，将控制传递给内核中的异常处理程序。</p><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><img src="/2017/09/23/operating-system-memory/Untitled14.webp" class="" title="image"><p>上图中展示了页面命中的场景，CPU 硬件的执行步骤：</p><ol><li>处理器 生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存&#x2F;主存中请求这个 PTE 。</li><li>高速缓存&#x2F;主存向 MMU 返回 PTE。</li><li>MMU 构造物理地址，并把它传送给高速缓存&#x2F;主存。</li><li>高速缓存&#x2F;主存返回所请求的数据字给处理器。</li></ol><p>页面命中是全部由硬件来处理的，既然有页面命中，那么就有页面不命中的场景。</p><img src="/2017/09/23/operating-system-memory/Untitled15.webp" class="" title="image"><p>上图展示了页面不命中的场景， CPU 硬件的执行步骤：</p><ol><li>处理器 生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存&#x2F;主存中请求这个 PTE 。</li><li>高速缓存&#x2F;主存向 MMU 返回 PTE。</li><li>PTE 中的有效控制位为 0 ，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>缺页处理程序调入新的页面，并更新内存中的 PTE。</li><li>缺页处理程序返回原来的进程，再次执行导致缺页的指令， CPU 将引起缺页的虚拟地址重新发送给 MMU ，因为虚拟页面现在存在主存中，所以会命中，主存将请求字返回给处理器。</li></ol><p>地址翻译的过程执行起来太慢了？怎么解决呢？答案你应该也猜到了，就是添加缓存。在 MMU 中包含了一个 TLB （Translation Lookaside Buffer）缓存。</p><img src="/2017/09/23/operating-system-memory/Untitled16.webp" class="" title="image"><p>我们来看看 TLB 命中的场景，</p><ul><li>第 1 步 CPU 产生一个虚拟地址</li><li>第 2 和 3 步 MMU 从 TLB 中取出对应的 PTE 。</li><li>第 4 步 MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。</li><li>第 5 步 高速缓存&#x2F;主存将所请求的数据字返回 CPU。</li></ul><p>如下图所示，当 TLB 不命中的时候， 多了步骤 3 和 4 ，MMU 必须从 L1 缓存中取出对应的 PTE , 新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的 PTE 。</p><img src="/2017/09/23/operating-system-memory/Untitled17.webp" class="" title="image"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虚拟内存对于计算机系统来说是核心的，虚拟内存也是强大的，同时虚拟内存也是危险的。虚拟内存还包括多级页表，内存映射，动态内存分配，垃圾收集等等内容。限于篇幅，这里只是叙述了一些基本的概念，帮助程序员理解 虚拟内存 这个概念，对具体细节不做深究。若是有兴趣的话，可以参考 《深入理解计算机系统》书籍，了解更多关于计算机虚拟内存要点。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://courses.cs.washington.edu/courses/cse351/17wi/videos.html">The Hardware &#x2F; Software Interface</a> 课程笔记</li><li><a href="https://book.douban.com/subject/26912767/">https://book.douban.com/subject/26912767/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS AOP 框架 - Aspects 源码解读</title>
    <link href="/2017/05/07/reading-source-code-of-Aspects/"/>
    <url>/2017/05/07/reading-source-code-of-Aspects/</url>
    
    <content type="html"><![CDATA[<h1 id="Aspects-解读"><a href="#Aspects-解读" class="headerlink" title="Aspects 解读"></a>Aspects 解读</h1><p><a href="https://github.com/steipete/Aspects">Aspects</a> 是 iOS 上的一个轻量级 AOP 库。它利用 method swizzling 技术为已有的类或者实例方法添加额外的代码，它是著名框架 PSPDFKit （an iOS PDF framework that ships with apps like Dropbox or Evernote）的一部分。</p><h3 id="怎么使用-Aspects"><a href="#怎么使用-Aspects" class="headerlink" title="怎么使用 Aspects"></a>怎么使用 Aspects</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific class.</span><br>+ (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br><br><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br><br></code></pre></td></tr></table></figure><p>Aspects 提供了2个 AOP 方法，一个用于类，一个用于实例。在确定 hook 的 方法之后， Aspects 允许我们选择 hook 的时机是在方法执行之前，还是方法执行之后，甚至可以直接替换掉方法的实现。Aspects 的常见使用情景是 log 和 打点统计 等和业务无关的操作。比如 hook ViewController 的 viewWillLayoutSubviews 方法。</p><span id="more"></span><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[aspectsController aspect_hookSelector:<span class="hljs-keyword">@selector</span>(viewWillLayoutSubviews) withOptions:<span class="hljs-number">0</span> usingBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Controller is layouting!&quot;</span>);<br>        &#125; error:<span class="hljs-literal">NULL</span>];<br></code></pre></td></tr></table></figure><h3 id="Aspects-使用的技术"><a href="#Aspects-使用的技术" class="headerlink" title="Aspects 使用的技术"></a>Aspects 使用的技术</h3><p>在阅读 Aspects 源码之前需要一些 Runtime 的相应知识，可以参考我自己的一些博客。</p><ol><li><a href="http://www.jianshu.com/p/8295f2503594">Objective-C 之 objc_msgSend 简单实现</a></li><li><a href="http://www.jianshu.com/p/e0682171f0a2">Objective-C 方法签名和调用</a></li><li><a href="http://www.jianshu.com/p/6186320a79db">Objective-C 动态实现</a></li><li><a href="http://www.jianshu.com/p/bdf84c417e4f">Objective-C 消息转发</a></li><li><a href="http://www.jianshu.com/p/1d59d266b8be">Objective-C 方法混写</a></li></ol><h3 id="Aspects-的代码"><a href="#Aspects-的代码" class="headerlink" title="Aspects 的代码"></a>Aspects 的代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br></code></pre></td></tr></table></figure><p>接下来的源码解读，主要是分析 Aspects 的 实例方法的执行流程，以及 Aspects 的设计思路。至于 Aspects 的类方法的执行流程和思路也是大同小异，这里就不再累赘了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// @return A token which allows to later deregister the aspect.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                           withOptions:(AspectOptions)options<br>                            usingBlock:(<span class="hljs-type">id</span>)block<br>                                 error:(<span class="hljs-built_in">NSError</span> **)error &#123;<br>    <span class="hljs-keyword">return</span> aspect_add(<span class="hljs-keyword">self</span>, selector, options, block, error);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法返回一个 AspectToken 对象，这个对象主要是 aspect 的唯一标识符。 该方法调用了 static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) 方法，这个方法用于给一个实例添加 aspect 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">id</span> aspect_add(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL selector, AspectOptions options, <span class="hljs-type">id</span> block, <span class="hljs-built_in">NSError</span> **error) &#123;<br><br>   <span class="hljs-comment">// ...... 省略代码    </span><br>    __block AspectIdentifier *identifier = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 给 block 加锁</span><br>    aspect_performLocked(^&#123;<br>        <span class="hljs-comment">// 判断 selector 是否可以被 hook</span><br>        <span class="hljs-keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="hljs-keyword">self</span>, selector, options, error)) &#123;<br>            <span class="hljs-comment">// 创建一个 AspectsContainer 对象,用 selector 关联到实例对象</span><br>            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="hljs-keyword">self</span>, selector);<br>            <span class="hljs-comment">// 创建一个 AspectIdentifier 对象，</span><br>            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="hljs-keyword">self</span> options:options block:block error:error];<br>            <span class="hljs-keyword">if</span> (identifier) &#123;<br>                <span class="hljs-comment">// 把 AspectIdentifier 对象加入 AspectsContainer 对象中</span><br>                [aspectContainer addAspect:identifier withOptions:options];<br>                <br>                <span class="hljs-comment">// Modify the class to allow message interception.</span><br>                aspect_prepareClassAndHookSelector(<span class="hljs-keyword">self</span>, selector, error);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> identifier;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>给 block 加锁 </li><li>判断 selector 是否符合 hook 的规则</li><li>创建一个 AspectsContainer 对象,用 selector 关联到实例对象。用于管理一个对象或者类的一个方法的所有 aspects </li><li>创建一个 AspectIdentifier 对象，并放入 AspectsContainer 对象管理。AspectIdentifier 对象 表示一个 aspect 的内容</li></ol><p>细看 aspect_isSelectorAllowedAndTrack 方法的内容，看如何判断一个 selector 是否符合 hook 规则</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 判断 selector 是否能被 hook</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, AspectOptions options, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-comment">// 不能被 hook 的方法集合</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSSet</span> *disallowedSelectorList;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> pred;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;pred, ^&#123;<br>        <span class="hljs-comment">// 这些方法不能被 hook</span><br>        disallowedSelectorList = [<span class="hljs-built_in">NSSet</span> setWithObjects:<span class="hljs-string">@&quot;retain&quot;</span>, <span class="hljs-string">@&quot;release&quot;</span>, <span class="hljs-string">@&quot;autorelease&quot;</span>, <span class="hljs-string">@&quot;forwardInvocation:&quot;</span>, <span class="hljs-literal">nil</span>];<br>    &#125;);<br>    <br>    <span class="hljs-comment">// Check against the blacklist.</span><br>    <span class="hljs-comment">// ...... 省略代码</span><br>    <br>    <span class="hljs-comment">// Additional checks.</span><br>    AspectOptions position = options&amp;AspectPositionFilter;<br>    <span class="hljs-comment">// dealloc 方法不允许在执行之后被 hook，因为对象会被销毁</span><br>    <span class="hljs-keyword">if</span> ([selectorName isEqualToString:<span class="hljs-string">@&quot;dealloc&quot;</span>] &amp;&amp; position != AspectPositionBefore) &#123;<br>       <span class="hljs-comment">// ...... 省略代码</span><br>    &#125;<br>    <span class="hljs-comment">// 被 hook 的方法不存在于类中</span><br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="hljs-keyword">self</span>.class instancesRespondToSelector:selector]) &#123;<br>       <span class="hljs-comment">// ...... 省略代码</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// Search for the current class and the class hierarchy IF we are modifying a class object</span><br>    <span class="hljs-keyword">if</span> (class_isMetaClass(object_getClass(<span class="hljs-keyword">self</span>))) &#123;<br>        Class klass = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>        <span class="hljs-built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();<br>        Class currentClass = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>        <br>        AspectTracker *tracker = swizzledClassesDict[currentClass];<br>        <span class="hljs-comment">// 判断子类是否已经 hook 该方法</span><br>        <span class="hljs-keyword">if</span> ([tracker subclassHasHookedSelectorName:selectorName]) &#123;<br>            <span class="hljs-comment">// ...... 省略代码</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 判断是否已经 hook 了该方法</span><br>            tracker = swizzledClassesDict[currentClass];<br>            <span class="hljs-keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;<br>                <span class="hljs-keyword">if</span> (klass == currentClass) &#123;<br>                    <span class="hljs-comment">// Already modified and topmost!</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>                &#125;<br>                <span class="hljs-built_in">NSString</span> *errorDescription = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, <span class="hljs-built_in">NSStringFromClass</span>(currentClass)];<br>                AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));<br>        <br>        <span class="hljs-comment">// ...... 省略代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>selector 不允许被 hook 的判断规则</p><ol><li>@”retain”, @”release”, @”autorelease”, @”forwardInvocation:” 这些方法是不允许被 hook 的</li><li>dealloc 方法不允许在执行之后被 hook</li><li>被 hook 的方法不存在于类中</li><li>一个方法只能被 hook 一次</li></ol><p>接下来看看 static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) 方法实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> aspect_prepareClassAndHookSelector(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(selector);<br>    Class klass = aspect_hookClass(<span class="hljs-keyword">self</span>, error);<span class="hljs-comment">// 1  swizzling forwardInvocation</span><br>    <span class="hljs-comment">// 被 hook 的 selector</span><br>    Method targetMethod = class_getInstanceMethod(klass, selector);<br>    IMP targetMethodIMP = method_getImplementation(targetMethod);<br>    <span class="hljs-keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;<span class="hljs-comment">//2  swizzling method</span><br>        <span class="hljs-comment">// 使用一个 aliasSelector 来指向原来 selector 的方法实现</span><br>        <span class="hljs-comment">// Make a method alias for the existing method implementation, it not already copied.</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);<br>        SEL aliasSelector = aspect_aliasForSelector(selector);<br>        <span class="hljs-keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;<br>            __unused <span class="hljs-type">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);<br>            <span class="hljs-built_in">NSCAssert</span>(addedAlias, <span class="hljs-string">@&quot;Original implementation for %@ is already copied to %@ on %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(selector), <span class="hljs-built_in">NSStringFromSelector</span>(aliasSelector), klass);<br>        &#125;<br>        <br>        <span class="hljs-comment">// We use forwardInvocation to hook in.</span><br>        <span class="hljs-comment">// 把 selector 指向 _objc_msgForward 函数</span><br>        <span class="hljs-comment">// 用 _objc_msgForward 函数指针代替 selector 的 imp,然后执行这个 imp</span><br>        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="hljs-keyword">self</span>, selector), typeEncoding);<br>        AspectLog(<span class="hljs-string">@&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, klass, <span class="hljs-built_in">NSStringFromSelector</span>(selector));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>swizzling forwardInvocation。</li><li>拿到原始 selector 的 方法实现，再生成一个 aliasSelector 来指向原来 selector 的方法实现</li><li>把 selector 指向 _objc_msgForward 函数，用 _objc_msgForward 函数指针代替 selector 的 IMP ，这样执行 selector 的时候就会执行 _objc_msgForward 函数。</li></ol><p>接下来看看 static Class aspect_hookClass(NSObject *self, NSError **error) 的实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-keyword">static</span> Class aspect_hookClass(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(<span class="hljs-keyword">self</span>);<br>    Class statedClass = <span class="hljs-keyword">self</span>.class;<br>    Class baseClass = object_getClass(<span class="hljs-keyword">self</span>);<br>    <span class="hljs-built_in">NSString</span> *className = <span class="hljs-built_in">NSStringFromClass</span>(baseClass);<br>    <span class="hljs-comment">// 是否有 _Aspects_ 后缀</span><br>    <span class="hljs-comment">// Already subclassed</span><br>    <span class="hljs-keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;<br>        <span class="hljs-keyword">return</span> baseClass;<br>        <span class="hljs-comment">// We swizzle a class object, not a single object.</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_isMetaClass(baseClass)) &#123;<br>        <span class="hljs-keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="hljs-keyword">self</span>);<br>        <span class="hljs-comment">// Probably a KVO&#x27;ed class. Swizzle in place. Also swizzle meta classes in place.</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statedClass != baseClass) &#123;<br>        <span class="hljs-keyword">return</span> aspect_swizzleClassInPlace(baseClass);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的 forwardInvocation 方法</span><br>    <span class="hljs-comment">// Default case. Create dynamic subclass.</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;<br>    Class subclass = objc_getClass(subclassName);<br>    <br>    <span class="hljs-keyword">if</span> (subclass == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-comment">// 生成 baseClass 对象的子类</span><br>        subclass = objc_allocateClassPair(baseClass, subclassName, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (subclass == <span class="hljs-literal">nil</span>) &#123;<br>            <span class="hljs-built_in">NSString</span> *errrorDesc = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;objc_allocateClassPair failed to allocate class %s.&quot;</span>, subclassName];<br>            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换子类的 forwardInvocation 方法</span><br>        aspect_swizzleForwardInvocation(subclass);<br>        <span class="hljs-comment">// 修改了 subclass 以及其 subclass metaclass 的 class 方法,使他返回当前对象的 class。</span><br>        aspect_hookedGetClass(subclass, statedClass);<br>        aspect_hookedGetClass(object_getClass(subclass), statedClass);<br>        objc_registerClassPair(subclass);<br>    &#125;<br>    <span class="hljs-comment">// 将当前对象 isa 指针指向了 subclass</span><br>    <span class="hljs-comment">// 将当前 self 设置为子类，这里其实只是更改了 self 的 isa 指针而已</span><br>    object_setClass(<span class="hljs-keyword">self</span>, subclass);<br>    <span class="hljs-keyword">return</span> subclass;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法的作用是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的 forwardInvocation 方法，这样做的好处是不需要去更改对象本身的实例。该方法调用了static void aspect_swizzleForwardInvocation(Class klass) 方法对子类的 forwardInvocation: 方法进行混写;</p><p>接下来看看 static void aspect_swizzleForwardInvocation(Class klass) 的方法实现，看它如何实现对 forwardInvocation: 方法的混写</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//swizzling forwardinvation 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> AspectsForwardInvocationSelectorName = <span class="hljs-string">@&quot;__aspects_forwardInvocation:&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(klass);<br>    <span class="hljs-comment">// If there is no method, replace will act like class_addMethod.</span><br>    <span class="hljs-comment">// 使用 __ASPECTS_ARE_BEING_CALLED__ 替换子类的 forwardInvocation 方法实现</span><br>    <span class="hljs-comment">// 由于子类本身并没有实现 forwardInvocation ，</span><br>    <span class="hljs-comment">// 所以返回的 originalImplementation 将为空值，所以子类也不会生成 AspectsForwardInvocationSelectorName 这个方法</span><br>    IMP originalImplementation = class_replaceMethod(klass, <span class="hljs-keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    <span class="hljs-keyword">if</span> (originalImplementation) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class_addMethod&quot;</span>);<br>        class_addMethod(klass, <span class="hljs-built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    &#125;<br>    AspectLog(<span class="hljs-string">@&quot;Aspects: %@ is now aspect aware.&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(klass));<br>&#125;<br></code></pre></td></tr></table></figure><p>关键实现在在这句代码,将 forwardInvocation: 的实现换成 __ASPECTS_ARE_BEING_CALLED__实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">IMP originalImplementation = class_replaceMethod(klass, <span class="hljs-keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="hljs-string">&quot;v@:@&quot;</span>);<br></code></pre></td></tr></table></figure><p>到这里我们可以知道了，知道 hook 了一个方法，那么最后都会执行 <strong>ASPECTS_ARE_BEING_CALLED</strong> 这个方法，代码执行到这里基本就到末尾了。我们看看这个方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// This is the swizzled forwardInvocation: method.</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="hljs-keyword">unsafe_unretained</span> <span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, <span class="hljs-built_in">NSInvocation</span> *invocation) &#123;<br>    <span class="hljs-comment">// ... 省略代码</span><br><br>    <span class="hljs-comment">// Before hooks. 在切面之前执行</span><br>    aspect_invoke(classContainer.beforeAspects, info);<br>    aspect_invoke(objectContainer.beforeAspects, info);<br>    <br>    <span class="hljs-comment">// Instead hooks. 替换切面</span><br>    <span class="hljs-type">BOOL</span> respondsToAlias = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;<br>        aspect_invoke(classContainer.insteadAspects, info);<br>        aspect_invoke(objectContainer.insteadAspects, info);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 重新转回原来的 selector 所指向的函数</span><br>        Class klass = object_getClass(invocation.target);<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;<br>                [invocation invoke];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));<br>    &#125;<br>    <br>    <span class="hljs-comment">// After hooks. 在切面之后执行</span><br>    aspect_invoke(classContainer.afterAspects, info);<br>    aspect_invoke(objectContainer.afterAspects, info);<br>    <br>    <span class="hljs-comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span><br>    <span class="hljs-comment">// 找不到 aliasSelector 的方法实现，也就是没有找到被 hook 的 selector 的原始方法实现，那么进行消息转发</span><br>    <span class="hljs-keyword">if</span> (!respondsToAlias) &#123;<br>        invocation.selector = originalSelector;<br>        SEL originalForwardInvocationSEL = <span class="hljs-built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;<br>            ((<span class="hljs-type">void</span>( *)(<span class="hljs-type">id</span>, SEL, <span class="hljs-built_in">NSInvocation</span> *))objc_msgSend)(<span class="hljs-keyword">self</span>, originalForwardInvocationSEL, invocation);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:invocation.selector];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Remove any hooks that are queued for deregistration.</span><br>    [aspectsToRemove makeObjectsPerformSelector:<span class="hljs-keyword">@selector</span>(remove)];<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>根据切面的时机点，执行相应的代码</li><li>执行完额外的代码之后，看下是否需要回到原来的代码上，若是需要则执行原来的代码</li><li>若是没有找到被 hook 的 selector 的原始方法实现，那么进行消息转发</li><li>Aspects 做对应的清理工作</li></ol><h3 id="Aspects-的思路"><a href="#Aspects-的思路" class="headerlink" title="Aspects 的思路"></a>Aspects 的思路</h3><ol><li><p>找到被 hook 的 originalSelector 的 方法实现</p></li><li><p>新建一个 aliasSelector 指向原来的 originalSelector 的方法实现</p></li><li><p>动态创建一个 originalSelector 所在实例的子类，然后 hook 子类的 forwardInvocation: 方法并将方法的实现替换成 <strong>ASPECTS_ARE_BEING_CALLED</strong> 方法</p></li><li><p>originalSelector 指向 _objc_msgForward 方法实现</p></li><li><p>实例的 originalSelector 的方法执行的时候，实际上是指向 <em>objc_msgForward ，而 <em>objc_msgForward 的方法实现被替换成  <strong>ASPECTS_ARE_BEING_CALLED</strong> 的方法实现，也就是说 originalSelector 的方法执行之后，实际上执行的是__ASPECTS_ARE_BEING_CALLED</em></em> 的方法实现。而 aliasSelector 的作用就是用来保存 originalSelector 的方法实现，当 hook 代码执行完成之后，可以回到 originalSelector 的原始方法实现上继续执行。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/steipete/Aspects">https://github.com/steipete/Aspects</a></li><li><a href="https://wereadteam.github.io/2016/06/30/Aspects/">https://wereadteam.github.io/2016/06/30/Aspects/</a></li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></li><li><a href="http://www.jianshu.com/p/8295f2503594">Objective-C 之 objc_msgSend 简单实现</a></li><li><a href="http://www.jianshu.com/p/e0682171f0a2">Objective-C 方法签名和调用</a></li><li><a href="http://www.jianshu.com/p/6186320a79db">Objective-C 动态实现</a></li><li><a href="http://www.jianshu.com/p/bdf84c417e4f">Objective-C 消息转发</a></li><li><a href="http://www.jianshu.com/p/1d59d266b8be">Objective-C 方法混写</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C Swizzling 原理</title>
    <link href="/2017/04/23/oc-swizzle/"/>
    <url>/2017/04/23/oc-swizzle/</url>
    
    <content type="html"><![CDATA[<h3 id="方法混写"><a href="#方法混写" class="headerlink" title="方法混写"></a>方法混写</h3><p>在 Objctive-C 中，混写（Swizzling）指的是偷梁换柱，将一个东西透明的换成另外一个东西，在 Runtime 运行时替换方法实现。<br>这个技术有什么作用呢？我们利用混写技术可以改变那些没有源代码的对象的行为，这其中包括了一些系统对象的行为，也包括了一些第三方 SDK 。</p><h3 id="给-NSNotificationCenter-添加日志"><a href="#给-NSNotificationCenter-添加日志" class="headerlink" title="给 NSNotificationCenter 添加日志"></a>给 NSNotificationCenter 添加日志</h3><p>接下来展示一个案例，每次在给 NSNotificationCenter 添加观察者的时候就打印日志。</p><span id="more"></span><h3 id="创建-NSObject-MethodSwizzle"><a href="#创建-NSObject-MethodSwizzle" class="headerlink" title="创建 NSObject+MethodSwizzle"></a>创建 NSObject+MethodSwizzle</h3><p>创建一个 NSObject 的 Category，叫做 NSObject+MethodSwizzle  用于实现方法混写。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// NSObject+MethodSwizzle.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">// 为 NSObject 添加方法混写实现</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br>+ (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">// NSObject+MethodSwizzle.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+MethodSwizzle.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><br><span class="hljs-comment">// 把 origSelector 的当前实现替换为新的实现</span><br>+(IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP&#123;<br>    <span class="hljs-comment">// 当前 class</span><br>    Class <span class="hljs-keyword">class</span> = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>    <span class="hljs-comment">// 获取 origSelector 的 Method</span><br>    Method origMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, origSelector);<br>    <span class="hljs-comment">// 获取 origSelector 的实现</span><br>    IMP origIMP = method_getImplementation(origMethod);<br><br>    <span class="hljs-comment">// 若是 class_addMethod 给 class 成功添加了方法，那么返回 YES，否则返回 NO。</span><br>    <span class="hljs-comment">// class_addMethod 会覆盖父类的方法实现，若是覆写方法会返回 YES。</span><br>    <span class="hljs-comment">// class_addMethod 返回 NO，那么我们可以知道这个类是直接实现了 origSelector 对应的方法</span><br>    <span class="hljs-type">BOOL</span> isAdd = class_addMethod(<span class="hljs-keyword">class</span>, origSelector, newIMP, method_getTypeEncoding(origMethod));<br>    <span class="hljs-keyword">if</span> (!isAdd) &#123;<br>        <span class="hljs-comment">// 替换 origMethod 方法的实现</span><br>        method_setImplementation(origMethod, newIMP);<br>    &#125;<br>    <span class="hljs-comment">// 返回 origSelector 对应的方法的实现</span><br>    <span class="hljs-keyword">return</span> origIMP;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>NSObject+MethodSwizzle 的 + (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP;<br>方法用于把类中的 origSelector 这个 Selector 对应的方法实现替换为 newIMP 这个方法实现。<br>在做方法混写的时候我们需要考虑三个情况：</p><ol><li>该类直接实现了这个方法</li><li>该类的类层次结构中的某个父类实现了这个方法</li><li>该类压根没有实现这个方法<br>我们使用了 class_addMethod 来处理以上三种情况。</li></ol><h3 id="创建-NSNotificationCenter-MethodSwizzle"><a href="#创建-NSNotificationCenter-MethodSwizzle" class="headerlink" title="创建 NSNotificationCenter+MethodSwizzle"></a>创建 NSNotificationCenter+MethodSwizzle</h3><p>创建 NSNotificationCenter 的 Category,叫做 NSNotificationCenter+MethodSwizzle 用于给 NSNotificationCenter 添加混写方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// NSNotificationCenter+MethodSwizzle.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSNotificationCenter</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><span class="hljs-comment">// 给自己添加方法混写</span><br>+ (<span class="hljs-type">void</span>)swizzleAddObserver;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// NSNotificationCenter+MethodSwizzle.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSNotificationCenter+MethodSwizzle.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+MethodSwizzle.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSNotificationCenter</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (*voidIMP)(<span class="hljs-type">id</span>,SEL,...);<br><span class="hljs-keyword">static</span> voidIMP sOrigAddObserver = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 用于替换 NSNotificationCenter 的 addObserver:selector:name:object: 的默认实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> MyAddObserver(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>,SEL _cmd,<span class="hljs-type">id</span> observer,SEL selector,<span class="hljs-built_in">NSString</span> *name,<span class="hljs-type">id</span> object)&#123;<br>    <span class="hljs-comment">// 打印日志</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;添加观察者：%@&quot;</span>,observer);<br>    <span class="hljs-built_in">NSAssert</span>(sOrigAddObserver, <span class="hljs-string">@&quot;旧方法找不到&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sOrigAddObserver)&#123;<br>        <span class="hljs-comment">// 调用原来的方法实现</span><br>        sOrigAddObserver(<span class="hljs-keyword">self</span>,_cmd,observer,selector,name,object);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法混写实现</span><br>+ (<span class="hljs-type">void</span>)swizzleAddObserver&#123;<br>    <span class="hljs-comment">//  swizzleAddObserver 只能被调用一次，可以采用更好的方法来实现这个需求</span><br>    <span class="hljs-built_in">NSAssert</span>(!sOrigAddObserver, <span class="hljs-string">@&quot;swizzleAddObserver 只能调用一次&quot;</span>);<br>    <span class="hljs-comment">// 准备混写的方法</span><br>    SEL sel = <span class="hljs-keyword">@selector</span>(addObserver:selector:name:object:);<br>    <span class="hljs-comment">// 替换方法新实现，并拿到旧方法实现</span><br>    sOrigAddObserver = (<span class="hljs-type">void</span> *)[<span class="hljs-keyword">self</span> swizzleSelector:sel withIMP:(IMP)MyAddObserver];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>NSNotificationCenter+MethodSwizzle 的swizzleAddObserver会将 addObserver:selector:name:object: 的系统默认实现替换为自己的实现 MyAddObserver，<br>MyAddObserver 在每次 NSNotificationCenter 添加观察者时会打印一个日志，然后再调用 addObserver:selector:name:object: 的系统默认实现。</p><h2 id="在-ViewController-中使用"><a href="#在-ViewController-中使用" class="headerlink" title="在 ViewController 中使用"></a>在 ViewController 中使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 加载方法混写</span><br>    [<span class="hljs-built_in">NSNotificationCenter</span> swizzleAddObserver];<br>    <span class="hljs-comment">// 给 NSNotificationCenter 添加一个观察者</span><br>    Observer *observer = [[Observer alloc] init];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:observer<br>                                             selector:<span class="hljs-keyword">@selector</span>(somthingHappened:)<br>                                                 name:<span class="hljs-string">@&quot;SomethingHappenedNotification&quot;</span><br>                                               object:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">添加观察者：&lt;Observer: <span class="hljs-number">0x60800001b660</span>&gt;<br></code></pre></td></tr></table></figure><p>在执行 NSNotificationCenter 添加观察者的代码的同时，控制台输出了我们预埋的日志，<br>可以看出 NSNotificationCenter 的 addObserver:selector:name:object: 方法实现已经被我们替换为自己的方法实现了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法混写是一个非常强大的技术，但是用不好也会引发一些莫名其妙的 bug 。<br>通常方法混写技术最好不要用于线上代码，但在开发过程中对于调试，性能调优和研究系统框架实现又是有非常大的作用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li>demo 地址 <a href="https://github.com/junbinchencn/Swizzle">https://github.com/junbinchencn/Swizzle</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 视频剪切、旋转，视频添加音频、添加水印，视频导出</title>
    <link href="/2017/04/16/video-editor-ios/"/>
    <url>/2017/04/16/video-editor-ios/</url>
    
    <content type="html"><![CDATA[<h1 id="AVSimpleEditoriOS-解读"><a href="#AVSimpleEditoriOS-解读" class="headerlink" title="AVSimpleEditoriOS 解读"></a>AVSimpleEditoriOS 解读</h1><p>视频处理主要是用到以下这几个类<br><strong>AVMutableComposition</strong>、<strong>AVMutableVideoComposition</strong>、<strong>AVMutableAudioMix</strong>、<strong>AVMutableVideoCompositionInstruction</strong>、<strong>AVMutableVideoCompositionLayerInstruction</strong>、<strong>AVAssetExportSession</strong> 等。其中 AVMutableComposition 可以用来操作音频和视频的组合，AVMutableVideoComposition 可以用来对视频进行操作，AVMutableAudioMix 类是给视频添加音频的，AVMutableVideoCompositionInstruction和AVMutableVideoCompositionLayerInstruction 一般都是配合使用，用来给视频添加水印或者旋转视频方向，AVAssetExportSession 是用来进行视频导出操作的。需要值得注意的是当App进入后台之后，会对使用到GPU的代码操作进行限制，会造成崩溃，而视频处理这些功能多数会使用到GPU,所以需要做对应的防错处理。<br>在这里我会使用Apple的官方Demo “<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html">AVSimpleEditoriOS</a>“ 作为讲解案例，该案例采用Command设计模式来组织代码，其中基类的AVSECommand包含了一些各个子类Command共用的属性。本文就视频相关操作做简要介绍，说明一些相关的操作，并标注一些重点代码，希望本文可以起到抛砖引玉的效果,让大家对视频剪辑处理有个初步印象，然后可以根据Apple官方Demo的内容进行相应的修改。大家可以下载相应的Apple官方Demo运行查看结果。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableComposition</span> *mutableComposition;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableVideoComposition</span> *mutableVideoComposition;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableAudioMix</span> *mutableAudioMix;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">CALayer</span> *watermarkLayer;<br></code></pre></td></tr></table></figure><img src="/2017/04/16/video-editor-ios/Untitled.webp" class="" title="image"><h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><img src="/2017/04/16/video-editor-ios/Untitled1.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li></ol><h2 id="视频旋转"><a href="#视频旋转" class="headerlink" title="视频旋转"></a>视频旋转</h2><p>在查有关视频旋转的资料的时候查看了一篇很不错的参考资料，在这里给大家安利一下<br><a href="http://blog.csdn.net/likendsl/article/details/7595611">http://blog.csdn.net/likendsl/article/details/7595611</a> 讲的是矩阵运算的原理，对视图的矩阵操作的相关内容。</p><img src="/2017/04/16/video-editor-ios/Untitled2.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled3.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled4.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>设置旋转矩阵变换</li><li>创建AVMutableVideoComposition对象</li><li>设置视频的渲染宽高和Frame</li><li>创建视频组合指令AVMutableVideoCompositionInstruction，并设置指令在视频的作用时间范围和旋转矩阵变换</li><li>创建视频组合图层指令AVMutableVideoCompositionLayerInstruction，并设置图层指令在视频的作用时间范围和旋转矩阵变换</li><li>把视频图层指令放到视频指令中，再放入视频组合对象中</li></ol><p>这里给出不同旋转角度的案例代码，希望能够对你起帮助，节省你的时间。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CGAffineTransform</span> translateToCenter;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.degrees != <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">CGAffineTransform</span> mixedTransform;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">90</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转90°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转90度,home按键在左&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(mixedVideoTrack.naturalSize.height,<span class="hljs-number">0.0</span>);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI_2);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.height,mixedVideoTrack.naturalSize.width);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">180</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转180°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转180度，home按键在上&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(mixedVideoTrack.naturalSize.width, mixedVideoTrack.naturalSize.height);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.width,mixedVideoTrack.naturalSize.height);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">270</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转270°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转270度，home按键在右&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(<span class="hljs-number">0.0</span>, assetVideoTrack.naturalSize.width);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI_2*<span class="hljs-number">3.0</span>);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.height,mixedVideoTrack.naturalSize.width);<br>       &#125;<br>       <span class="hljs-built_in">AVMutableVideoCompositionInstruction</span> *roateInstruction = [<span class="hljs-built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];<br>       roateInstruction.timeRange = <span class="hljs-built_in">CMTimeRangeMake</span>(kCMTimeZero, [mixComposition duration]);<br>      <span class="hljs-built_in">AVMutableVideoCompositionLayerInstruction</span> *roateLayerInstruction = [<span class="hljs-built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:mixedVideoTrack];<br>       <br>       [roateLayerInstruction setTransform:mixedTransform atTime:kCMTimeZero];<br>       <br>       roateInstruction.layerInstructions = @[roateLayerInstruction];<br>       <span class="hljs-comment">//将视频方向旋转加入到视频处理中</span><br>       waterMarkVideoComposition.instructions = @[roateInstruction];<br>       <br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="视频添加音频"><a href="#视频添加音频" class="headerlink" title="视频添加音频"></a>视频添加音频</h2><img src="/2017/04/16/video-editor-ios/Untitled5.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled6.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>往AVMutableComposition对象添加要追加的音频资源，同时设置音频资源的时间段，插入点和混合模式</li></ol><h2 id="视频添加水印"><a href="#视频添加水印" class="headerlink" title="视频添加水印"></a>视频添加水印</h2><img src="/2017/04/16/video-editor-ios/Untitled7.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled8.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>创建视频组合器对象 AVMutableVideoComposition 并设置frame和渲染宽高</li><li>创建视频组合器指令对象，设置指令的作用范围</li><li>创建视频组合器图层指令对象，设置指令的作用范围</li><li>视频组合器图层指令对象 放入 视频组合器指令对象中</li><li>视频组合器指令对象放入视频组合器对象</li><li>创建水印图层Layer并设置frame和水印的位置，并将水印加入视频组合器中</li></ol><h2 id="视频导出"><a href="#视频导出" class="headerlink" title="视频导出"></a>视频导出</h2><img src="/2017/04/16/video-editor-ios/Untitled9.webp" class="" title="image"><ol><li>创建输出路径</li><li>根据AVMutableComposition对象创建AVAssetExportSession视频导出对象</li><li>设置AVAssetExportSession的AVMutableVideoComposition对象，AVMutableAudioMix对象，视频导出路径，视频导出格式</li><li>异步导出视频，根据导出结果做对应处理。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://blog.csdn.net/likendsl/article/details/7595611">http://blog.csdn.net/likendsl/article/details/7595611</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 之 objc_msgSend 简单实现</title>
    <link href="/2017/04/16/oc-msgsend/"/>
    <url>/2017/04/16/oc-msgsend/</url>
    
    <content type="html"><![CDATA[<h3 id="objc-msgSend-函数"><a href="#objc-msgSend-函数" class="headerlink" title="objc_msgSend 函数"></a>objc_msgSend 函数</h3><p>在 Objective-C 中, message 是直到 Runtime 的时候才会绑定实现，编译器会将我们的发送消息 [receiver message] 变成函数调用 objc_msgSend，该函数会有2个默认参数，分别是 receiver 和 selector 。当然，若是该函数有其他的参数，那么其他参数就跟在2个默认参数后面。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_msgSend(receiver, selector, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p>在动态绑定过程中，objc_msgSend 函数的作用如下</p><ol><li>找到 selector 对应的方法实现，</li><li>调用方法实现，传入参数</li><li>接收方法实现的返回值并将这个返回值作为自己的返回值</li></ol><p>objc_msgSend 函数调用过程中依赖于编译器为每个类和对象提供的一些类结构，这个类结构包含了下面 2 个基本元素</p><ol><li>一个指向 superclass 的指针, 这个指针叫做 isa，对象可以用它来来访问 class ，通过 class 可以访问这个 class 类继承层次上的所有其他 class</li><li>一个 class dispatch table , 一个 selector - 方法实现地址 对应的表格， 比如 sestOrigin:: 的 selector 对应的是 setOrigin::的方法实现地址</li></ol><img src="/2017/04/16/oc-msgsend/Untitled.webp" class="" title="image"><p>Messaging 过程如上图所示，当一个对象收到一个消息（message）的时候，objc_msgSend 函数（messaging function） 会根据对象的 isa 指针 到 class dispatch table 里面去查找 method selector 。如果找不到呢？那就根据 isa 指针寻找到 superclass ，若是一直没有找到，那么就会沿着类继承层次来到了 NSObjct 。一旦找到了 method selector,那么就调用 method selector 对应的方法实现并传入对应的参数。这就是 Runtime 寻找方法实现的方式，消息动态绑定到方法实现。</p><p>为了提高 Messaging 过程的速度，消息被首次使用的时候，Runtime 会缓存 selector 和 方法实现地址。Messaging 的时候会先查询缓存，若是没有缓存，那么去 class dispatch table 寻找，若是有缓存，那么直接使用缓存，这个时候 Messaging 的速度只是比直接的函数调用来的慢那么一点点儿，这个差异基本可以忽略。</p><p>Runtime 的核心在于消息分派器 objc_msgSend，它的作用是把选择器映射为函数指针，并调用被函数指针引用的函数。我们来做简单的 objc_msgSend 的实现。</p><h3 id="C-代码实现消息分派器"><a href="#C-代码实现消息分派器" class="headerlink" title="C 代码实现消息分派器"></a>C 代码实现消息分派器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">myMsgSend</span><span class="hljs-params">(id receiver, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>&#123;<br>    <span class="hljs-comment">// selector 是选择器，是方法名的唯一标识符</span><br>    SEL selector = sel_registerName(name);<br>    <span class="hljs-comment">// methodIMP 方法实现，只是一个指向方法某个函数的指针</span><br>    IMP methodIMP = class_getMethodImplementation(object_getClass(receiver), selector);<br>    <span class="hljs-comment">// 执行 methodIMP 方法实现，methodIMP 接受一个对象，一个选择器，可变长参数列表作为参数，并返回一个对象</span><br>    <span class="hljs-keyword">return</span> methodIMP(receiver,selector);<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个 myMsgSend 函数，该函数的作用类似于 objc_msgSend。</p><ol><li>使用 sel_registerName 获取方法的唯一标识符</li><li>使用 class_getMethodImplementation 获取关于某个类或者对象的方法实现</li><li>给对应得方法实现 methodIMP 传入合适的参数，并返回一个对象。</li></ol><p>接下来我们看看如何使用这个简单的 objc_msgSend 实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">RunMyMsgSend</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// NSObject *object = [[NSObject alloc] init];</span><br>    <span class="hljs-comment">// objectClass 定义了 Objective-C 的类</span><br>    Class objectClass = (Class)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>);<br>    id object = class_createInstance(objectClass, <span class="hljs-number">0</span>);<br>    myMsgSend(object, <span class="hljs-string">&quot;init&quot;</span>);<br>    <br>    <span class="hljs-comment">// id description = [object description];</span><br>    id description = (id)myMsgSend(object, <span class="hljs-string">&quot;description&quot;</span>);<br>    <br>    <span class="hljs-comment">// const char *cstr = [description UTF8String];</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cstr = myMsgSend(description, <span class="hljs-string">&quot;UTF8String&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,cstr);<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看到，我们将 Objective-C 的发送消息过程 ，使用 C 语言来做了简单的类似实现。可以粗略的说，Runtime 真的只是 C 。</p><ol><li><code> NSObject *object = [[NSObject alloc] init] </code> 发送 init 消息使用<code> myMsgSend(object, "init")</code> 实现</li><li><code>id description = [object description]</code> 发送 description 消息使用 <code> myMsgSend(object, "description") </code> 实现</li><li><code> [description UTF8String] </code> 发送 UTF8String 消息使用 <code> myMsgSend(description, "UTF8String")</code> 实现</li></ol><p>运行以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\nRunMyMsgSend()\n&quot;</span>);<br>RunMyMsgSend();<br>NSObject *testObj = [[NSObject alloc] init];<br>NSLog(@<span class="hljs-string">&quot;%@&quot;</span>, testObj);<br></code></pre></td></tr></table></figure><p>输出运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">RunMyMsgSend()<br>&lt;NSObject: <span class="hljs-number">0x60800000fd50</span>&gt;<br>&lt;NSObject: <span class="hljs-number">0x60800000fd60</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="methodForSelector-实现消息分派器"><a href="#methodForSelector-实现消息分派器" class="headerlink" title="methodForSelector: 实现消息分派器"></a>methodForSelector: 实现消息分派器</h3><p>在 Objective-C 中，我们可以使用 methodForSelector: 来实现消息分派,那么使用 methodForSelector: 和 使用 objc_msgSend相比，会有性能提升么？为了这个性能提升直接跳过objc_msgSend值得么? 直接用代码来个测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> NSUInteger kTotalCount = <span class="hljs-number">100000000</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*voidIMP)</span><span class="hljs-params">(id,SEL,...)</span>;<br><br><span class="hljs-comment">// 分别使用objc_msgSend 和 methodForSelector 来做消息分派，对字符串做一亿次操作之后进行耗时比较</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FastCall</span><span class="hljs-params">()</span>&#123;<br>    <br>    NSMutableString *<span class="hljs-built_in">string</span> = [NSMutableString <span class="hljs-built_in">string</span>];<br>    NSTimeInterval totalTime = <span class="hljs-number">0</span>;<br>    NSDate *start = nil;<br>    NSUInteger count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 用 objc_msgSend</span><br>    start = [NSDate date];<br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; kTotalCount; count ++) &#123;<br>        [<span class="hljs-built_in">string</span> setString:@<span class="hljs-string">&quot;stuff&quot;</span>];<br>    &#125;<br>    <span class="hljs-comment">// 计算用 objc_msgSend 耗时时间</span><br>    totalTime = -[start timeIntervalSinceNow];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w/ objc_msgSend = %f\n&quot;</span>, totalTime);<br><br>    <span class="hljs-comment">// 跳过 objc_msgSend, 使用 methodForSelector 来做消息分派</span><br>    start = [NSDate date];<br>    SEL selector = @selector(setString:);<br>    voidIMP setStringMethod = (voidIMP)[<span class="hljs-built_in">string</span> methodForSelector:selector];<br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; kTotalCount; count ++) &#123;<br>        setStringMethod(<span class="hljs-built_in">string</span>,selector,@<span class="hljs-string">&quot;stuff&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 计算用 跳过 objc_msgSend 耗时时间</span><br>    totalTime = -[start timeIntervalSinceNow];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w/ objc_msgSend = %f\n&quot;</span>,totalTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>多次运行之后，结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">用 objc_msgSend 耗时 = <span class="hljs-number">6.885367</span><br>跳过 objc_msgSend 耗时 = <span class="hljs-number">6.475993</span><br></code></pre></td></tr></table></figure><p>可以为这个例子做个总结。<strong>多数情况下，我们会把 Objective-C 的方法重写成函数，这样可以得到更好更可靠的性能提升，但是不要想着绕过消息分派器 objc_msgSend ，因为 objc_msgSend 的性能开销已经小到可以忽略不计了，不需要再去优化这个过程了</strong>。</p><p>那么什么时候需要绕过消息分派器 objc_msgSend 呢？那就是循环内的大量方法调用，我们以一个<code>setFilled: </code>方法来做示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> (*setter)(id, SEL, BOOL);<br><span class="hljs-type">int</span> i;<br> <br>setter = (<span class="hljs-type">void</span> (*)(id, SEL, BOOL))[target<br>methodForSelector:@selector(setFilled:)];<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++ )<br>    setter(targetList[i], @selector(setFilled:), YES);<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 方法签名和调用</title>
    <link href="/2017/04/16/oc-signature-invocation/"/>
    <url>/2017/04/16/oc-signature-invocation/</url>
    
    <content type="html"><![CDATA[<h2 id="Objective-C-方法签名和调用"><a href="#Objective-C-方法签名和调用" class="headerlink" title="Objective-C 方法签名和调用"></a>Objective-C 方法签名和调用</h2><p>NSInvocation 是命令模式的一种实现。它把一个目标、一个选择器、一个方法签名、所有的参数都放到一个对象里面。当 NSInvocation 被调用的时候，Objective-C Runtime会执行正确的方法实现。<br>NSInvocation 包含的一个目标是一个接受消息的对象，包含的选择器是被发送的消息。在这里我们可以把选择器看成一个方法的名称，也就是一个字符串。那 NSInvocation 包含的方法签名是什么呢？方法签名 NSMethodSignature 是一个方法的返回类型和参数类型，不包括方法名称。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//  -[NSString  initWithUTF8String:] 的方法签名</span><br><span class="hljs-built_in">NSMethodSignature</span> *signature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;@@:*&quot;</span>];<br></code></pre></td></tr></table></figure><p>方法签名的 “ @@:* “ 字符串怎么理解呢？ 第一个字符 @ 表明返回值是一个 id。对于消息传递系统来说，所以的 Objective-C 对象都是 id 类型。 接下来的二个字符 @： 表明该方法接受一个 id 和一个 SEL 。其实每个 Objective-C 方法都把 id 和 SEL 作为头2个参数。最后一个字符 *   表示该方法的一个显式的参数是一个字符串（char *）。那如何获取这些类型编码呢，可以参考官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a> ，也可以直接使用类型编码 @encode(type) 获取表示该类型的字符串，而不必硬编码。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;id Type encoding --&gt;%s&quot;</span>,<span class="hljs-keyword">@encode</span>(<span class="hljs-type">id</span>));<br><span class="hljs-comment">//  输出结果 id Type encoding --&gt;@</span><br></code></pre></td></tr></table></figure><p>在平常的开发中我们基本是不需要去使用 signatureWithObjCTypes： 方法去手动创建一个方法签名的，我们可以直接使用 methodSignatureForSelector: 来获取类方法的签名或者实例方法的签名，对于实例方法的签名获取也可以直接使用 instanceMethodForSelector: 获取。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SEL initSEL = <span class="hljs-keyword">@selector</span>(init);<span class="hljs-comment">// init 方法的选择器</span><br>SEL allocSEL = <span class="hljs-keyword">@selector</span>(alloc);<span class="hljs-comment">// alloc 方法的选择器</span><br><br><span class="hljs-built_in">NSMethodSignature</span> *initSignature, *allocSignature;<br><span class="hljs-comment">// 从实例中获取实例方法签名</span><br>initSignature = [<span class="hljs-string">@&quot;Signature&quot;</span> methodSignatureForSelector:initSEL];<br><span class="hljs-comment">// 从类中获取实例方法签名</span><br>initSignature = [<span class="hljs-built_in">NSString</span> instanceMethodSignatureForSelector:initSEL];<br><span class="hljs-comment">// 从类中获取类方法签名</span><br>allocSignature = [<span class="hljs-built_in">NSString</span> methodSignatureForSelector:allocSEL];<br></code></pre></td></tr></table></figure><p>知道了方法签名的概念之后，我们可以构建一个 NSInvocation 对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//  创建数组</span><br>    <span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;array.count---&gt;%ld&quot;</span>,array.count);<br><span class="hljs-comment">//  创建一个 NSString 对象，该对象后面加入 array</span><br>    <span class="hljs-built_in">NSString</span> *stuff = <span class="hljs-string">@&quot;Stuff&quot;</span>;<br><span class="hljs-comment">//  获取 NSMutableArray 的 addObject: 方法签名</span><br>    SEL selector = <span class="hljs-keyword">@selector</span>(addObject:);<br>    <span class="hljs-built_in">NSMethodSignature</span> *signature = [array methodSignatureForSelector:selector];<br><br><span class="hljs-comment">//  创建 NSInvocation 对象</span><br>    <span class="hljs-comment">//  使用方法签名</span><br>    <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:signature];<br>    <span class="hljs-comment">// array 是接收消息的对象</span><br>    [invocation setTarget:array];<br>    <span class="hljs-comment">// 被 invocation 发送的消息 selector</span><br>    [invocation setSelector:selector];<br>    <span class="hljs-comment">// 默认 index = 0 位置的参数是 目标（self）， index = 1 位置的参数是 selector（_cmd）,从 index =2 开始才是第一个参数</span><br>    [invocation setArgument:&amp;stuff atIndex:<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// 调用 NSInvocation</span><br>    [invocation invoke];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;array.count---&gt;%ld&quot;</span>,array.count);<br><span class="hljs-comment">//  运行结果</span><br><span class="hljs-comment">//   array.count---&gt;0</span><br><span class="hljs-comment">//   array.count---&gt;1</span><br></code></pre></td></tr></table></figure><p>Objective-C 的蹦床技术<br>蹦床顾名思义就是把一个消息从一个对象反弹到另一个对象。蹦床技术一般使用 forwardInvocation: 方法来处理消息。如果一个对象在 Objective-C 提示错误之前不响应一个选择器，那么就会创建一个 NSInvocation 对象 并且传递给该对象的 forwardInvocation: 。我们可以使用这个 NSInvocation 对象做消息转发。</p><p>接下来使用蹦床这个技术实现一个类似 NSNotification 的功能。我们创建一个 RNObserverManager 的蹦床，把发送到 RNObserverManager 的消息转发到响应选择器的已注册观察者。</p><p>第一步创建 RNObserverManager</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// RNObserverManager.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNObserverManager</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">// 初始化的时候 需要一个协议和一组观察者</span><br>- (<span class="hljs-type">id</span>)initWithProtocol:(Protocol *)protocol observers:(<span class="hljs-built_in">NSSet</span> *)observers;<br><span class="hljs-comment">// 添加观察者</span><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-type">id</span>)observer;<br><span class="hljs-comment">// 删除观察者</span><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-type">id</span>)observer;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RNObserverManager.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNObserverManager</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableSet</span> *observers;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Protocol *protocol;<br><br><span class="hljs-keyword">@end</span><br><span class="hljs-comment">// 蹦床把一条消息从一个对象反弹到另一个对象。</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RNObserverManager</span></span><br><br>- (<span class="hljs-type">id</span>)initWithProtocol:(Protocol *)protocol observers:(<span class="hljs-built_in">NSSet</span> *)observers&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.protocol = protocol;<br>        <span class="hljs-keyword">self</span>.observers = [<span class="hljs-built_in">NSMutableSet</span> setWithSet:observers];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-type">id</span>)observer&#123;<br>    <span class="hljs-keyword">if</span> ([observer conformsToProtocol:<span class="hljs-keyword">self</span>.protocol]) &#123;<br>        [<span class="hljs-keyword">self</span>.observers addObject:observer];<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-type">id</span>)observer&#123;<br>    [<span class="hljs-keyword">self</span>.observers removeObject:observer];<br>&#125;<br><br><span class="hljs-comment">// Objective-C 的消息分派器使用这个方法为未知的选择器构造一个 NSInvocation</span><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *result = [<span class="hljs-variable language_">super</span> methodSignatureForSelector:aSelector];<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">// 查找所需方法</span><br>    <span class="hljs-keyword">struct</span> objc_method_description desc = protocol_getMethodDescription(<span class="hljs-keyword">self</span>.protocol, aSelector, <span class="hljs-literal">YES</span>, <span class="hljs-literal">YES</span>);<br><br>    <span class="hljs-keyword">if</span>(desc.name == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 有可能是协议的可选方法</span><br>        desc = protocol_getMethodDescription(<span class="hljs-keyword">self</span>.protocol, aSelector, <span class="hljs-literal">NO</span>, <span class="hljs-literal">YES</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(desc.name == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 找不到方法，那么抛出异常</span><br>        [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:aSelector];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:desc.types];<br>&#125;<br><span class="hljs-comment">// 把方法调用转发到响应选择器的观察者</span><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation&#123;<br>    SEL selector = [anInvocation selector];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">id</span> responder <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers)&#123;<br>        <span class="hljs-keyword">if</span> ([responder respondsToSelector:selector]) &#123;<br>            [anInvocation setTarget:responder];<br>            [anInvocation invoke];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>RNObserverManager 对象在 Objective-C 提示错误之前不响应一个选择器的话， Objective-C 会用 NSObject 类的 <code> - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector  </code> 方法获取该未知选择器的方法签名， 然后为这个未知的选择器构造一个 NSInvocation 对象，最后将这个 NSInvocation 对象传递给 NSObject 的 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation </code> 方法。</p><p>那么怎么使用 RNObserverManager 这个蹦床呢？我们先定义协议，观察者实现协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 观察者需要实现的协议</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-type">void</span>)doSomething;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 观察者</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">MyProtocol</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-comment">// 观测者实现协议方法</span><br>- (<span class="hljs-type">void</span>)doSomething&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;doSomething :%@&quot;</span>, <span class="hljs-keyword">self</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>接下来在 ViewController 里面使用这些内容</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-comment">// 使用 id 类型可以避免编译器警告</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> observerManager;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 创建消息观察者集合</span><br>    <span class="hljs-built_in">NSSet</span>  *observers = [<span class="hljs-built_in">NSSet</span> setWithObjects:[MyClass new],[MyClass new], <span class="hljs-literal">nil</span>];<br>    <span class="hljs-comment">// 创建 RNObserverManager 蹦床</span><br>    <span class="hljs-keyword">self</span>.observerManager = [[RNObserverManager alloc]<br>                            initWithProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">MyProtocol</span>) <span class="hljs-title">observers</span>:<span class="hljs-title">observers</span>];</span><br>    <span class="hljs-comment">// 给 RNObserverManager 发送 doSomething 消息，实际上都会被转发到 MyClass 的 doSomething 方法</span><br>    [<span class="hljs-keyword">self</span>.observerManager doSomething];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>查看控制台输出结果</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">doSomething <span class="hljs-symbol">:&lt;MyClass</span>: <span class="hljs-number">0x6080000157c0</span>&gt;<br>doSomething <span class="hljs-symbol">:&lt;MyClass</span>: <span class="hljs-number">0x6080000157f0</span>&gt;<br></code></pre></td></tr></table></figure><p>从结果上看，我们给 RNObserverManager 发送 doSomething 消息，实际上都会被转发到 MyClass 的 doSomething 方法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS 编程实战</a> 读书笔记</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C @dynamic 原理</title>
    <link href="/2017/04/16/oc-dynamic/"/>
    <url>/2017/04/16/oc-dynamic/</url>
    
    <content type="html"><![CDATA[<h2 id="Objective-C-dynamic-原理"><a href="#Objective-C-dynamic-原理" class="headerlink" title="Objective-C @dynamic 原理"></a>Objective-C @dynamic 原理</h2><p>在 Objective-C 中，我们偶尔会看到一个属性被声明为 @dynamic, 其实这个是在向编译器保证，虽然现在这个属性找不到 setter 和 getter 方法，但是在运行时会有可用的实现，你编译器不要自动帮我合成 ivar 了。那么 @dynamic 合成属性的方法是怎么样的呢？ 我们这里使用一个 Demo 来说明这个过程。<br>这个 Demo 使用动态实现来为 NSMutableDictionary 中存储的属性动态创建获取方法和设置方法。</p><span id="more"></span> <p>创建一个 Person 对象，该对象有 firstName 和 lastName 这两个属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Person.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *firstName;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *lastName;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>接下来看 Person.m 文件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *properties;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><span class="hljs-comment">// @dynamic, 其实这个是在向编译器保证，虽然现在这个属性找不到 setter 和 getter 方法，</span><br><span class="hljs-comment">// 但是在运行时会有可用的实现，你编译器不要自动帮我合成 ivar 了</span><br><span class="hljs-keyword">@dynamic</span> firstName,lastName;<br><br>- (<span class="hljs-type">id</span>)init&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _properties = [[<span class="hljs-built_in">NSMutableDictionary</span> alloc] init];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// getter 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">id</span> propertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL _cmd)&#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> properties] valueForKey:<span class="hljs-built_in">NSStringFromSelector</span>(_cmd)];<br>&#125;<br><br><span class="hljs-comment">// setter 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> setPropertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>,SEL _cmd, <span class="hljs-type">id</span> aValue)&#123;<br>    <span class="hljs-type">id</span> value = [aValue <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-comment">// 使用 mutableCopy 而不是 copy</span><br>    <span class="hljs-built_in">NSMutableString</span> *key = [<span class="hljs-built_in">NSStringFromSelector</span>(_cmd) mutableCopy];<br>    <span class="hljs-comment">// 删除 “set”</span><br>    [key deleteCharactersInRange:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)];<br>    <span class="hljs-comment">// 删除 “：”</span><br>    [key deleteCharactersInRange:<span class="hljs-built_in">NSMakeRange</span>([key length] <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)];<br>    <span class="hljs-comment">// 将第一个字母变为小写</span><br>    <span class="hljs-built_in">NSString</span> *firstC = [key substringToIndex:<span class="hljs-number">1</span>];<br>    [key replaceCharactersInRange:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) withString:[firstC lowercaseString]];<br>    <span class="hljs-comment">// 保存对应属性的值</span><br>    [[<span class="hljs-keyword">self</span> properties] setValue:value forKey:key];<br>&#125;<br><br><span class="hljs-comment">// 这里假设所有不能识别的方法都是 setter 方法或者 getter 方法</span><br>+ (<span class="hljs-type">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">NSStringFromSelector</span>(sel) hasPrefix:<span class="hljs-string">@&quot;set&quot;</span>]) &#123;<br>        <span class="hljs-comment">// 第一个字符 v 表明返回值是一个 void。</span><br>        <span class="hljs-comment">// 接下来的二个字符 @： 表明该方法接受一个 id 和一个 SEL</span><br>        <span class="hljs-comment">// 最后一个字符是方法的显式参数 @ 表示是一个 id</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)setPropertyIMP, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 第一个字符 @ 表明返回值是一个 id。</span><br>        <span class="hljs-comment">// 对于消息传递系统来说，所以的 Objective-C 对象都是 id 类型。</span><br>        <span class="hljs-comment">// 接下来的二个字符 @： 表明该方法接受一个 id 和一个 SEL</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)propertyIMP, <span class="hljs-string">&quot;@:@&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>从代码中可以看到，我们将 firstName,lastName 这2个属性设置成 @dynamic 。然后提供了 <code> static void setPropertyIMP(id self,SEL _cmd, id aValue)  </code> 这个 setter 方法，也提供了 <code> static id propertyIMP(id self, SEL _cmd) </code> 这个 getter 方法。在 setter 和 getter 中使用了 NSMutableDictionary 来存储和读取属性。</p><p>当 Person 无法识别一些方法的时候，Objective-C 的消息分派就会调用 Person 类的 <code>+ (BOOL)resolveInstanceMethod:(SEL)sel </code> 方法。那么我们在这个方法里面 为 Person 这个类动态的添加属性的 setter 和 getter 方法。这样 Person 就可以正确的响应属性的 setter 和 getter。这个就是 Objective-C 的动态实现，在运行过程中提供方法实现。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Runtime Type Encoding</a></li><li><a href="https://book.douban.com/subject/25976913/">iOS 编程实战</a> 读书笔记</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 消息转发流程</title>
    <link href="/2017/04/16/oc-fast-forwarding/"/>
    <url>/2017/04/16/oc-fast-forwarding/</url>
    
    <content type="html"><![CDATA[<h3 id="快速转发"><a href="#快速转发" class="headerlink" title="快速转发"></a>快速转发</h3><p>什么是快速转发呢？我们假设有这么一个对象 CacheProxy，若是有未知的选择器发送到 CacheProxy，objc_msgSend 都会调用 CacheProxy 的 forwardingTargetForSelector: 方法，如果这个方法返回一个对象，那么 objc_msgSend 会试着将这个未知的选择器发送给返回的那个对象这就是快速转发（fast forwarding）。那么我们可以利用这个快速转发的特性来代理对象。</p><p>我们使用 CacheProxy 这个对象来说明如何利用快速转发的特性来缓存其他对象的 setter 和 getter 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CacheProxy.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">// 快速转发 ：若是有未知的选择器发送到 CacheProxy，objc_msgSend 都会调用 CacheProxy 的 forwardingTargetForSelector: 方法，如果这个方法返回一个对象，那么 objc_msgSend 会试着将这个未知的选择器发送给返回的那个对象。</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CacheProxy</span> : <span class="hljs-title">NSProxy</span></span><br><span class="hljs-comment">// 初始化方法 ，返回类型为 id 类型，可以避免编译器报错</span><br>- (<span class="hljs-type">id</span>)initWithObject:(<span class="hljs-type">id</span>)anObject properties:(<span class="hljs-built_in">NSArray</span> *)properties;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>值的注意的是  CacheProxy 并不是 NSObject 的子类，而是 NSProxy 的子类，NSProxy 是一个轻量级的根类，是为那些转发大部分方法调用的类而设计的。CacheProxy 本身就是一个代理对象，适合成为 NSProxy 的子类。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CacheProxy.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CacheProxy.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CacheProxy</span> ()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> object;<span class="hljs-comment">//被代理的对象</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *valueForProperty;<span class="hljs-comment">// 用于保存被代理对象的属性值</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CacheProxy</span></span><br><br><span class="hljs-comment">// setFoo: -&gt; foo</span><br><span class="hljs-comment">// 通过 selector 得到属性名</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *propertyNameForSelector(SEL selector)&#123;<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br><br><span class="hljs-comment">// foo -&gt; setFoo:</span><br><span class="hljs-comment">// 通过属性名得到 selector</span><br><span class="hljs-keyword">static</span> SEL setterForPropertyName(<span class="hljs-built_in">NSString</span> *property)&#123;<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br><br><span class="hljs-comment">// getter 方法实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">id</span> propertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL _cmd)&#123;<br>    <span class="hljs-built_in">NSString</span> *propertyName = <span class="hljs-built_in">NSStringFromSelector</span>(_cmd);<br>    <span class="hljs-type">id</span> value = [[<span class="hljs-keyword">self</span> valueForProperty] valueForKey:propertyName];<br>    <span class="hljs-comment">// NSMutableDictionary 不能存储 nil，所以使用 NSNull 来处理 nil</span><br>    <span class="hljs-keyword">if</span> (value == [<span class="hljs-built_in">NSNull</span> null]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 从缓存对象取不到属性值的话，那么从原对象取属性值</span><br>    value = [[<span class="hljs-keyword">self</span> object] valueForKey:propertyName];<br>    <span class="hljs-comment">// 从原对象取属性值之后，将属性值缓存到缓存对象</span><br>    [[<span class="hljs-keyword">self</span> valueForProperty] setValue:value forKey:propertyName];<br><br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// setter 方法实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> setPropertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL _cmd, <span class="hljs-type">id</span> aValue)&#123;<br>    <span class="hljs-type">id</span> value = [aValue <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSString</span> *propertyName = propertyNameForSelector(_cmd);<br>    <span class="hljs-comment">// 先将属性值设置到缓存对象，再将属性值设置到原对象</span><br>    [[<span class="hljs-keyword">self</span> valueForProperty] setValue:(value != <span class="hljs-literal">nil</span> ? value : [<span class="hljs-built_in">NSNull</span> null]) forKey:propertyName];<br>    [[<span class="hljs-keyword">self</span> object] setValue:value forKey:propertyName];<br>&#125;<br><br><br>- (<span class="hljs-type">id</span>)initWithObject:(<span class="hljs-type">id</span>)anObject properties:(<span class="hljs-built_in">NSArray</span> *)properties&#123;<br>    _object = anObject;<br>    _valueForProperty = [<span class="hljs-built_in">NSMutableDictionary</span> new];<br>    <span class="hljs-comment">// 缓存对象为 anObject 的所有属性生成 setter 和 getter 方法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSString</span> *property <span class="hljs-keyword">in</span> properties)&#123;<br>        <span class="hljs-comment">// 添加 getter 方法</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-built_in">NSSelectorFromString</span>(property), (IMP)propertyIMP, <span class="hljs-string">&quot;@@:&quot;</span>);<br>        <span class="hljs-comment">// 添加 setter 方法</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], setterForPropertyName(property), (IMP)setPropertyIMP, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 覆写以下方法，CacheProxy 缓存对象对外可以被识别为 object 对象</span><br>- (<span class="hljs-built_in">NSString</span> *)description&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ (%@)&quot;</span>,[<span class="hljs-variable language_">super</span> description],<span class="hljs-keyword">self</span>.object];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isEqual:(<span class="hljs-type">id</span>)object&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isEqual:object];<br>&#125;<br><br>- (<span class="hljs-built_in">NSUInteger</span>)hash&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object hash];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object respondsToSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isKindOfClass:(Class)aClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isKindOfClass:aClass];<br>&#125;<br><br><br><span class="hljs-comment">// 如果有未知的选择器发送到 CacheProxy 缓存对象，在这里把所有的未知选择器都发送给代理对象。</span><br><span class="hljs-comment">// 快速转发</span><br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.object;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation setTarget:<span class="hljs-keyword">self</span>.object];<br>    [invocation invoke];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ol><li><p>方法 static NSString *propertyNameForSelector(SEL selector) 用于通过 selector 得到属性名。</p></li><li><p>方法 static SEL setterForPropertyName(NSString *property)用于通过属性名得到 selector。</p></li><li><p>方法 static id propertyIMP(id self, SEL _cmd) 是一个 getter 方法实现。由于 NSMutableDictionary 不能存储 nil，所以使用 NSNull 来处理 nil。从 CacheProxy 这个缓存对象对象取不到属性值的话，那么从被代理对象取属性值。 从被代理对象取属性值之后，将属性值缓存到缓存对象。</p></li><li><p>方法 static void setPropertyIMP(id self, SEL _cmd, id aValue) 是一个 setter 方法实现。 先将属性值设置到缓存对象，再将属性值设置到被代理对象。</p></li><li><p>forwardingTargetForSelector: 方法，如果有未知的选择器发送到 CacheProxy 缓存对象，在这里把所有的未知选择器都发送给被代理对象。</p></li><li><p>如果被代理的对象不响应 CacheProxy 发送过来的未知选择器，那么 objc_msgSend会调用 methodSignatureForSelector: 和 forwardInvocation: 进行普通转发。</p></li><li><p>初始化方法 initWithObject: properties: 做的工作是代理对象生成被代理对象的属性 setter 和 getter 方法。</p></li><li><p>由于 NSProxy 有一些方法的默认实现，有默认实现的方法则不会被转发到代理对象，所以需要覆写以下方法。</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSString</span> *)description&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ (%@)&quot;</span>,[<span class="hljs-variable language_">super</span> description],<span class="hljs-keyword">self</span>.object];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isEqual:(<span class="hljs-type">id</span>)object&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isEqual:object];<br>&#125;<br><br>- (<span class="hljs-built_in">NSUInteger</span>)hash&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object hash];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object respondsToSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isKindOfClass:(Class)aClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isKindOfClass:aClass];<br>&#125;```<br><br><br>创建完了 CacheProxy 这个代理对象，我们再创建一个 被代理对象 CachePerson<br>```objectivec<br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CachePerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">// 2个属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *firstName;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *lastName;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>接下来看看如何使用 CacheProxy 这个代理对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 说明 CacheProxy 如何缓存其他对象的 setter 和 getter 方法</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------------------------------------------&quot;</span>);<br><span class="hljs-type">id</span> cachePerson = [[CachePerson alloc] init];<br><span class="hljs-type">id</span> cacheProxy = [[CacheProxy alloc] initWithObject:cachePerson properties:@[<span class="hljs-string">@&quot;firstName&quot;</span>,<span class="hljs-string">@&quot;lastName&quot;</span>]];<br><span class="hljs-comment">// 设置 CacheProxy 对象的属性， cachePerson 这个被代理对象的属性也有值</span><br>[cacheProxy setFirstName:<span class="hljs-string">@&quot;CCCC&quot;</span>];<br>[cacheProxy setLastName:<span class="hljs-string">@&quot;DDDD&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CacheProxy : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cacheProxy firstName],[cacheProxy lastName]);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CachePerson : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cachePerson firstName],[cachePerson lastName]);<br><br><span class="hljs-comment">// 说明快速转发</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------------------------------------------&quot;</span>);<br><span class="hljs-comment">// 只设置被代理对象 CachePerson 的属性，利用快速转发的特性 CacheProxy 也能拿到 CachePerson 的属性</span><br><span class="hljs-type">id</span> cachePerson2 = [[CachePerson alloc] init];<br>[cachePerson2 setFirstName:<span class="hljs-string">@&quot;EEEE&quot;</span>];<br>[cachePerson2 setLastName:<span class="hljs-string">@&quot;FFFF&quot;</span>];<br><br><span class="hljs-type">id</span> cacheProxy2 = [[CacheProxy alloc] initWithObject:cachePerson2 properties:@[<span class="hljs-string">@&quot;firstName&quot;</span>]];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CacheProxy2 : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cacheProxy2 firstName],[cacheProxy2 lastName]);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CachePerson2 : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cachePerson2 firstName],[cachePerson2 lastName]);<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> ------------------------------------------<br>CacheProxy : firstName--&gt;CCCC,  lastName---&gt;DDDD<br>CachePerson : firstName--&gt;CCCC,  lastName---&gt;DDDD<br> ------------------------------------------<br>CacheProxy2 : firstName--&gt;EEEE,  lastName---&gt;FFFF<br>CachePerson2 : firstName--&gt;EEEE,  lastName---&gt;FFFF<br></code></pre></td></tr></table></figure><p>从运行结果来看，第一个案例，我们设置了 CacheProxy 对象的属性 firstName 和 lastName， cachePerson 这个被代理对象的属性 firstName 和 lastName 也拿到了对应的值。第二个案例，我们只设置被代理对象 CachePerson 的属性 firstName 和 lastName 的值，但是利用快速转发的特性 CacheProxy 也能拿到 CachePerson 的属性 firstName 和 lastName 的值。</p><h3 id="普通转发"><a href="#普通转发" class="headerlink" title="普通转发"></a>普通转发</h3><p>在前面的快速转发失效之后，也就是经过 resolveInstanceMethod: 和 forwardingTargetForSelector： 方法之后还是无法找到未知选择器的响应对象，那么 Runtime 就会尝试最慢的转发方式 forwardInvocation: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation setTarget:<span class="hljs-keyword">self</span>.object];<br>    [invocation invoke];<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，在 forwardInvocation: 方法会收到一个 NSInvocation 参数，这个 NSInvocation 类把目标，选择器，方法签名和方法参数封装在一起。我们可以在方法内部改变 NSInvocation 的目标然后再调用。</p><p>若是类有实现 forwardInvocation: 方法，那么也需要实现 methodSignatureForSelector: 方法， NSInvocation 类的方法签名就是来自于这个方法。</p><p>在 forwardInvocation：方法中，我们可以看到该方法没有任何返回值，但是 Runtime 会把 NSInvocation 的结果返回给最初的调用者。</p><h3 id="转发失败"><a href="#转发失败" class="headerlink" title="转发失败"></a>转发失败</h3><p>在整个消息转发过程都没有为未知选择器找到响应对象，那么接下来要怎么办？<br>由于 forwardInvocation：是消息转发过程的最后一环，若是它不处理这个未知选择器的话，那么就什么也不会发生，也可以利用这个特点来丢弃某些方法。但是 forwardInvocation: 的默认实现会有一些动作，它会调用 doesNotReconizeSelector：方法，该方法会抛出 NSInvalidArgumentException。</p><p>我们平常也可以使用 doesNotReconizeSelector：方法做一些自己的事情，比如某个类的 init 方法不允许调用，那么有如下实现方案。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">id</span>)init&#123;<br>    [<span class="hljs-keyword">self</span> doesNotReconizeSelector:_cmd];<br>&#125;<br></code></pre></td></tr></table></figure><p>要是有人调用 init 方法， Runtime 会报错。<br>其实要实现这个效果还可以这么做，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">id</span>)init&#123;<br>    <span class="hljs-built_in">NSAssert</span>(<span class="hljs-literal">NO</span>,<span class="hljs-string">&quot;不要直接调用 init 方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后值得注意的是，当有一个类无法响应未知的选择器的时候应该在 forwardInvocation：中调用 doesNotReconizeSelector: 。除非你非常清楚你想要做什么，不然不要直接返回，直接返回可能会导致一些非常蛋疼的 bug 。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>demo <a href="https://github.com/junbinchencn/DynamicWork">https://github.com/junbinchencn/DynamicWork</a></li><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW2">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW2</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iPad 分屏框架 - SPStackedNav 源码解读</title>
    <link href="/2017/03/26/reading-source-code-of-SPStackedNav/"/>
    <url>/2017/03/26/reading-source-code-of-SPStackedNav/</url>
    
    <content type="html"><![CDATA[<h1 id="SPStackedNav-解读"><a href="#SPStackedNav-解读" class="headerlink" title="SPStackedNav 解读"></a>SPStackedNav 解读</h1><p><a href="https://github.com/spotify/SPStackedNav">SPStackedNav</a> 是全球最大的流音乐服务商 Spotify 开源的一个 iPad 分屏框架，用于 Spotify 的 iPad 版 App 中，网易云音乐 iPad 版 App 也是采用相似的分屏交互方案，该框架的交互表现如下图所示：</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled.webp" class="" title="image"><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>根据 <a href="https://github.com/spotify/SPStackedNav">GitHub</a> 上面的说明完成项目导入之后，那么就可以开始搭建UI框架了。</p><ol><li><p>创建 SPSideTabController,  SPSideTabController 的用法和UITabController的用法没有什么大的区别。</p></li><li><p>分别创建 SPSideTabController 的 RootViewController，设置 UITabBarItem 属性。</p></li><li><p>给 SPSideTabController 的 viewControllers 属性赋值对应的 RootViewController 数组。</p></li><li><p>Demo 的 AppDelegate 代码如下：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>&#123;<br>    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];<br>    <span class="hljs-comment">// Override point for customization after application launch.</span><br>    self.window.backgroundColor = [UIColor whiteColor];<br><br>    <span class="hljs-comment">// 步骤 1 创建 SPSideTabController</span><br>    self.tabs = [[SPSideTabController alloc] init];<br>    <br>    <span class="hljs-comment">// 步骤 2 分别创建 SPSideTabController 的 RootViewController，设置 UITabBarItem 属性</span><br>    RootTestViewController *root1 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root1.title = @<span class="hljs-string">&quot;Root 1&quot;</span>;<br>    root1.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;114-balloon&quot;</span>];<br>    <br>    RootTestViewController *root2 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root2.title = @<span class="hljs-string">&quot;Root 2&quot;</span>;<br>    root2.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;185-printer&quot;</span>];<br>    root2.tabBarItem.badgeValue = @<span class="hljs-string">&quot;5&quot;</span>;<br>    root2.tabBarItem.badgeColor = [UIColor redColor];<br><br>    RootTestViewController *root3 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root3.title = @<span class="hljs-string">&quot;Root 3&quot;</span>;<br>    root3.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;114-balloon&quot;</span>];<br>    <br>    <span class="hljs-comment">// 步骤 3 给 SPSideTabController 的 viewControllers 属性赋值对应的 RootViewController 数组</span><br>    self.tabs.viewControllers = @[<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root1],<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root2],<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root3]<br>    ];<br><br>    self.window.rootViewController = self.tabs;<br>    [self.window makeKeyAndVisible];<br>    <br>    <br>    <span class="hljs-keyword">return</span> YES;<br>&#125;```<br><br><br><span class="hljs-number">5.</span>效果图<br><br>&#123;% asset_img Untitled1.webp image %&#125;<br><br><br>&#123;% asset_img Untitled2.webp image %&#125;<br><br><br>### 设计<br><br>&#123;% asset_img Untitled3.webp image %&#125;<br><br>从图中的 View 层次结构图可以看到，左边的侧边栏 View 是一个  SPSideTabBar,该 SPSideTabBar 包含若干个 SPSideTabItemButton 。右边的容器 View 是一个 SPStackedNavigationScrollView ，该 SPStackedNavigationScrollView 里面包含了若干个 SPStackedPageContainer ， 一个 SPStackedPageContainer 可以简单的看做一个ViewController。<br><br>当我们在 Demo 项目中的 RootTestViewController 里面 push 一个 ViewController 的时候。其实就相当于往 SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 view。SPStackedPageContainer的显示内容来自于 ViewController 的 view 属性。<br><br>```CPP<br>    ChildTestViewController *vc = [ChildTestViewController <span class="hljs-keyword">new</span>];<br>    [self.stackedNavigationController pushViewController:vc animated:YES];<br></code></pre></td></tr></table></figure><h3 id="SPSideTabBar-和-SPSideTabItemButton-解析"><a href="#SPSideTabBar-和-SPSideTabItemButton-解析" class="headerlink" title="SPSideTabBar 和 SPSideTabItemButton 解析"></a>SPSideTabBar 和 SPSideTabItemButton 解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP">RootTestViewController *root2 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root2.title = @<span class="hljs-string">&quot;Root 2&quot;</span>;<br>    root2.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;185-printer&quot;</span>];<br>    root2.tabBarItem.badgeValue = @<span class="hljs-string">&quot;5&quot;</span>;<br>    root2.tabBarItem.badgeColor = [UIColor redColor];<br></code></pre></td></tr></table></figure><p>Demo 代码里面的 AppDelegate 设置的明明是 UITabBarItem 的各类属性， 但是为什么在 SPSideTabBar 里面没有看到关于 UITabBarItem 的信息呢？</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled4.webp" class="" title="image"><p>再来看看 SPSideTabBar 这个 View 的层级结构图，可以猜出 SPSideTabBar 将 UITabBarItem 的属性设置映射成 SPSideTabItemButton 的属性设置了。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled5.webp" class="" title="image"><p>查看 SPSideTabController.m 文件的 viewDidLoad 方法，我们可以看到 _tabBar.items &#x3D; validItems 这个属性设置方法将 SPSideTabController 的 tabBarItem 的对象数组传给SPSideTabBar 的 items属性。</p><p>来到 SPSideTabBar.m 实现文件查看 - (void)setItems:(NSArray*)items 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//将 UITabBarItem 数组转成 SPSideTabItemButton 数组</span><br>- (<span class="hljs-type">void</span>)setItems:(NSArray*)items<br>&#123;<br>    <br>    <span class="hljs-keyword">if</span> ([items isEqual:_items]) <span class="hljs-keyword">return</span>;<br>    <br>    self.selectedItem = nil;<br>    <br>    _items = [items copy];<br>    <br>    <span class="hljs-keyword">for</span>(UIView *b in _itemButtons) [b removeFromSuperview];<br>    self.itemButtons = nil;<br><br>    <span class="hljs-keyword">if</span> (_items) &#123;<br>        NSMutableArray *itemButtons = [NSMutableArray array];<br>        CGRect pen = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>);<br>        <span class="hljs-keyword">for</span>(UITabBarItem *item in _items) &#123;<br>            <span class="hljs-comment">//关键步骤 将 UITabBarItem 转成 SPSideTabItemButton</span><br>            UIView *b = [self buttonForItem:item withFrame:pen];<br>            [itemButtons addObject:b];<br>            [self addSubview:b];<br>            pen.origin.y += pen.size.height + <span class="hljs-number">10</span>;<br>        &#125;<br>        self.itemButtons = itemButtons;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟踪查看方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">UIView *b = [self buttonForItem:item withFrame:pen];<br>```         <br><br>```CPP<br><span class="hljs-comment">// 设置 SPTabBarItem 的 frame，并返回 SPTabBarItem 的 View</span><br>- (UIView*)buttonForItem:(UITabBarItem*)item withFrame:(CGRect)pen<br>&#123;<br>    <span class="hljs-keyword">if</span> ([item isKindOfClass:[SPTabBarItem <span class="hljs-keyword">class</span>]] &amp;&amp; [(SPTabBarItem*)item view]) &#123;<br>        UIView *view = [(SPTabBarItem*)item view];<br>        [view setFrame:pen];<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>    <br>    SPSideTabItemButton *b = [[SPSideTabItemButton alloc] initWithFrame:pen];<br>    <br>     <span class="hljs-comment">// 省略 UITabBarItem 的属性转成 SPSideTabItemButton 的属性过程，</span><br>     <span class="hljs-comment">// 具体细节可以详看源码</span><br>    <br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 SPSideTabBar 自定义 View 来替代系统的 UITabBar, 使用 SPTabBarItem 自定义 View 来替代系统的 UITabBarItem，SPSideTabBar 将 UITabBarItem 的属性设置映射到 SPTabBarItem。这个就是常见的自定义 TabBar  的思路。</p><h3 id="SPStackedNavigationController-解析"><a href="#SPStackedNavigationController-解析" class="headerlink" title="SPStackedNavigationController 解析"></a>SPStackedNavigationController 解析</h3><p>SPStackedNavigationController 继承与 UIViewController，并定义和实现了一系列和 NavigationController 相关的方法,简而言之就是自己实现一个 NavigationController，这里做重讲解2个主要的方法.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate<br><br>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;<br></code></pre></td></tr></table></figure><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled6.webp" class="" title="image"><p>当 SPStackedNavigationController 做 push 操作的时候，就是往 SPStackedNavigationScrollView 这个仿 ScrollView 的 View 添加一个 SPStackedPageContainer 子View。从上图中的左边的 View 层次结构中可以看到SPStackedNavigationScrollView 里面有2个 SPStackedPageContainer 子 View。而上图中右边的 View 表现正好印证了这个结构。</p><p>查看 SPStackedNavigationController.m 文件的 - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate 实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate<br>&#123;<br>    <span class="hljs-comment">// 省略代码</span><br>    <span class="hljs-comment">// 添加 viewController 到 viewControllers 的数组</span><br>    [self willChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    [self addChildViewController:viewController];<br>    <br>    <span class="hljs-comment">//将 viewController 添加到 self,</span><br>    <span class="hljs-keyword">if</span> ([self isViewLoaded])<br>    <span class="hljs-comment">// 关键步骤 SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 View</span><br>        [self pushPageContainerWithViewController:viewController];<br>    <br>    <span class="hljs-keyword">if</span> (activate)<br>        [self setActiveViewController:viewController position:activePosition animated:animated];<br>    <span class="hljs-comment">// 调用 viewController 生命周期方法</span><br>    [viewController didMoveToParentViewController:self];<br>    [self didChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看看  SPStackedNavigationController.m 文件  - (void)pushPageContainerWithViewController:(UIViewController*)viewController 的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushPageContainerWithViewController:(UIViewController*)viewController<br>&#123;<br>    CGSize size = self.view.frame.size;<br>    CGRect frame = <span class="hljs-built_in">CGRectMake</span>(self.view.bounds.size.width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size.height);<br>    frame.size.width = (viewController.stackedNavigationPageSize == kStackedPageHalfSize ?<br>                        kSPStackedNavigationHalfPageWidth :<br>                        size.width);<br>    <br>    SPStackedPageContainer *pageC = [[SPStackedPageContainer alloc] initWithFrame:frame VC:viewController];<br>    <span class="hljs-comment">//SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 View</span><br>    [_scroll addSubview:pageC];<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以验证我们上文所述，当 SPStackedNavigationController 做 push 操作的时候，就是往 SPStackedNavigationScrollView 这个 View 添加一个 SPStackedPageContainer 子 View。</p><p>我们现在是否可以这样猜测，当 SPStackedNavigationController 做 pop 操作的时候，就是在 SPStackedNavigationScrollView 这个View 移除一个 SPStackedPageContainer View。</p><p>接下来查看 SPStackedNavigationController.m 文件的  - (UIViewController *)popViewControllerAnimated:(BOOL)animated 方法来验证一下我们的猜测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (UIViewController *)popViewControllerAnimated:(BOOL)animated<br>&#123;<br>    UIViewController *viewController = [[self childViewControllers] lastObject];<br>    <span class="hljs-keyword">if</span> (!viewController)<br>        <span class="hljs-keyword">return</span> nil;<br>    <br>    [self willChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    [viewController willMoveToParentViewController:nil];<br>    <br>    <span class="hljs-keyword">if</span> ([self isViewLoaded])<br>    &#123;<br>        <span class="hljs-comment">// 关键步骤 ，将 SPStackedPageContainer 标记为移除状态，后续 SPStackedNavigationScrollView 会将它移除</span><br>        SPStackedPageContainer *pageC = [_scroll containerForViewController:viewController];<br>        pageC.markedForSuperviewRemoval = YES;<br>    &#125;<br>    <br>    <span class="hljs-comment">//关键步骤，移除 viewController</span><br>    [viewController removeFromParentViewController];<br>    [self didChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    <br>    [self setActiveViewController:[self.childViewControllers lastObject]<br>                         position:SPStackedNavigationPagePositionRight<br>                         animated:animated];<br>    <br>    <span class="hljs-keyword">return</span> viewController;<br>&#125;<br></code></pre></td></tr></table></figure><p>如我们猜测 SPStackedNavigationController 做 pop 操作的时候，就是在 SPStackedNavigationScrollView 这个View 移除一个 SPStackedPageContainer View。并让  SPStackedPageContainer 对应的 ViewController 发一个  removeFromParentViewController 的消息。</p><h3 id="SPStackedPageContainer-解析"><a href="#SPStackedPageContainer-解析" class="headerlink" title="SPStackedPageContainer 解析"></a>SPStackedPageContainer 解析</h3><p>SPStackedPageContainer 的作用是承载 ViewController 的 View，并对一些手势动作进行处理，在这里 SPStackedPageContainer 这个概念在这里等同于一个分屏 View。<br>打开 SPStackedPageContainer.m 查看 - (void)setVCVisible:(BOOL)VCVisible 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//将VC的View加到Container里面</span><br>- (<span class="hljs-type">void</span>)setVCVisible:(BOOL)VCVisible<br>&#123;<br>    <span class="hljs-keyword">if</span> (VCVisible == self.VCVisible) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span> (VCVisible) &#123;<br>        [self.screenshot removeFromSuperview];<br>        self.screenshot = nil;<br>        <span class="hljs-keyword">if</span> (!self.markedForSuperviewRemoval || [_vc isViewLoaded])<br>        &#123;<br>            _vcContainer.backgroundColor = _vc.view.backgroundColor;<br>            _vc.view.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.bounds.size.width, self.bounds.size.height);<br>            <span class="hljs-keyword">if</span> (!_vc.view.superview)<br>                <span class="hljs-comment">// 关键步骤 添加 View</span><br>                [_vcContainer insertSubview:_vc.view atIndex:<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([_vc isViewLoaded])<br>            <span class="hljs-comment">// 关键步骤 移除 View</span><br>            [_vc.view removeFromSuperview];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPStackedNavigationScrollView-解析"><a href="#SPStackedNavigationScrollView-解析" class="headerlink" title="SPStackedNavigationScrollView 解析"></a>SPStackedNavigationScrollView 解析</h3><p>SPStackedNavigationScrollView 是一个模仿 UIScrollView 实现的 View。关于 UIScrollView 的深入理解，推荐 ObjC 中国的文章 <a href="https://www.objccn.io/issue-3-2/">理解 Scroll Views</a>， 这里就不再详述，默认大家都是能理解 UIScrollView 的相关概念。</p><p>当使用 SPStackedNavigationController 做3次 Push 操作的时候， SPStackedNavigationScrollView 的 View 层次结构是这样的。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled7.webp" class="" title="image"><p>SPStackedNavigationController 的 rootView 就是 Container0 这个 View。而 Push 的 View 分别是 Container1，Container2,Container3。左边的半屏 View 的位置从底往上分别是 Container1 –&gt; Container2。右边的半屏 View 则是 Container3。若是 SPStackedNavigationController 再 Push 一个 View 的话，那么 左边的半屏 View 的位置从底往上分别是 Container1 –&gt; Container2 –&gt; Container3 。右边的半屏 View 则是 Container4，<strong>Container 这个概念在这里等同于一个分屏 View</strong>。 在这个时候 SPStackedNavigationScrollView 的View 的简单示意图如下</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled8.webp" class="" title="image"><p>从上面的 View 结构示意图中可以看出，SPStackedNavigationScrollView 对 UIScrollView 的模仿主要体现在 UIScrollView 的滑动机制上。<br>当 SPStackedNavigationController 做 push 操作的时候，SPStackedNavigationScrollView 右边半屏的 View 会从右向左滑动到左边半屏的位置，而右边半屏则从右向左显示一个新的 push 进来的 View。<br> 当 SPStackedNavigationController 做 pop 操作的时候，SPStackedNavigationScrollView 右边半屏的 View 会从左向右滑动出屏幕显示范围，而左边半屏的 View 则会从左向右滑动到右边半屏。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled9.webp" class="" title="image"><p>讲完了 SPStackedNavigationScrollView 的大概表现之后，若是大家还是不怎么了解的话，可以运行 Demo 详细体会SPStackedNavigationScrollView 的UI变化。<br>我们接下来查看 SPStackedNavigationScrollView.h 文件，寻找和 UIScrollView 相关的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP">@interface SPStackedNavigationScrollView : UIView<br> <span class="hljs-comment">// ...... 省略代码</span><br>@<span class="hljs-built_in">property</span>(nonatomic) CGPoint contentOffset;<br>- (<span class="hljs-type">void</span>)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;<br>- (NSRange)scrollRange;<br><span class="hljs-comment">// ...... 省略代码</span><br>@end<br></code></pre></td></tr></table></figure><p>从 SPStackedNavigationScrollView 的头文件中，我们可以看到  SPStackedNavigationScrollView 继承于 UIView。和 UIScrollView 相关的概念有 contentOffset 和 scrollRange。关于 UIScrollView 的深入理解，推荐 查看 ObjC 中国的文章 <a href="https://www.objccn.io/issue-3-2/">理解 Scroll Views</a> ，这里就不再详述，默认大家都是能理解 UIScrollView 的相关概念。</p><p>接下来开始讲解 SPStackedNavigationScrollView 的具体实现。<br>看下面的图，当屏幕上只有 rootView 没有分屏的 View 的时候 SPStackedNavigationScrollView 的 frame 的坐标原点是在 rootView 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; 0。</p><p>接着看图，当屏幕上出现一个分屏的 View 的时候，我们叫这个 View 为 Container1。 SPStackedNavigationScrollView 的 frame 的坐标原点是在 Container1 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; rootView.width &#x2F; 2。</p><p>接着看图，当屏幕上出现二个分屏的 View 的时候，我们分别叫这二个 View 为 Container1 和 Container2。 SPStackedNavigationScrollView 的 frame 的坐标原点是在 Container1 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; rootView.width。</p><p>从上面的示意图中不难看出理解 SPStackedNavigationScrollView 的重点在于理解 SPStackedNavigationScrollView 不断变化的 frame 原点 和 contentOffset。只要 contentOffset 发生了变化，那么 SPStackedNavigationScrollView 就会发生滚动。</p><p>查看 SPStackedNavigationScrollView.m 文件，看到了2个和contentOffset相关的变量 _actualOffset 和 _targetOffset，接下来跟踪这2个变量的变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP">@implementation SPStackedNavigationScrollView &#123;<br>    CGPoint _actualOffset; <span class="hljs-comment">//模拟 ScrollView 当前的 contentOffset</span><br>    CGPoint _targetOffset;<span class="hljs-comment">// 模拟 ScrollView 将要滚动到的 contentOffset</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查看 SPStackedNavigationScrollView 的 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated 方法,作用是赋值 _targetOffset 和 _actualOffset 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 模仿 UIScrollView 滚动到指定位置</span><br>- (<span class="hljs-type">void</span>)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated<br>&#123;<br>    <span class="hljs-comment">//  给 _targetOffset 赋值</span><br>    _targetOffset = contentOffset;<br>    <span class="hljs-keyword">if</span> (animated)<br>        [self animateToTargetScrollOffset];<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  给 _actualOffset 赋值</span><br>        _actualOffset = _targetOffset;<br>        <span class="hljs-keyword">if</span> (_onScrollDone)<br>        &#123;<br>            self.<span class="hljs-built_in">onScrollDone</span>();<br>            self.onScrollDone = nil;<br>        &#125;<br>       <span class="hljs-comment">// 关键步骤</span><br>        [self setNeedsLayout];<br>    &#125;                                                                                                                         <br>&#125;<br></code></pre></td></tr></table></figure><p>UIView 在调用 setNeedsLayout 方法之后，会调用 layoutSubviews 方法。接下看查看该方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)layoutSubviews<br>&#123;<br>    <span class="hljs-comment">// pen 的作用是stretch scroll at start and end</span><br>    <span class="hljs-comment">// 用于在第一屏从左向右拉扯和最后一屏从右向左拉扯，</span><br>    <span class="hljs-comment">// 让手势拖动的距离2倍于View移动的距离。</span><br>    <span class="hljs-comment">// _actualOffset 改变之后，通过特定的规则计算 pen 的 frame,然后将 frame 赋值给 View ，</span><br>    <span class="hljs-comment">// 总之作用就是调整 View 的 frame 位置</span><br>    <span class="hljs-comment">// 可以说 pen 就是对应的每个分屏的 frame</span><br>    CGRect pen = CGRectZero;<br><br>    <span class="hljs-comment">// 为什么需要 -  _actualOffset.x ？</span><br>    <span class="hljs-comment">// 为了得到每个分屏 View 的坐标的 X 值 （坐标原点是 SPStackedNavigationScrollView 的坐标原点，即在屏幕范围内的最左边的分屏 View 的左上角位置）</span><br>    <span class="hljs-comment">// 详见 ContentOffset 的计算方法</span><br>    pen.origin.x = -_actualOffset.x;<br>    <br>    <span class="hljs-comment">// stretch scroll at start and end</span><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 第一页从左向右拉扯 _actualOffset.x &lt; 0 才成立，</span><br>        <span class="hljs-comment">// _actualOffset 就是当前模仿的 UIScrollView 的 contentOffset</span><br>        <span class="hljs-comment">// 手势拖动的距离2倍于 View 移动的距离</span><br>        pen.origin.x = -_actualOffset.x/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    CGFloat maxScroll = [self scrollOffsetForAligningPageWithRightEdge:self.subviews.lastObject];<br>    <span class="hljs-keyword">if</span> (_actualOffset.x &gt; maxScroll)&#123;<br>            pen.origin.x = -(maxScroll + (_actualOffset.x-maxScroll)/<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// markedForSuperviewRemovalOffset 标记 pageC 自己的 offset 坐标</span><br>    <span class="hljs-comment">// 用来给 superview 把 pageC 从当前位置移动到 markedForSuperviewRemovalOffset 指定的坐标</span><br>    <span class="hljs-comment">// 可以让自己的 View 对边缘层叠效果做出对应的位置</span><br>    <span class="hljs-comment">// 也可以让 pageC 自己全屏或者半屏,</span><br>    CGFloat markedForSuperviewRemovalOffset = pen.origin.x;<span class="hljs-comment">// View 的坐标位置x</span><br>    NSMutableArray *stackedViews = [NSMutableArray array];<br>    <br>    <span class="hljs-keyword">for</span>(SPStackedPageContainer *pageC in self.subviews) &#123;<br>        pen.size = pageC.bounds.size;<br>        pen.size.height = self.frame.size.height;<br>        <span class="hljs-keyword">if</span> (pageC.vc.stackedNavigationPageSize == kStackedPageFullSize)<br>            pen.size.width = self.frame.size.width;<br>        <br>        CGRect actualPen = pen;<br>        <span class="hljs-keyword">if</span> (pageC.markedForSuperviewRemoval)<br>            actualPen.origin.x = markedForSuperviewRemovalOffset;<br>        <span class="hljs-comment">// Stack on the left</span><br>        <span class="hljs-comment">// 小于 （0，1，2，3）*3</span><br>        <span class="hljs-comment">// 左边是一个 stackedViews，最多有3层边缘层叠效果</span><br>        <span class="hljs-keyword">if</span> (actualPen.origin.x &lt; (<span class="hljs-built_in">MIN</span>(i, <span class="hljs-number">3</span>))*<span class="hljs-number">3</span>)&#123;<br>           <span class="hljs-comment">// 如果actualPen.origin.x 小于 (MIN(i, 3))*3 那么说明该 pageC 的位置不是在 stackedViews 最顶部的三个以内</span><br>           [stackedViews addObject:pageC];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>           pageC.hidden = NO;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (self.scrollAnimationTimer == nil)<br>            <span class="hljs-comment">// floorf取整操作</span><br>            actualPen.origin.x = <span class="hljs-built_in">floorf</span>(actualPen.origin.x);<br>        <span class="hljs-comment">// 改变pageC.frame，那么pageC就会动了</span><br>        pageC.frame = actualPen;<br>   <br>        markedForSuperviewRemovalOffset += pen.size.width;<br>        <span class="hljs-comment">// NavVC 做 POP 操作的时候会将 markedForSuperviewRemoval 置为 YES</span><br>        <span class="hljs-comment">// 前面 pen.origin.x = -_actualOffset.x;</span><br>        <span class="hljs-comment">// 这里计算下一个屏幕的位置 frame 的 x 值</span><br>        <span class="hljs-comment">// 所以需要加上 pen.size.width</span><br>        <span class="hljs-keyword">if</span> (!pageC.markedForSuperviewRemoval)<br>            pen.origin.x += pen.size.width;<br>        <br>        <span class="hljs-comment">// 覆盖不透明度</span><br>        <span class="hljs-keyword">if</span> (actualPen.origin.x &lt;= <span class="hljs-number">0</span> &amp;&amp; pageC != [self.subviews lastObject]) &#123;<br>            <span class="hljs-comment">// abs()绝对值函数</span><br>            pageC.overlayOpacity = <span class="hljs-number">0.3</span>/actualPen.size.width*<span class="hljs-built_in">abs</span>(actualPen.origin.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pageC.overlayOpacity = <span class="hljs-number">0.0</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br>    <br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (NSInteger index = <span class="hljs-number">0</span>; index &lt; [stackedViews count]; index++)<br>    &#123;<br>        SPStackedPageContainer *pageC = stackedViews[index];<br>        <span class="hljs-comment">// stackedViews 包括 RootVC 的 View;</span><br>        <span class="hljs-comment">// stackedViews 里面的最后3个 View 显示</span><br>        <span class="hljs-keyword">if</span> ([stackedViews count] &gt; <span class="hljs-number">3</span> &amp;&amp; index &lt; ([stackedViews count]<span class="hljs-number">-3</span>))<br>            pageC.hidden = YES;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 左边是一个 stackedViews，最多有3层边缘层叠效果</span><br>            pageC.hidden = NO;<br>            CGRect frame = pageC.frame;<br>            <span class="hljs-comment">// 调整坐标，显示层叠效果</span><br>            frame.origin.x = <span class="hljs-number">0</span> + <span class="hljs-built_in">MIN</span>(i, <span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;<br>            pageC.frame = frame;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Only make sure we show what we need to, don&#x27;t unload stuff until we&#x27;re done animating</span><br>    [self updateContainerVisibilityByShowing:YES byHiding:NO];<br>&#125;<br></code></pre></td></tr></table></figure><p>在 layoutSubviews 方法里面 根据 _actualOffset 计算好每个分屏的 frame ，以及哪些分屏是可以显示在屏幕上的，哪些分屏是需要移除的，哪些分屏的位置是在屏幕显示的分屏的左边，哪些分屏的位置是在屏幕显示的分屏的右边。</p><p>在layoutSubviews 方法里面调用了一个方法用于控制分屏 View 的显示与隐藏，在这里分屏 View的概念可以等同于SPStackedPageContainer。这个方法是 - (void)updateContainerVisibilityByShowing:(BOOL)doShow byHiding:(BOOL)doHide 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)updateContainerVisibilityByShowing:(BOOL)doShow byHiding:(BOOL)doHide<br>&#123;<br>    <span class="hljs-comment">// fabsf 浮点数的绝对值</span><br>    <span class="hljs-comment">// 分屏 View 是否需要弹跳效果</span><br>    BOOL bouncing = self.scrollAnimationTimer &amp;&amp; <span class="hljs-built_in">fabsf</span>(_targetOffset.x - _actualOffset.x) &lt; <span class="hljs-number">30</span>;<br>    <br>    <span class="hljs-comment">// layoutSubViews的 pen 是一个 frame、</span><br>    <span class="hljs-comment">// 这里的 pen 是一个 frame 的 x 坐标</span><br>    <span class="hljs-comment">// 但是用法和 layoutSubViews 的 pen 没什么区别</span><br>    CGFloat pen = -_actualOffset.x;<br>    <br>    <span class="hljs-comment">// stretch scroll at start and end</span><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &lt; <span class="hljs-number">0</span>)<br>        pen = -_actualOffset.x/<span class="hljs-number">2</span>;<br>    <br>    CGFloat maxScroll = [self scrollOffsetForAligningPageWithRightEdge:self.subviews.lastObject];<br><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &gt; maxScroll)<br>        pen = -(maxScroll + (_actualOffset.x-maxScroll)/<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 用来让 SuperView 移动 pageC 的 x 坐标，原点是屏幕显示的最左边的分屏的 X 坐标</span><br>    CGFloat markedForSuperviewRemovalOffset = pen;<br>    <br>    NSMutableArray *viewsToDelete = [NSMutableArray array];<br>    <span class="hljs-keyword">for</span>(SPStackedPageContainer *pageC in self.subviews) &#123;<br>        CGFloat currentPen = pen;<br>        <span class="hljs-comment">// 该 pageC 被做了 POP 操作，需要被 SuperView移除</span><br>        <span class="hljs-keyword">if</span> (pageC.markedForSuperviewRemoval)<br>            currentPen = markedForSuperviewRemovalOffset;<br>        <span class="hljs-comment">// 该分屏是否是在屏幕可见的分屏的右边同时无法看见该分屏</span><br>        BOOL isOffScreenToTheRight = currentPen &gt;= self.bounds.size.width;<br><br>        NSRange scrollRange = [self scrollRangeForPageContainer:pageC];<br>        <span class="hljs-comment">// View 是否被其他 View 覆盖了</span><br>        BOOL isCovered = currentPen + scrollRange.length &lt;= <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// View 现在是否可见</span><br>        BOOL isVisible = !isOffScreenToTheRight &amp;&amp; !isCovered;<br>        <br><br>        <span class="hljs-comment">// pageC 的可见性发生变化 &amp;&amp; （ (isVisible == NO  &amp;&amp; doHide == Yes)  ||  isVisible == Yes &amp;&amp; doShow ==Yes）</span><br>        <span class="hljs-comment">// 只要 pageC 的可见性发生变化，不管是隐藏还是显示都执行下面的if条件分支</span><br>        <span class="hljs-keyword">if</span> (pageC.VCVisible != isVisible &amp;&amp; ((!isVisible &amp;&amp; doHide) || (isVisible &amp;&amp; doShow)))<br>        &#123;<br>            <br>            <span class="hljs-comment">// pageC分屏将出现</span><br>            <span class="hljs-comment">// pageC分屏将离开屏幕</span><br>            <span class="hljs-comment">//(isVisible == No || bouncing == No || (isVisible ==Yes &amp;&amp; needsInitialPresentation == Yes))</span><br>            <span class="hljs-keyword">if</span> (!isVisible || !bouncing || (isVisible &amp;&amp; pageC.needsInitialPresentation)) &#123;<br>                pageC.needsInitialPresentation = NO;<br>                pageC.VCVisible = isVisible;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 要隐藏 pageC 并且该 pageC 被标记为销毁的</span><br>        <span class="hljs-comment">//(doHide ==Yes &amp;&amp; pageC.markedForSuperviewRemoval ==Yes)</span><br>        <span class="hljs-comment">// 将 pageC 加入销毁数组 viewsToDelete</span><br>        <span class="hljs-keyword">if</span> (doHide &amp;&amp; pageC.markedForSuperviewRemoval)<br>            [viewsToDelete addObject:pageC];<br>        <br>        <span class="hljs-comment">//经过 Demo 验证 pen 和 markedForSuperviewRemovalOffset 的值一样</span><br>        markedForSuperviewRemovalOffset += pageC.frame.size.width;<br>        <br>        <span class="hljs-comment">// markedForSuperviewRemoval = No</span><br>        <span class="hljs-comment">// 计算 pen 的值，该值为下一个分屏的 X 坐标</span><br>        <span class="hljs-keyword">if</span> (!pageC.markedForSuperviewRemoval)<br>            pen += pageC.frame.size.width;<br>    &#125;<br>    <span class="hljs-comment">// 对viewsToDelete数组里面的View执行销毁操作</span><br>    [viewsToDelete makeObjectsPerformSelector:@<span class="hljs-built_in">selector</span>(removeFromSuperview)];<br>&#125;<br></code></pre></td></tr></table></figure><p>限于篇幅关系无法一一介绍SPStackedNavigationScrollView 的各种实现。<br>未介绍的细节知识点包括但不限于 NSRunLoop，用于 SPStackedNavigationScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。SPStackedNavigationScrollView 的 scrollRange 的计算细节，SPStackedNavigationScrollView 的手势处理等等，大家若是有兴趣可以在我的 <a href="https://github.com/junbinchencn/SPStackedNav-Note">GitHub</a> 上下载对应注释版本源码,地址 <a href="https://github.com/junbinchencn/SPStackedNav-Note">https://github.com/junbinchencn/SPStackedNav-Note</a> 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SPStackedNav 项目是一个用于 iPad 分屏的 UI 解决方案。该方案的核心在于 SPStackedNavigationScrollView 这个类。SPStackedNavigationScrollView 模仿了 UIScrollView 的实现。SPStackedNav 的分屏方案的设计非常精巧，实现思路清晰明确，实现过程中的很多细节还是非常具有参考和学习价值的，一些 contentOffset 的计算方法还是非常巧妙的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>理解 Scroll Views <a href="https://www.objccn.io/issue-3-2/">https://www.objccn.io/issue-3-2/</a><br>SPStackedNav <a href="https://github.com/spotify/SPStackedNav">https://github.com/spotify/SPStackedNav</a><br>SPStackedNav-Note <a href="https://github.com/junbinchencn/SPStackedNav-Note">https://github.com/junbinchencn/SPStackedNav-Note</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 模型框架- Mantle 解读</title>
    <link href="/2016/11/04/reading-source-code-of-Mantle/"/>
    <url>/2016/11/04/reading-source-code-of-Mantle/</url>
    
    <content type="html"><![CDATA[<h1 id="Mantle-解读"><a href="#Mantle-解读" class="headerlink" title="Mantle 解读"></a>Mantle 解读</h1><p><a href="https://github.com/Mantle/Mantle/">Mantle</a> 是由 Github 开发一款模型框架，Mantle 的主要作用在于让开发者更简单的构建应用的 model 层。本文主要介绍 Mantle 中最常使用的 JSON 功能–字典转模型。</p><h3 id="Mantle-的使用"><a href="#Mantle-的使用" class="headerlink" title="Mantle 的使用"></a>Mantle 的使用</h3><p>先以知乎的一个 <a href="http://news-at.zhihu.com/api/4/news/latest">API</a> 为例，讲解如何使用 Mantle 为这个 API 构建 model 。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled.webp" class="" title="API的数据结构"><p>1.按照 Mantle 要求构建对应的 model，Mantle 要求所有的 Model 都要继承于 MTLModel 并实现 MTLJSONSerializing 协议</p><p>构建 ZhihuLatestNews model 对应返回的 JSONKeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled1.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled2.webp" class="" title="image"><p>构建 ZhihuStory model 对应 sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled3.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled4.webp" class="" title="image"><p>构建 ZhihuStory model 对应 top_sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled5.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled6.webp" class="" title="image"><p>2.将网络请求的结果使用 Manlte 转化成 model</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled7.webp" class="" title="image"><h3 id="Mantle的接口"><a href="#Mantle的接口" class="headerlink" title="Mantle的接口"></a>Mantle的接口</h3><p>Mantle 通过 MTLJSONAdapter 实现 字典和 model 之间的转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">ZhihuLatestNews *lateNews = [MTLJSONAdapter modelOfClass:ZhihuLatestNews.<span class="hljs-keyword">class</span> fromJSONDictionary:dict error:&amp;merror];<br></code></pre></td></tr></table></figure><h3 id="Mantle的核心操作步骤"><a href="#Mantle的核心操作步骤" class="headerlink" title="Mantle的核心操作步骤"></a>Mantle的核心操作步骤</h3><p>1.获取 model 的属性–&gt; JSONKeyPath 映射字典<br>2.获取 model 的属性列表<br>3.根据 model 的方法给网络请求中返回的 JSON 字典中的 value 做值类型转化操作<br>4.使用 KVC 把值赋给 model 的属性，完成操作</p><h3 id="Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程"><a href="#Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程" class="headerlink" title="Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程"></a>Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>| +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<span class="hljs-comment">// Mantle 调用入口</span><br>|   [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; initWithModelClass:]<span class="hljs-comment">// 创建 MTLJSONAdapter </span><br>|     +[ZhihuLatestNews JSONKeyPathsByPropertyKey]<span class="hljs-comment">// 获取 属性-&gt; JSONKeyPath 映射字典</span><br>|     +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|       +[ZhihuLatestNews enumeratePropertiesUsingBlock:]<br>|         +[ZhihuLatestNews storageBehaviorForPropertyWithKey:] <span class="hljs-comment">// 判断 model 的属性是否 Mantle 要求</span><br><br>| From: -[MTLJSONAdapter initWithModelClass:]<br>| +[MTLJSONAdapter valueTransformersForModelClass:] <span class="hljs-comment">//值转化</span><br>|   +[ZhihuLatestNews propertyKeys]<br>|   +[MTLJSONAdapter transformerForModelPropertiesOfClass:]<br><br>| From: +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<br>| [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; modelFromJSONDictionary:error:] <br>|   +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|   +[ZhihuLatestNews modelWithDictionary:error:] <span class="hljs-comment">//生成 model 对象</span><br>|     [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; initWithDictionary:error:]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; init]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; setDate:]<br>|   [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; validate:]<br>|     +[ZhihuLatestNews propertyKeys]<br><br></code></pre></td></tr></table></figure><h3 id="Mantle的源码解读"><a href="#Mantle的源码解读" class="headerlink" title="Mantle的源码解读"></a>Mantle的源码解读</h3><p>1.初始化 MTLJSONAdapter</p><p>MTLJSONAdapter 是 字典和 model 之间的适配器，将 JSON 字典 转成应用的 model 对象</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled8.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>     <span class="hljs-comment">//初始化MTLJSONAdapter</span><br>MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];<br><br><span class="hljs-keyword">return</span> [adapter modelFromJSONDictionary:JSONDictionary error:error];<br>&#125;<br></code></pre></td></tr></table></figure><p>2.initWithModelClass:(Class)modelClass 的作用是使用给定的 modelClass 初始化 MTLJSONAdapter</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled9.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)initWithModelClass:(Class)modelClass &#123;<br>  <br>    <span class="hljs-comment">//对modelClass进行判空操作</span><br><span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-comment">//是否实现MTLJSONSerializing协议的判断，对是否继承了MTLModel进行确认</span><br><span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br><br>self = [super init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br><br>    <span class="hljs-comment">//使用变量保存modelClass，以便后续使用</span><br>     _modelClass = modelClass;<br><br>    <span class="hljs-comment">//获取属性值和JSONKeyPaths的映射字典，并使用_JSONKeyPathsByPropertyKey保存</span><br>    <span class="hljs-comment">//JSONKeyPathsByPropertyKey 是 MTLJSONSerializing 协议中定义的一个方法，在MTLModel的子类中实现</span><br>_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];<br><br>   <span class="hljs-comment">//获取 model 的属性，保存在propertyKeys变量中</span><br>   <span class="hljs-comment">//  **该方法后文有详细的实现解读**</span><br>NSSet *propertyKeys = [self.modelClass propertyKeys];<br><br>     <span class="hljs-comment">//判断 _JSONKeyPathsByPropertyKey 是否包含在 propertyKeys 里面,</span><br>     <span class="hljs-comment">//用来确认 _JSONKeyPathsByPropertyKey 里面的 key 都是 model 的属性</span><br><span class="hljs-keyword">for</span> (NSString *mappedPropertyKey in _JSONKeyPathsByPropertyKey) &#123;<br><span class="hljs-keyword">if</span> (![propertyKeys containsObject:mappedPropertyKey]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ is not a property of %@.&quot;</span>, mappedPropertyKey, modelClass);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>        <span class="hljs-comment">//根据 model 的属性 key 取出 JSONKeyPath</span><br>id value = _JSONKeyPathsByPropertyKey[mappedPropertyKey];<br>        <span class="hljs-comment">//TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？在文章末尾说明1</span><br><span class="hljs-keyword">if</span> ([value isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-keyword">for</span> (NSString *keyPath in value) &#123;<br><span class="hljs-keyword">if</span> ([keyPath isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>, mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (![value isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>,mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//获取 model 属性的 valueTransformers 用于做类型转化</span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>_valueTransformersByPropertyKey = [self.<span class="hljs-keyword">class</span> valueTransformersForModelClass:modelClass];<br>    <span class="hljs-comment">//A new map table object which has strong references to the keys and values.</span><br>_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.MTLModel的propertyKeys类方法,该方法会返回一个包含 model 属性列表的 NSSet 数据，但是这个 NSSet 数据不包含 被 readonly 修饰的属性，没有 ivars 变量的属性，以及 MTLModel 类自身的属性。除此之外的所有通过 @property 声明的属性都会存在 NSSet 数据中，</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled10.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/// Returns the keys for all @property declarations, except for `readonly`</span><br><span class="hljs-comment">/// properties without ivars, or properties on MTLModel itself.</span><br>+ (NSSet *)propertyKeys &#123;<br>    <span class="hljs-comment">// 判断 model 中 是否有属性列表的缓存，若有直接返回</span><br>NSSet *cachedKeys = <span class="hljs-built_in">objc_getAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey);<br><span class="hljs-keyword">if</span> (cachedKeys != nil) <span class="hljs-keyword">return</span> cachedKeys;<br><br>NSMutableSet *keys = [NSMutableSet set];<br>    <span class="hljs-comment">//遍历 model 所有的属性，判断哪些属性是符合要求的，加入 keys 变量中</span><br>   <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>[self enumeratePropertiesUsingBlock:^(<span class="hljs-type">objc_property_t</span> property, BOOL *stop) &#123;<br>        <span class="hljs-comment">//获取属性名字</span><br>NSString *key = @(<span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-comment">//判断哪些属性是可以做映射的，即不是 MTLPropertyStorageNone 的都可以做映射</span><br>        <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br><span class="hljs-keyword">if</span> ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;<br> [keys addObject:key];<br>&#125;<br>&#125;];<br><br><span class="hljs-comment">// It doesn&#x27;t really matter if we replace another thread&#x27;s work, since we do</span><br><span class="hljs-comment">// it atomically and the result should be the same.</span><br>    <span class="hljs-comment">// 给这个对象设置属性列表的缓存</span><br><span class="hljs-built_in">objc_setAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);<br><br><span class="hljs-keyword">return</span> keys;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.MTLModel 的enumeratePropertiesUsingBlock类方法，该方法用来遍历 model 的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (<span class="hljs-type">void</span>)enumeratePropertiesUsingBlock:(<span class="hljs-built_in">void</span> (^)(<span class="hljs-type">objc_property_t</span> property, BOOL *stop))block &#123;<br>Class cls = self;<br>BOOL stop = NO;<br>    <span class="hljs-comment">//按 mode l的继承层级，遍历 model 的属性</span><br><span class="hljs-keyword">while</span> (!stop &amp;&amp; ![cls isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-type">unsigned</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取属性列表</span><br><span class="hljs-type">objc_property_t</span> *properties = <span class="hljs-built_in">class_copyPropertyList</span>(cls, &amp;count);<br>cls = cls.superclass;<br><span class="hljs-keyword">if</span> (properties == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(properties);<br>&#125;;<br>        <span class="hljs-comment">//block回调</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br><span class="hljs-built_in">block</span>(properties[i], &amp;stop);<br><span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.MTLModel 的 storageBehaviorForPropertyWithKey 类方法，用于判断 model 的属性是否可以用来做转化</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled11.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;<br>    <span class="hljs-comment">//根据属性名获取属性的相关内容</span><br><span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(self.<span class="hljs-keyword">class</span>, propertyKey.UTF8String);<br><span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>  <span class="hljs-comment">//将属性的 runtime 表示方法 转成 Mantle 的表示方法</span><br>  <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(attributes);<br>&#125;;<br>  <span class="hljs-comment">//是否有 setter 和 getter 方法</span><br>BOOL hasGetter = [self instancesRespondToSelector:attributes-&gt;getter];<br>BOOL hasSetter = [self instancesRespondToSelector:attributes-&gt;setter]; <br><span class="hljs-keyword">if</span> (!attributes-&gt;dynamic &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span> &amp;&amp; !hasGetter &amp;&amp; !hasSetter) &#123;<br>        <span class="hljs-comment">// attributes 不是 dynamic ( @dynamic 就是要来告诉编译器，代码中用 @dynamic 修饰的属性，其 getter 和 setter 方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译)</span><br>        <span class="hljs-comment">// attributes-&gt;ivar 为空</span><br>        <span class="hljs-comment">//没有 getter 方法</span><br>        <span class="hljs-comment">//没有 setter 方法</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attributes-&gt;readonly &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">//attributes 是 readonly</span><br>        <span class="hljs-comment">//attributes-&gt;ivar 变量为空</span><br><span class="hljs-keyword">if</span> ([self isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br>            <span class="hljs-comment">//是否是 MTLModel 的属性</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check superclass in case the subclass redeclares a property that</span><br><span class="hljs-comment">// falls through</span><br>            <span class="hljs-comment">// 检查一下超类属性，防止超类属性被子类重新声明</span><br><span class="hljs-keyword">return</span> [self.superclass storageBehaviorForPropertyWithKey:propertyKey];<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> MTLPropertyStoragePermanent;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.EXTRuntimeExtensions 的 mtl_copyPropertyAttributes 方法，作用是将属性的runtime表示形式转成更好理解的 Mantle 表示形式。该方法比较枯燥无味且相对来说难以理解，可以略过，不影响 Mantle 解读。<br>该方法需要结合苹果的官方<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a>开发文档再进行单步调试才能更好的理解。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled12.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//以属性date为例,说明整个转化过程，具体的信息可以参考苹果官方的 runtime 文档</span><br><span class="hljs-comment">// @property (nonatomic,strong) NSString *date </span><br><br><span class="hljs-function">mtl_propertyAttributes *<span class="hljs-title">mtl_copyPropertyAttributes</span> <span class="hljs-params">(<span class="hljs-type">objc_property_t</span> property)</span> </span>&#123;<br>    <span class="hljs-comment">//The string starts with a T followed by the @encode type and a comma(逗号), and finishes with a V followed by the name of the backing instance variable.</span><br>    <span class="hljs-comment">//属性 date 的 runtime 表示形式为 &quot;T@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> attrString = <span class="hljs-built_in">property_getAttributes</span>(property);<br>    <span class="hljs-keyword">if</span> (!attrString) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not get attribute string from property %s\n&quot;</span>, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//必须以 T 开头</span><br>    <span class="hljs-keyword">if</span> (attrString[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;T&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Expected attribute string \&quot;%s\&quot; for property %s to start with &#x27;T&#x27;\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//去掉 T 变成 &quot;@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *typeString = attrString + <span class="hljs-number">1</span>;<span class="hljs-comment">//attrString代表字符串的起始地址，地址加1表示字符串截取</span><br><br>    <span class="hljs-comment">// Obtains the actual size and the aligned size of an encoded type.</span><br>    <span class="hljs-comment">// 去掉 @encode 字符串 变成 &quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *next = <span class="hljs-built_in">NSGetSizeAndAlignment</span>(typeString, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!next) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read past type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   <span class="hljs-comment">// 以属性 date 为例差11个字符</span><br>    <span class="hljs-type">size_t</span> typeLength = next - typeString;<br>    <span class="hljs-keyword">if</span> (!typeLength) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Invalid type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// allocate enough space for the structure and the type string (plus a NUL)</span><br>    <span class="hljs-comment">// 将propertyAttributes变成mtl_propertyAttributes类型</span><br>    <span class="hljs-comment">// TODO 长度的计算？为什么是这样计算？</span><br>    mtl_propertyAttributes *attributes = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(mtl_propertyAttributes) + typeLength + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!attributes) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not allocate mtl_propertyAttributes structure for attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the type string</span><br>    <span class="hljs-comment">// 复制属性的类型</span><br>    <span class="hljs-built_in">strncpy</span>(attributes-&gt;type, typeString, typeLength);<br>    attributes-&gt;type[typeLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//字符串结尾</span><br><br>    <span class="hljs-comment">// if this is an object type, and immediately followed by a quoted string...</span><br>    <span class="hljs-keyword">if</span> (typeString[<span class="hljs-number">0</span>] == *(@<span class="hljs-built_in">encode</span>(id)) &amp;&amp; typeString[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;<br>        <span class="hljs-comment">// we should be able to extract a class name</span><br>        <span class="hljs-comment">// &quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *className = typeString + <span class="hljs-number">2</span>;<span class="hljs-comment">//字符串截取</span><br><br>        <span class="hljs-comment">//extern char *strchr(const char *s,char c);查找字符串s中首次出现字符c的位置。</span><br>        <span class="hljs-comment">//&quot;\&quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(className, <span class="hljs-string">&#x27;&quot;&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (!next) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read class name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (className != next) &#123;<br>            <span class="hljs-comment">// 通过内存地址相减 0x0000000104f0347e((const char *) next) - 0x0000000104f03476((const char *) className) = 8</span><br>            <span class="hljs-type">size_t</span> classNameLength = next - className;<br>            <span class="hljs-type">char</span> trimmedName[classNameLength + <span class="hljs-number">1</span>];<span class="hljs-comment">//创建用于存放属性类型的数组</span><br><br>            <span class="hljs-built_in">strncpy</span>(trimmedName, className, classNameLength);<span class="hljs-comment">//复制属性类型到trimmedName</span><br>            trimmedName[classNameLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//数组末尾结束符号</span><br><br>            <span class="hljs-comment">// attempt to look up the class in the runtime</span><br>            attributes-&gt;objectClass = <span class="hljs-built_in">objc_getClass</span>(trimmedName);<span class="hljs-comment">//设置属性类型</span><br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">// &quot;\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-keyword">if</span> (*next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-comment">// skip past any junk before the first flag</span><br>        <span class="hljs-comment">// &quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (next &amp;&amp; *next == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-comment">//第一次循环 &amp;</span><br>        <span class="hljs-comment">//第一次循环 N</span><br>        <span class="hljs-comment">//第一次循环 V</span><br>        <span class="hljs-type">char</span> flag = next[<span class="hljs-number">1</span>];<br>        next += <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">switch</span> (flag) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>            <span class="hljs-comment">//The property is read-only (readonly).</span><br>            attributes-&gt;readonly = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            <span class="hljs-comment">//The property is a copy of the value last assigned (copy).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyCopy;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;&#x27;</span>:<br>            <span class="hljs-comment">//The property is a reference to the value last assigned (retain).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyRetain;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:<br>            <span class="hljs-comment">//The property is non-atomic (nonatomic).</span><br>            attributes-&gt;nonatomic = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).</span><br>            &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *nextFlag = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>                SEL name = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-keyword">if</span> (!nextFlag) &#123;<br>                    <span class="hljs-comment">// assume that the rest of the string is the selector</span><br>                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *selectorString = next;<br>                    next = <span class="hljs-string">&quot;&quot;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">size_t</span> selectorLength = nextFlag - next;<br>                    <span class="hljs-keyword">if</span> (!selectorLength) &#123;<br>                        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Found zero length selector name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>                        <span class="hljs-keyword">goto</span> errorOut;<br>                    &#125;<br><br>                    <span class="hljs-type">char</span> selectorString[selectorLength + <span class="hljs-number">1</span>];<br><br>                    <span class="hljs-built_in">strncpy</span>(selectorString, next, selectorLength);<br>                    selectorString[selectorLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                    next = nextFlag;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&#x27;G&#x27;</span>)<br>                    attributes-&gt;getter = name;<br>                <span class="hljs-keyword">else</span><br>                    attributes-&gt;setter = name;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>            <span class="hljs-comment">//The property is dynamic (@dynamic).</span><br>            attributes-&gt;dynamic = YES;<br>            attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:<br>            <span class="hljs-comment">// assume that the rest of the string (if present) is the ivar name</span><br>            <span class="hljs-comment">// V 之后的是变量名称</span><br>            <span class="hljs-keyword">if</span> (*next == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>                <span class="hljs-comment">// if there&#x27;s nothing there, let&#x27;s assume this is dynamic</span><br>                attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//取得变量名称</span><br>                attributes-&gt;ivar = next;<br>                next = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>             <span class="hljs-comment">//The property is a weak reference (__weak).</span><br>            attributes-&gt;weak = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;P&#x27;</span>:<br>            <span class="hljs-comment">//The property is eligible for garbage collection.</span><br>            attributes-&gt;canBeCollected = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Old-style type encoding is unsupported in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br><br>            <span class="hljs-comment">// skip over this type encoding</span><br>            <span class="hljs-keyword">while</span> (*next != <span class="hljs-string">&#x27;,&#x27;</span> &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                ++next;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Unrecognized attribute string flag &#x27;%c&#x27; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, flag, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Warning: Unparsed data \&quot;%s\&quot; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, next, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;getter) &#123;<br>        <span class="hljs-comment">// use the property name as the getter by default</span><br>        <span class="hljs-comment">//使用默认的 getter 方法</span><br>        attributes-&gt;getter = <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;setter) &#123;<br>        <span class="hljs-comment">//使用默认的 setter 方法</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propertyName = <span class="hljs-built_in">property_getName</span>(property);<br>        <span class="hljs-type">size_t</span> propertyNameLength = <span class="hljs-built_in">strlen</span>(propertyName);<br><br>        <span class="hljs-comment">// we want to transform the name to setProperty: style</span><br>        <span class="hljs-type">size_t</span> setterLength = propertyNameLength + <span class="hljs-number">4</span>;<br><br>        <span class="hljs-type">char</span> setterName[setterLength + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strncpy</span>(setterName, <span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">strncpy</span>(setterName + <span class="hljs-number">3</span>, propertyName, propertyNameLength);<br><br>        <span class="hljs-comment">// capitalize property name for the setter</span><br>        setterName[<span class="hljs-number">3</span>] = (<span class="hljs-type">char</span>)<span class="hljs-built_in">toupper</span>(setterName[<span class="hljs-number">3</span>]);<br><br>        setterName[setterLength - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;:&#x27;</span>;<br>        setterName[setterLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        attributes-&gt;setter = <span class="hljs-built_in">sel_registerName</span>(setterName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> attributes;<br><br>errorOut:<br>    <span class="hljs-built_in">free</span>(attributes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.在获取了 Mantle 需要的属性之后，接下来就需要做一些转化操作了。MTLJSONAdapter 的类方法 valueTransformersForModelClass 主要是将 JSONKeyPath 的值转成 model 的属性声明的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//对值做类型转化,值类型的转化方法由 model 提供</span><br>+ (NSDictionary *)valueTransformersForModelClass:(Class)modelClass &#123;<br>    <span class="hljs-comment">//基本判断</span><br>    <span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br>    NSMutableDictionary *result = [NSMutableDictionary dictionary];<br>    <br>    <span class="hljs-comment">//依次为每个属性拼接值类型转化方法并判断 model 是否实现了该方法</span><br>    <span class="hljs-keyword">for</span> (NSString *key in [modelClass propertyKeys]) &#123;<br>   <br>        <span class="hljs-comment">// 1、判断 model 是否实现了 +&lt;key&gt;JSONTransformer 类型方法</span><br>        SEL selector = <span class="hljs-built_in">MTLSelectorWithKeyPattern</span>(key, <span class="hljs-string">&quot;JSONTransformer&quot;</span>);<br>        <span class="hljs-comment">//判断是否有实现该方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:selector]) &#123;<br>            <span class="hljs-comment">//取得该方法的实现，调用该方法并获取该方法的返回值</span><br>            IMP imp = [modelClass methodForSelector:selector];<br>            NSValueTransformer * (*function)(id, SEL) = (__typeof__(function))imp;<br>            NSValueTransformer *transformer = <span class="hljs-built_in">function</span>(modelClass, selector);<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、判断 model 是否实现了 +JSONTransformerForKey: 类型方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(JSONTransformerForKey:)]) &#123;<br>            NSValueTransformer *transformer = [modelClass JSONTransformerForKey:key];<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(modelClass, key.UTF8String);<br>        <span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>       <span class="hljs-comment">//将属性的runtime 表示形式 转成 Mantle 的表示形式</span><br>        mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>        @onExit &#123;<br>            <span class="hljs-built_in">free</span>(attributes);<br>        &#125;;<br>      <span class="hljs-comment">//3、其他值类型转化</span><br>        NSValueTransformer *transformer = nil;<br>        <span class="hljs-keyword">if</span> (*(attributes-&gt;type) == *(@<span class="hljs-built_in">encode</span>(id))) &#123;<br>            Class propertyClass = attributes-&gt;objectClass;<br>            <span class="hljs-keyword">if</span> (propertyClass != nil) &#123;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                <span class="hljs-comment">//如果是对象类型，那么取出类型转化的 NSValueTransformer 对象</span><br>                transformer = [self transformerForModelPropertiesOfClass:propertyClass];<br>            &#125;<br>             <span class="hljs-comment">//用于做属性的值类型转换</span><br>            <span class="hljs-keyword">if</span> (transformer == nil) transformer = [NSValueTransformer mtl_validatingTransformerForClass:propertyClass ?: NSObject.<span class="hljs-keyword">class</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//区分BOOL类型</span><br>            transformer = [self transformerForModelPropertiesOfObjCType:attributes-&gt;type] ?: [NSValueTransformer mtl_validatingTransformerForClass:NSValue.<span class="hljs-keyword">class</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 方法完成字典转成 model 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>    <span class="hljs-comment">//判断是否实现 classForParsingJSONDictionary: 协议</span><br>    <span class="hljs-keyword">if</span> ([self.modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(classForParsingJSONDictionary:)]) &#123;<br>        <span class="hljs-comment">//获取Class</span><br>        Class <span class="hljs-keyword">class</span> = [self.modelClass classForParsingJSONDictionary:JSONDictionary];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> == nil) &#123;<br>            <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">//错误处理</span><br>                NSDictionary *userInfo = @&#123;<br>                    NSLocalizedDescriptionKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;Could not parse JSON&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>),<br>                    NSLocalizedFailureReasonErrorKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;No model class could be found to parse the JSON dictionary.&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>)<br>                &#125;;<br>                *error = [NSError errorWithDomain:MTLJSONAdapterErrorDomain code:MTLJSONAdapterErrorNoClassFound userInfo:userInfo];<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> != self.modelClass) &#123;<br>            <span class="hljs-comment">//实现协议判断</span><br>            <span class="hljs-built_in">NSAssert</span>([<span class="hljs-keyword">class</span> conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)], @<span class="hljs-string">&quot;Class %@ returned from +classForParsingJSONDictionary: does not conform to &lt;MTLJSONSerializing&gt;&quot;</span>, <span class="hljs-keyword">class</span>);<br><br>            MTLJSONAdapter *otherAdapter = [self JSONAdapterForModelClass:<span class="hljs-keyword">class</span> error:error];<br><br>            <span class="hljs-keyword">return</span> [otherAdapter modelFromJSONDictionary:JSONDictionary error:error];<br>        &#125;<br>    &#125;<br><br>    NSMutableDictionary *dictionaryValue = [[NSMutableDictionary alloc] initWithCapacity:JSONDictionary.count];<br>    <span class="hljs-comment">//取出 model 的属性 key</span><br>    <span class="hljs-keyword">for</span> (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;<br>        <span class="hljs-comment">//取出JSONKeyPath</span><br>        id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];<br><br>        <span class="hljs-keyword">if</span> (JSONKeyPaths == nil) <span class="hljs-keyword">continue</span>;<br><br>        id value;<br>        <span class="hljs-comment">//TODO 这个判断数组的用处？</span><br>        <span class="hljs-keyword">if</span> ([JSONKeyPaths isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br>            NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];<br>            <span class="hljs-keyword">for</span> (NSString *keyPath in JSONKeyPaths) &#123;<br>                BOOL success;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];<br>                <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                <span class="hljs-keyword">if</span> (value != nil) dictionary[keyPath] = value;<br>            &#125;<br>            value = dictionary;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            BOOL success;<br>           <span class="hljs-comment">//取出字典中JSONKeyPaths对应的值</span><br>           <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>            value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];<br>            <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value == nil) <span class="hljs-keyword">continue</span>;<br>        @<span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//取出值转化的 NSValueTransformer 对象，若是对象为空则说明该 propertyKey 不需要做值转化</span><br>            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];<br>            <span class="hljs-keyword">if</span> (transformer != nil) &#123;<br>                <span class="hljs-comment">// Map NSNull -&gt; nil for the transformer, and then back for the</span><br>                <span class="hljs-comment">// dictionary we&#x27;re going to insert into.</span><br>                <span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil;<br>                <span class="hljs-comment">//值转化操作</span><br>                <span class="hljs-keyword">if</span> ([transformer respondsToSelector:@<span class="hljs-built_in">selector</span>(transformedValue:success:error:)]) &#123;<br>                <span class="hljs-comment">//转化过程有回调 </span><br>                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;<br>                    BOOL success = YES;<br>                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];<br>                    <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不需要转化过程回调，直接转化</span><br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                    value = [transformer transformedValue:value];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (value == nil) value = NSNull.null;<br>            &#125;<br>            <span class="hljs-comment">// 保存被 NSValueTransformer 转化过的 JSONKeyPath 的值</span><br>            dictionaryValue[propertyKey] = value;<br>        &#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br>           <span class="hljs-comment">//省略错误处理代码</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;</span>, ex, JSONKeyPaths, JSONDictionary);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将字典转换成 model </span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>    id model = [self.modelClass modelWithDictionary:dictionaryValue error:error];<br>    <span class="hljs-comment">//进行错误验证</span><br>    <span class="hljs-keyword">return</span> [model validate:error] ? model : nil;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>9.NSDictionary+MTLJSONKeyPath 的 - (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error; 方法作用在于根据 JSONKeyPath 从 JSON 字典中取出对应的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error &#123;<br>    <span class="hljs-comment">//TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</span><br>NSArray *components = [JSONKeyPath componentsSeparatedByString:@<span class="hljs-string">&quot;.&quot;</span>];<br>id result = self;<span class="hljs-comment">//字典</span><br><span class="hljs-keyword">for</span> (NSString *component in components) &#123;<br><span class="hljs-comment">// Check the result before resolving the key path component to not</span><br><span class="hljs-comment">// affect the last value of the path.</span><br><span class="hljs-keyword">if</span> (result == nil || result == NSNull.null) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (![result isKindOfClass:NSDictionary.<span class="hljs-keyword">class</span>]) &#123;<br>                 <span class="hljs-comment">//错误处理代码</span><br>&#125;<br>        <span class="hljs-comment">//以JSONKeyPath为key取出JSON字典中的值</span><br>result = result[component];<br>&#125;<br><br><span class="hljs-keyword">if</span> (success != <span class="hljs-literal">NULL</span>) *success = YES;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>10.在取得了JSONKeyPath对应的 value 之后，那么下一步操作就是要根据 model 值转化方法返回的 NSValueTransformer 对象做值转化操作</p><p>MTLValueTransformer 是一个基于 block 操作的值转化对象，实现 JSON字典–&gt;model 的转化。而MTLReversibleValueTransformer<br>实现逆向转化操作。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled13.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>@implementation MTLValueTransformer<br><br><span class="hljs-comment">//转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.forwardBlock(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.forwardBlock(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br><br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br><br><span class="hljs-comment">//反向转化 model --&gt; JSON 字典</span><br>@implementation MTLReversibleValueTransformer<br><span class="hljs-comment">//反向转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现反向转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br>    <br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>11.在处理的值转化之后，那么接下来就是要将从 JSON 字典中获取的 model 属性值赋值给对应的 model 对象了。在 MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 的实现中的最后一部分代码就是用来生成对应的 model 对象的。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled14.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//MTLModel  代码片段</span><br><br><span class="hljs-comment">//使用字典初始化 model </span><br>+ (instancetype)modelWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br><span class="hljs-keyword">return</span> [[self alloc] initWithDictionary:dictionary error:error];<br>&#125;<br>......<br><span class="hljs-comment">//使用字典初始化 model </span><br>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br>self = [self init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br>       <span class="hljs-comment">//取出NSDictionary的key</span><br><span class="hljs-keyword">for</span> (NSString *key in dictionary) &#123;<br><span class="hljs-comment">// Mark this as being autoreleased, because validateValue may return</span><br><span class="hljs-comment">// a new object to be stored in this variable (and we don&#x27;t want ARC to</span><br><span class="hljs-comment">// double-free or leak the old or new values).</span><br>__autoreleasing id value = [dictionary objectForKey:key];<br><span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil; <br>        <span class="hljs-comment">//判断 model 的这个属性是否可以采用 KVC 来给属性赋值</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, YES, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>&#125;<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br><br><br><span class="hljs-comment">//判断 model 的某个属性是否可以采用 KVC 来给属性赋值，然后根据赋值条件给予赋值</span><br><span class="hljs-function"><span class="hljs-type">static</span> BOOL <span class="hljs-title">MTLValidateAndSetValue</span><span class="hljs-params">(id obj, NSString *key, id value, BOOL forceUpdate, NSError **error)</span> </span>&#123;<br>__autoreleasing id validatedValue = value;<br>@<span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当开发者需要验证能不能用KVC设定某个值时，可以调用validateValue: forKey:这个方法来验证</span><br>        <span class="hljs-comment">// 这个方法的默认实现是去类里面寻找是否有一个这样的方法：-(BOOL)validate&lt;Key&gt;:error:</span><br>        <span class="hljs-comment">// 如果有这个方法，就以这个方法的返回值作为判断标准，没有的话就直接返回YES</span><br><span class="hljs-keyword">if</span> (![obj validateValue:&amp;validatedValue forKey:key error:error]) <span class="hljs-keyword">return</span> NO;<br>        <span class="hljs-comment">// 设置新值</span><br>        <span class="hljs-comment">// obj 返回的 validatedValue 与 传进来的参数 value 进行对比，若不一致采用validatedValue的值</span><br>        <span class="hljs-comment">// forceUpdate 为 YES 那么也是直接给 key 设置值</span><br><span class="hljs-keyword">if</span> (forceUpdate || value != validatedValue) &#123;<br>[obj setValue:validatedValue forKey:key];<br>&#125;<br><span class="hljs-keyword">return</span> YES;<br>&#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br><span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception setting key \&quot;%@\&quot; : %@&quot;</span>, key, ex);<br><span class="hljs-comment">//错误处理代码</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// model 的属性验证，只做验证处理，不做赋值操作</span><br>- (BOOL)validate:(NSError **)error &#123;<br><span class="hljs-keyword">for</span> (NSString *key in self.<span class="hljs-keyword">class</span>.propertyKeys) &#123;<br>id value = [self valueForKey:key];<br>        <span class="hljs-comment">//验证 model 是否有某个属性不能使用 KVC 赋值，若是有属性无法通过 KVC 赋值那么返回 NO。 此时 JSON 字典 --&gt; model 过程会得到一个 nil 对象，model 转化失败</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, NO, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br><span class="hljs-keyword">return</span> YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>12.Mantle完成最后的 model 属性验证之后，返回相关的 model 对象。至此 Mantle 的 JSON 字典 –&gt; model 过程就完成了。</p><p>13.TODO 的应用场景说明<br> 在文中有 2 个 TODO  说明，限于篇幅统一放在这里说明。可以搜索 TODO 关键字找到文章做 TODO 标记文职<br>&#x2F;&#x2F; TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                               @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span><br>                          &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下可能想把 temp 和 temp_max 放到一个字典当中。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSDictionary *temp;<br><br>@end<br><span class="hljs-comment">// temp 和 temp_max 放到一个字典当中 ,那么 JSONKeyPathsByPropertyKey 方法做如下实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:[NSArray arrayWithObjects:@<span class="hljs-string">&quot;temp&quot;</span>, @<span class="hljs-string">&quot;temp_max&quot;</span>,nil]<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;weather&quot;</span>:@&#123;<br>                                       @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_min&quot;</span> : @<span class="hljs-string">&quot;53.01&quot;</span><br>                                       &#125;<br>                               &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法会再给 TestModel 新建一个名为 weather 的对象属性</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) Weather *weather;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下并不想给 TestModel 新建对象属性，而是把 JSON 字典中所有层级的 JSONKeyPath 都放到第一层级来。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_min;<br>@end<br><span class="hljs-comment">//JSON 字典中所有层级的 JSONKeyPath 都放到第一层级,那么 JSONKeyPathsByPropertyKey 方法需要做好对应的层级关系实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:@<span class="hljs-string">&quot;weather.temp&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_max&quot;</span>:@<span class="hljs-string">&quot;weather.temp_max&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_min&quot;</span>:@<span class="hljs-string">&quot;weather.temp_min&quot;</span>,<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mantle 作为一款经典的 JSON 字典 &lt;–&gt; model 转化模型框架，主要是利用 KVC 特性为 model 赋值,其框架设计有不少优点，比如值转化过程的设计等，阅读优秀的开源项目不仅可以扩大技术眼界，也可以增加对代码细节的把控能力。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://github.com/Mantle/Mantle">https://github.com/Mantle/Mantle</a><br><a href="http://southpeak.github.io/2015/01/11/sourcecode-mantle/">http://southpeak.github.io/2015/01/11/sourcecode-mantle/</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a><br><a href="http://www.jianshu.com/p/f49ddbf8a2ea">http://www.jianshu.com/p/f49ddbf8a2ea</a><br><a href="http://www.jianshu.com/p/9f039124efef">http://www.jianshu.com/p/9f039124efef</a><br><a href="https://github.com/johnno1962/Xtrace">https://github.com/johnno1962/Xtrace</a><br><a href="http://nshipster.com/nsvaluetransformer/">http://nshipster.com/nsvaluetransformer/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS GIF 动画加载框架 - FLAnimatedImage 解读</title>
    <link href="/2016/08/31/reading-source-code-of-FLAnimatedImage/"/>
    <url>/2016/08/31/reading-source-code-of-FLAnimatedImage/</url>
    
    <content type="html"><![CDATA[<h1 id="FLAnimatedImage-解读"><a href="#FLAnimatedImage-解读" class="headerlink" title="FLAnimatedImage 解读"></a>FLAnimatedImage 解读</h1><p><a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> 是由Flipboard开源的iOS平台上播放GIF动画的一个优秀解决方案，在内存占用和播放体验都有不错的表现。<br>本文章主要是介绍FLAnimatedImage框架的GIF动画加载和播放流程，旨在说明流程和主要细节点，大家可以参考流程进行源码解读并调试，相信可以得到大量有用信息。<br>文章不免有不足或者错误之处，请大家在下方评论指出，我会尽快修正 l-(&gt;-&lt;)-l 。</p><h3 id="FLAnimatedImage简单流程图"><a href="#FLAnimatedImage简单流程图" class="headerlink" title="FLAnimatedImage简单流程图"></a>FLAnimatedImage简单流程图</h3><p>FLAnimatedImage项目的流程比较简单，FLAnimatedImage就是负责GIF数据的处理，然后提供给FLAnimatedImageView一个UIImage对象。FLAnimatedImageView拿到UIImage对象显示出来就可以了。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage使用"><a href="#FLAnimatedImage使用" class="headerlink" title="FLAnimatedImage使用"></a>FLAnimatedImage使用</h3><p>使用FLAnimatedImage处理GIF动画数据，使用FLAnimatedImageView展示FLAnimatedImage处理后的动画数据。</p><ul><li><p>使用NSData初始化FLAnimatedImage,然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView1) &#123;<br>       self.imageView1 = [[FLAnimatedImageView alloc] init];<br>       self.imageView1.contentMode = UIViewContentModeScaleAspectFill;<br>       self.imageView1.clipsToBounds = YES;<br>   &#125;<br>   [self.view addSubview:self.imageView1];<br>   self.imageView1.frame = CGRectMake(0.0, 120.0, self.view.bounds.size.width, 447.0);   <br>   NSURL *url1 = [[NSBundle mainBundle] URLForResource:@&quot;rock&quot; withExtension:@&quot;gif&quot;];<br>   NSData *data1 = [NSData dataWithContentsOfURL:url1];<br>   FLAnimatedImage *animatedImage1 = [FLAnimatedImage animatedImageWithGIFData:data1];<br>   self.imageView1.animatedImage = animatedImage1;<br></code></pre></td></tr></table></figure></li><li><p>使用URL初始化FLAnimatedImage，然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView2) &#123;<br>    self.imageView2 = [[FLAnimatedImageView alloc] init];<br>    self.imageView2.contentMode = UIViewContentModeScaleAspectFill;<br>    self.imageView2.clipsToBounds = YES;<br>&#125;<br>[self.view addSubview:self.imageView2];<br>self.imageView2.frame = CGRectMake(0.0, 577.0, 379.0, 447.0);<br><br>NSURL *url2 = [NSURL URLWithString:@&quot;https://cloud.githubusercontent.com/assets/1567433/10417835/1c97e436-7052-11e5-8fb5-69373072a5a0.gif&quot;];<br>[self loadAnimatedImageWithURL:url2 completion:^(FLAnimatedImage *animatedImage) &#123;<br>    self.imageView2.animatedImage = animatedImage;<br>&#125;];<br></code></pre></td></tr></table></figure></li></ul><h3 id="FLAnimatedImage项目代码结构"><a href="#FLAnimatedImage项目代码结构" class="headerlink" title="FLAnimatedImage项目代码结构"></a>FLAnimatedImage项目代码结构</h3><p> FLAnimatedImage项目采用了“生产者和消费者”模型来处理这个GIF动画的播放问题。一个线程负责生产数据，另一个线程负责消费数据。生产者FLAnimatedImage负责提供帧UIImage对象，消费者FLAnimatedImageView负责显示该UIImage对象。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled1.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage接口"><a href="#FLAnimatedImage接口" class="headerlink" title="FLAnimatedImage接口"></a>FLAnimatedImage接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">@property (nonatomic, strong, readonly) UIImage *posterImage;//GIF动画的封面帧图片<br>@property (nonatomic, assign, readonly) CGSize size; //GIF动画的封面帧图片的尺寸<br>@property (nonatomic, assign, readonly) NSUInteger loopCount; //GIF动画的循环播放次数<br>@property (nonatomic, strong, readonly) NSDictionary *delayTimesForIndexes; // GIF动画中的每帧图片的显示时间集合<br>@property (nonatomic, assign, readonly) NSUInteger frameCount; //GIF动画的帧数量<br>@property (nonatomic, assign, readonly) NSUInteger frameCacheSizeCurrent; //当前被缓存的帧图片的总数量<br>@property (nonatomic, assign) NSUInteger frameCacheSizeMax; // 允许缓存多少帧图片<br><br>// Intended to be called from main thread synchronously; will return immediately.<br>// If the result isn&#x27;t cached, will return `nil`; the caller should then pause playback, not increment frame counter and keep polling.<br>// After an initial loading time, depending on `frameCacheSize`, frames should be available immediately from the cache.<br>// 取出对应索引的帧图片<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index;<br><br>// Pass either a `UIImage` or an `FLAnimatedImage` and get back its size<br>// 计算该帧图片的尺寸<br>+ (CGSize)sizeForImage:(id)image;<br><br>// 初始化方法<br>// On success, the initializers return an `FLAnimatedImage` with all fields initialized, on failure they return `nil` and an error will be logged.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data;<br>// Pass 0 for optimalFrameCacheSize to get the default, predrawing is enabled by default.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled NS_DESIGNATED_INITIALIZER;<br>+ (instancetype)animatedImageWithGIFData:(NSData *)data;<br><br>//初始化数据<br>@property (nonatomic, strong, readonly) NSData *data; // The data the receiver was initialized with; read-only<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImage解析"><a href="#FLAnimatedImage解析" class="headerlink" title="FLAnimatedImage解析"></a>FLAnimatedImage解析</h3><ul><li>关键方法 初始化解析<br>a、对传进来的数据进行合法性判断，至少不能为nil。<br>b、初始化对应的变量，用于存储各类辅助数据。<br>c、将传进来的数据处理成图片数据，根据 kCGImageSourceShouldCache 的官方文档描述 <strong>Whether the image should be cached in a decoded form. The value of this key must be a CFBoolean value. The default value is kCFBooleanFalse in 32-bit, kCFBooleanTrue in 64-bit.</strong>  所以设置 kCGImageSourceShouldCache为NO,可以避免系统对图片进行缓存，<br>d、从数据中读取图片类型，判断该图片是不是GIF动画类型。<br>e、读取GIF动画中的动画信息，包括动画循环次数，有几帧图片等。<br>f、遍历GIF动画中的所有帧图片，取出并保存帧图片的播放信息，设置GIF动画的封面帧图片<br>g、根据设置或者GIF动画的占用内存大小，与缓存策略对比，确认缓存策略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled<br>&#123;<br>    // 1、进行数据合法性判断<br>    BOOL hasData = ([data length] &gt; 0);<br>    if (!hasData) &#123;<br>        FLLog(FLLogLevelError, @&quot;No animated GIF data supplied.&quot;);<br>        return nil;<br>    &#125;<br>    <br>    self = [super init];<br>    if (self) &#123;<br>        // 2、初始化对应的变量<br>        // Do one-time initializations of `readonly` properties directly to ivar to prevent implicit actions and avoid need for private `readwrite` property overrides.<br>        // Keep a strong reference to `data` and expose it read-only publicly.<br>        // However, we will use the `_imageSource` as handler to the image data throughout our life cycle.<br>        _data = data;<br>        _predrawingEnabled = isPredrawingEnabled;<br>        <br>        // Initialize internal data structures<br>        _cachedFramesForIndexes = [[NSMutableDictionary alloc] init];//key-&gt;帧图片在GIF动画的索引位置 value-&gt;单帧图片<br>        _cachedFrameIndexes = [[NSMutableIndexSet alloc] init];//缓存的帧图片在GIF动画的索引位置集合<br>        _requestedFrameIndexes = [[NSMutableIndexSet alloc] init];//需要生产者生产的的帧图片的索引位置<br><br>        // 3、创建图片数据<br>        // Note: We could leverage `CGImageSourceCreateWithURL` too to add a second initializer `-initWithAnimatedGIFContentsOfURL:`.<br>        _imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)data,<br>                                                   (__bridge CFDictionaryRef)@&#123;(NSString *)kCGImageSourceShouldCache: @NO&#125;);<br>        // Early return on failure!<br>        if (!_imageSource) &#123;<br>            FLLog(FLLogLevelError, @&quot;Failed to `CGImageSourceCreateWithData` for animated GIF data %@&quot;, data);<br>            return nil;<br>        &#125;<br>        // 4、取出图片类型，判断是否是GIF动画<br>        // Early return if not GIF!<br>        CFStringRef imageSourceContainerType = CGImageSourceGetType(_imageSource);<br>        BOOL isGIFData = UTTypeConformsTo(imageSourceContainerType, kUTTypeGIF);<br>        if (!isGIFData) &#123;<br>            FLLog(FLLogLevelError, @&quot;Supplied data is of type %@ and doesn&#x27;t seem to be GIF data %@&quot;, imageSourceContainerType, data);<br>            return nil;<br>        &#125;<br>        // 5、取出GIF动画信息<br>        // Get `LoopCount`<br>        // Note: 0 means repeating the animation indefinitely.<br>        // Image properties example:<br>        // &#123;<br>        //     FileSize = 314446;<br>        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>        //         HasGlobalColorMap = 1;<br>        //         LoopCount = 0;<br>        //     &#125;;<br>        // &#125;<br>        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(_imageSource, NULL);<br>        //获取GIF动画循环次数<br>        _loopCount = [[[imageProperties objectForKey:(id)kCGImagePropertyGIFDictionary] objectForKey:(id)kCGImagePropertyGIFLoopCount] unsignedIntegerValue];<br>        <br>        // Iterate through frame images<br>        //遍历图片<br>        size_t imageCount = CGImageSourceGetCount(_imageSource);<br>        NSUInteger skippedFrameCount = 0;//用于记录GIF动画中异常帧的数量<br>        NSMutableDictionary *delayTimesForIndexesMutable = [NSMutableDictionary dictionaryWithCapacity:imageCount];//记录GIF动画中每帧图片的显示时间<br>        for (size_t i = 0; i &lt; imageCount; i++) &#123;<br>            @autoreleasepool &#123;<br>                // 6、取出帧图片<br>                //Return the image at `index&#x27; in the image source `isrc&#x27;.<br>                CGImageRef frameImageRef = CGImageSourceCreateImageAtIndex(_imageSource, i, NULL);<br>                if (frameImageRef) &#123;<br>                    UIImage *frameImage = [UIImage imageWithCGImage:frameImageRef];<br>                    // Check for valid `frameImage` before parsing its properties as frames can be corrupted (and `frameImage` even `nil` when `frameImageRef` was valid).<br>                    if (frameImage) &#123;<br>                        // Set poster image<br>                        // 取出的第一张图片为GIF动画的封面图片<br>                        if (!self.posterImage) &#123;<br>                            _posterImage = frameImage;<br>                            // Set its size to proxy our size.<br>                            _size = _posterImage.size;<br>                            // Remember index of poster image so we never purge it; also add it to the cache.<br>                            _posterImageFrameIndex = i;<br>                            [self.cachedFramesForIndexes setObject:self.posterImage forKey:@(self.posterImageFrameIndex)];<br>                            [self.cachedFrameIndexes addIndex:self.posterImageFrameIndex];<br>                        &#125;<br>                        // 7、取出帧图片的信息<br>                        // Get `DelayTime`<br>                        // Note: It&#x27;s not in (1/100) of a second like still falsely described in the documentation as per iOS 8 (rdar://19507384) but in seconds stored as `kCFNumberFloat32Type`.<br>                        // Frame properties example:<br>                        // &#123;<br>                        //     ColorModel = RGB;<br>                        //     Depth = 8;<br>                        //     PixelHeight = 960;<br>                        //     PixelWidth = 640;<br>                        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>                        //         DelayTime = &quot;0.4&quot;;<br>                        //         UnclampedDelayTime = &quot;0.4&quot;;<br>                        //     &#125;;<br>                        // &#125;<br>                        <br>                        NSDictionary *frameProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyPropertiesAtIndex(_imageSource, i, NULL);<br>                        NSDictionary *framePropertiesGIF = [frameProperties objectForKey:(id)kCGImagePropertyGIFDictionary];<br>                        <br>                        // 8、取出帧图片的展示时间<br>                        // Try to use the unclamped delay time; fall back to the normal delay time.<br>                        NSNumber *delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFUnclampedDelayTime];<br>                        if (!delayTime) &#123;<br>                            delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFDelayTime];<br>                        &#125;<br>                        // If we don&#x27;t get a delay time from the properties, fall back to `kDelayTimeIntervalDefault` or carry over the preceding frame&#x27;s value.<br>                        const NSTimeInterval kDelayTimeIntervalDefault = 0.1;<br>                        if (!delayTime) &#123;<br>                            if (i == 0) &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to default delay time for first frame %@ because none found in GIF properties %@&quot;, frameImage, frameProperties);<br>                                delayTime = @(kDelayTimeIntervalDefault);<br>                            &#125; else &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to preceding delay time for frame %zu %@ because none found in GIF properties %@&quot;, i, frameImage, frameProperties);<br>                                delayTime = delayTimesForIndexesMutable[@(i - 1)];<br>                            &#125;<br>                        &#125;<br>                        // Support frame delays as low as `kFLAnimatedImageDelayTimeIntervalMinimum`, with anything below being rounded up to `kDelayTimeIntervalDefault` for legacy compatibility.<br>                        // To support the minimum even when rounding errors occur, use an epsilon when comparing. We downcast to float because that&#x27;s what we get for delayTime from ImageIO.<br>                        if ([delayTime floatValue] &lt; ((float)kFLAnimatedImageDelayTimeIntervalMinimum - FLT_EPSILON)) &#123;<br>                            FLLog(FLLogLevelInfo, @&quot;Rounding frame %zu&#x27;s `delayTime` from %f up to default %f (minimum supported: %f).&quot;, i, [delayTime floatValue], kDelayTimeIntervalDefault, kFLAnimatedImageDelayTimeIntervalMinimum);<br>                            delayTime = @(kDelayTimeIntervalDefault);<br>                        &#125;<br>                        delayTimesForIndexesMutable[@(i)] = delayTime;<br>                    &#125; else &#123;<br>                        skippedFrameCount++;<br>                        FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because valid `CGImageRef` %@ did result in `nil`-`UIImage`.&quot;, i, frameImageRef);<br>                    &#125;<br>                    CFRelease(frameImageRef);<br>                &#125; else &#123;<br>                    skippedFrameCount++;<br>                    FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because failed to `CGImageSourceCreateImageAtIndex` with image source %@&quot;, i, _imageSource);<br>                &#125;<br>            &#125;<br>        &#125;<br>        //帧图片展示时间的数组<br>        _delayTimesForIndexes = [delayTimesForIndexesMutable copy];<br>        //GIF动画有多少帧图片<br>        _frameCount = imageCount;<br>        <br>        if (self.frameCount == 0) &#123;<br>            FLLog(FLLogLevelInfo, @&quot;Failed to create any valid frames for GIF with properties %@&quot;, imageProperties);<br>            return nil;<br>        &#125; else if (self.frameCount == 1) &#123;<br>            // Warn when we only have a single frame but return a valid GIF.<br>            FLLog(FLLogLevelInfo, @&quot;Created valid GIF but with only a single frame. Image properties: %@&quot;, imageProperties);<br>        &#125; else &#123;<br>            // We have multiple frames, rock on!<br>        &#125;<br>        // 9、GIF动画缓存策略<br>        // If no value is provided, select a default based on the GIF.<br>        if (optimalFrameCacheSize == 0) &#123;<br>            // Calculate the optimal frame cache size: try choosing a larger buffer window depending on the predicted image size.<br>            // It&#x27;s only dependent on the image size &amp; number of frames and never changes.<br>            // 图片的每行字节大小*高*图片数量/1M的字节 = GIF大小（M）<br>            // 根据GIF图的大小和缓存策略判断需要缓存的单帧图片数量<br>            <br>            //GIF动画的占用内存大小与FLAnimatedImageDataSizeCategory的方案比较，确认缓存策略<br>            CGFloat animatedImageDataSize = CGImageGetBytesPerRow(self.posterImage.CGImage) * self.size.height * (self.frameCount - skippedFrameCount) / MEGABYTE;<br>            if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryAll) &#123;<br>                _frameCacheSizeOptimal = self.frameCount;<br>            &#125; else if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryDefault) &#123;<br>                // This value doesn&#x27;t depend on device memory much because if we&#x27;re not keeping all frames in memory we will always be decoding 1 frame up ahead per 1 frame that gets played and at this point we might as well just keep a small buffer just large enough to keep from running out of frames.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeDefault;<br>            &#125; else &#123;<br>                // The predicted size exceeds the limits to build up a cache and we go into low memory mode from the beginning.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeLowMemory;<br>            &#125;<br>        &#125; else &#123;<br>            // Use the provided value.<br>            _frameCacheSizeOptimal = optimalFrameCacheSize;<br>        &#125;<br>        // In any case, cap the optimal cache size at the frame count.<br>        // _frameCacheSizeOptimal 不能大于 self.frameCount<br>        // 确认最佳的GIF动画的帧图片缓存数量<br>        _frameCacheSizeOptimal = MIN(_frameCacheSizeOptimal, self.frameCount);<br>        <br>        // Convenience/minor performance optimization; keep an index set handy with the full range to return in `-frameIndexesToCache`.<br>        _allFramesIndexSet = [[NSIndexSet alloc] initWithIndexesInRange:NSMakeRange(0, self.frameCount)];<br>        <br>        // See the property declarations for descriptions.<br>        //成为FLWeakProxy的代理<br>        _weakProxy = (id)[FLWeakProxy weakProxyForObject:self];<br>        <br>        // Register this instance in the weak table for memory notifications. The NSHashTable will clean up after itself when we&#x27;re gone.<br>        // Note that FLAnimatedImages can be created on any thread, so the hash table must be locked.<br>        @synchronized(allAnimatedImagesWeak) &#123;<br>            [allAnimatedImagesWeak addObject:self];<br>        &#125;<br>    &#125;<br>    return self;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 取UIImage对象<br>a、对索引位置进行判断，避免出现越界情况<br>b、记录当前取出的帧图片的索引位置<br>c、根据缓存策略判断接下来需要生产的帧图片索引，正常是当前显示帧图片之后的帧图片的索引。<br>d、根据需要生产的帧图片索引生产帧图片<br>e、取出对应的帧图片<br>f、根据缓存策略清缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// See header for more details.<br>// Note: both consumer and producer are throttled: consumer by frame timings and producer by the available memory (max buffer window size).<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index<br>&#123;<br>    // Early return if the requested index is beyond bounds.<br>    // Note: We&#x27;re comparing an index with a count and need to bail on greater than or equal to.<br>    // 1、索引位置判断<br>    if (index &gt;= self.frameCount) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Skipping requested frame %lu beyond bounds (total frame count: %lu) for animated image: %@&quot;, (unsigned long)index, (unsigned long)self.frameCount, self);<br>        return nil;<br>    &#125;<br>    <br>    // Remember requested frame index, this influences what we should cache next.<br>    // 2、记录当前要生产的帧图片在GIF动画中的索引位置<br>    self.requestedFrameIndex = index;<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>    if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImage:didRequestCachedFrame:)]) &#123;<br>        [self.debug_delegate debug_animatedImage:self didRequestCachedFrame:index];<br>    &#125;<br>#endif<br>    <br>    // Quick check to avoid doing any work if we already have all possible frames cached, a common case.<br>    // 3、判断GIF动画的帧图片的是否全部缓存下来了,因为有可能缓存策略是缓存所有的帧图片<br>    if ([self.cachedFrameIndexes count] &lt; self.frameCount) &#123;<br>        // If we have frames that should be cached but aren&#x27;t and aren&#x27;t requested yet, request them.<br>        // Exclude existing cached frames, frames already requested, and specially cached poster image.<br>        // 4、根据缓存策略得到接下来需要缓存的帧图片索引，<br>        NSMutableIndexSet *frameIndexesToAddToCacheMutable = [self frameIndexesToCache];<br>        // 5、除去已经缓存下来的帧图片索引<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.cachedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.requestedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndex:self.posterImageFrameIndex];<br>        NSIndexSet *frameIndexesToAddToCache = [frameIndexesToAddToCacheMutable copy];<br>        <br>        // Asynchronously add frames to our cache.<br>        if ([frameIndexesToAddToCache count] &gt; 0) &#123;<br>            // 6、生产帧图片<br>            [self addFrameIndexesToCache:frameIndexesToAddToCache];<br>        &#125;<br>    &#125;<br>    <br>    // Get the specified image.<br>    // 7、取出帧图片<br>    UIImage *image = self.cachedFramesForIndexes[@(index)];<br>    <br>    // Purge if needed based on the current playhead position.<br>    // 8、根据缓存策略清缓存<br>    [self purgeFrameCacheIfNeeded];<br>    <br>    return image;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他关键方法简单介绍</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// Only called once from `-imageLazilyCachedAtIndex` but factored into its own method for logical grouping.<br>// 生产帧图片<br>- (void)addFrameIndexesToCache:(NSIndexSet *)frameIndexesToAddToCache;<br><br>// 取出GIF动画的帧图片<br>- (UIImage *)imageAtIndex:(NSUInteger)index;<br><br>// Decodes the image&#x27;s data and draws it off-screen fully in memory; it&#x27;s thread-safe and hence can be called on a background thread.<br>// On success, the returned object is a new `UIImage` instance with the same content as the one passed in.<br>// On failure, the returned object is the unchanged passed in one; the data will not be predrawn in memory though and an error will be logged.<br>// First inspired by &amp; good Karma to: https://gist.github.com/steipete/1144242<br>// 解码图片<br>+ (UIImage *)predrawnImageFromImage:(UIImage *)imageToPredraw;<br><br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView接口"><a href="#FLAnimatedImageView接口" class="headerlink" title="FLAnimatedImageView接口"></a>FLAnimatedImageView接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C"><br>// FLAnimatedImageView是UIImageView的子类，完全兼容UIImageView的各个方法。<br><br>//  An `FLAnimatedImageView` can take an `FLAnimatedImage` and plays it automatically when in view hierarchy and stops when removed.<br>//  The animation can also be controlled with the `UIImageView` methods `-start/stop/isAnimating`.<br>//  It is a fully compatible `UIImageView` subclass and can be used as a drop-in component to work with existing code paths expecting to display a `UIImage`.<br>//  Under the hood it uses a `CADisplayLink` for playback, which can be inspected with `currentFrame` &amp; `currentFrameIndex`.<br>//<br>@interface FLAnimatedImageView : UIImageView<br><br>// Setting `[UIImageView.image]` to a non-`nil` value clears out existing `animatedImage`.<br>// And vice versa, setting `animatedImage` will initially populate the `[UIImageView.image]` to its `posterImage` and then start animating and hold `currentFrame`.<br>@property (nonatomic, strong) FLAnimatedImage *animatedImage;//设置GIF动画数据<br>@property (nonatomic, copy) void(^loopCompletionBlock)(NSUInteger loopCountRemaining);//GIF动画播放一次之后的回调Block<br><br>@property (nonatomic, strong, readonly) UIImage *currentFrame;//GIF动画当前显示的帧图片<br>@property (nonatomic, assign, readonly) NSUInteger currentFrameIndex;//GIF动画当前显示的帧图片索引<br><br>// The animation runloop mode. Enables playback during scrolling by allowing timer events (i.e. animation) with NSRunLoopCommonModes.<br>// To keep scrolling smooth on single-core devices such as iPhone 3GS/4 and iPod Touch 4th gen, the default run loop mode is NSDefaultRunLoopMode. Otherwise, the default is NSDefaultRunLoopMode.<br>@property (nonatomic, copy) NSString *runLoopMode;<br><br>@end<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView解析"><a href="#FLAnimatedImageView解析" class="headerlink" title="FLAnimatedImageView解析"></a>FLAnimatedImageView解析</h3><ul><li>关键方法 设置FLAnimatedImage对象解析<br>a、判断新旧FLAnimatedImage对象是否一致，一致就不需要继续操作了<br>b、设置GIF动画的封面帧图片，当前帧索引，GIF动画的循环播放次数，播放时间累加器<br>c、更新是否发起动画的标志位，判断是否启动GIF动画<br>d、刷新View的layer</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)setAnimatedImage:(FLAnimatedImage *)animatedImage<br>&#123;<br>    //新设置的GIF动画数据和当前的数据不一致<br>    if (![_animatedImage isEqual:animatedImage]) &#123;<br>        if (animatedImage) &#123;<br>            // Clear out the image.<br>            super.image = nil;<br>            // Ensure disabled highlighting; it&#x27;s not supported (see `-setHighlighted:`).<br>            super.highlighted = NO;<br>            // UIImageView seems to bypass some accessors when calculating its intrinsic content size, so this ensures its intrinsic content size comes from the animated image.<br>            //确保UIImageView的content size 大小来自 animated image<br>            [self invalidateIntrinsicContentSize];<br>        &#125; else &#123;<br>            // Stop animating before the animated image gets cleared out.<br>            // animatedImage为nil，需要清空当前动画图片<br>            [self stopAnimating];<br>        &#125;<br>        <br>        _animatedImage = animatedImage;<br>        <br>        self.currentFrame = animatedImage.posterImage;//GIF动画的封面帧图片<br>        self.currentFrameIndex = 0;//当前的帧图片索引<br>        //设置GIF动画的循环播放次数<br>        if (animatedImage.loopCount &gt; 0) &#123;<br>            self.loopCountdown = animatedImage.loopCount;<br>        &#125; else &#123;<br>            self.loopCountdown = NSUIntegerMax;<br>        &#125;<br>        //播放时间累加器<br>        self.accumulator = 0.0;<br>        <br>        // Start animating after the new animated image has been set.<br>        [self updateShouldAnimate];<br>        if (self.shouldAnimate) &#123;<br>            [self startAnimating];<br>        &#125;<br>        <br>        [self.layer setNeedsDisplay];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 设置CADisplayLink的frameInterval</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)startAnimating<br>&#123;<br>    //使用CADisplayLink来播放GIF动画<br>    if (self.animatedImage) &#123;<br>        // Lazily create the display link.<br>        if (!self.displayLink) &#123;<br>            // It is important to note the use of a weak proxy here to avoid a retain cycle. `-displayLinkWithTarget:selector:`<br>            // will retain its target until it is invalidated. We use a weak proxy so that the image view will get deallocated<br>            // independent of the display link&#x27;s lifetime. Upon image view deallocation, we invalidate the display<br>            // link which will lead to the deallocation of both the display link and the weak proxy.<br>            FLWeakProxy *weakProxy = [FLWeakProxy weakProxyForObject:self];<br>            self.displayLink = [CADisplayLink displayLinkWithTarget:weakProxy selector:@selector(displayDidRefresh:)];<br>            <br>            [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:self.runLoopMode];<br>        &#125;<br><br>        // Note: The display link&#x27;s `.frameInterval` value of 1 (default) means getting callbacks at the refresh rate of the display (~60Hz).<br>        // Setting it to 2 divides the frame rate by 2 and hence calls back at every other display refresh.<br>        const NSTimeInterval kDisplayRefreshRate = 60.0; // 60Hz<br>        // 1、frameInterval : Defines how many display frames must pass between each time the display link fires.<br>        // 2、先求出gif中每帧图片的播放时间，求出这些播放时间的最大公约数，<br>        // 3、将这个最大公约数*刷新速率，再与1比取最大值，该值作为frameInterval。<br>        // 4、将GIF动画的每帧图片显示时间除以帧显示时间的最大公约数，得到单位时间内GIF动画的每个帧显示时间的比例，然后再乘以屏幕刷新速率kDisplayRefreshRate作为displayLink.frameInterval,正好可以用displayLink调用刷新方法的频率来保证GIF动画的帧图片展示时间 frame delays的间隔比例，使GIF动画的效果能够正常显示。<br>        self.displayLink.frameInterval = MAX([self frameDelayGreatestCommonDivisor] * kDisplayRefreshRate, 1);<br><br>        self.displayLink.paused = NO;<br>    &#125; else &#123;<br>        [super startAnimating];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 播放GIF动画<br>该方法关键点在于accumulator累加器的使用和displayLink.frameInterval的计算，涉及一些简单的数学过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)displayDidRefresh:(CADisplayLink *)displayLink<br>&#123;<br>    // If for some reason a wild call makes it through when we shouldn&#x27;t be animating, bail.<br>    // Early return!<br>    if (!self.shouldAnimate) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Trying to animate image when we shouldn&#x27;t: %@&quot;, self);<br>        return;<br>    &#125;<br>    <br>    NSNumber *delayTimeNumber = [self.animatedImage.delayTimesForIndexes objectForKey:@(self.currentFrameIndex)];<br>    // If we don&#x27;t have a frame delay (e.g. corrupt frame), don&#x27;t update the view but skip the playhead to the next frame (in else-block).<br>    if (delayTimeNumber) &#123;<br>        NSTimeInterval delayTime = [delayTimeNumber floatValue];<br>        // If we have a nil image (e.g. waiting for frame), don&#x27;t update the view nor playhead.<br>        // 拿到当前要显示的图片<br>        UIImage *image = [self.animatedImage imageLazilyCachedAtIndex:self.currentFrameIndex];<br>        if (image) &#123;<br>            FLLog(FLLogLevelVerbose, @&quot;Showing frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>            //显示图片<br>            self.currentFrame = image;<br>            if (self.needsDisplayWhenImageBecomesAvailable) &#123;<br>                [self.layer setNeedsDisplay];<br>                self.needsDisplayWhenImageBecomesAvailable = NO;<br>            &#125;<br>            //frameInterval:Defines how many display frames must pass between each time the display link fires<br>            //duration :duration of the display frame<br>            <br>            //displayLink.duration * displayLink.frameInterval是每个display link fires之间的时间间隔<br>            self.accumulator += displayLink.duration * displayLink.frameInterval;<br>            <br>//从前面的startAnimating方法中displayLink.frameInterval的计算过程可以知道，<br>//GIF动画中的帧图片的展示时间都是delayTime都是displayLink.duration * displayLink.frameInterval的倍数关系，<br>//也就是说一个GIF动画帧图片的展示时间至少是一个display link fires的时间间隔。<br>//以下数据是使用FLAnimatedImage的Demo项目的第一个GIF动画的播放信息打印出来的。<br>//按照Demo中的打印数据来说，第0帧图片的展示时间是14个display link fires的时间间隔，而1，2，3帧图片都是只有一个display link fires的时间间隔。<br>//所以累加器self.accumulator的意义在于累加display link fires的时间间隔，并与帧图片的delayTime做比较，如果小于delayTime说明该帧图片还需要继续展示，否则该帧图片结束展示。<br>            <br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.100000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.150000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.200000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.250000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.300000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.350000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.400000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.450000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.500000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.550000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.600000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.650000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.700000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;1,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;2,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;3,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>            <br>            <br>            // While-loop first inspired by &amp; good Karma to: https://github.com/ondalabs/OLImageView/blob/master/OLImageView.m<br>            while (self.accumulator &gt;= delayTime) &#123;<br>                self.accumulator -= delayTime;<br>                self.currentFrameIndex++;<br>                <br>                if (self.currentFrameIndex &gt;= self.animatedImage.frameCount) &#123;<br>                    // 播放到结尾，循环次数减1<br>                    // If we&#x27;ve looped the number of times that this animated image describes, stop looping.<br>                    self.loopCountdown--;<br>                    if (self.loopCompletionBlock) &#123;<br>                        self.loopCompletionBlock(self.loopCountdown);<br>                    &#125;<br>                    // 循环次数为0，停止播放,退出方法<br>                    if (self.loopCountdown == 0) &#123;<br>                        [self stopAnimating];<br>                        return;<br>                    &#125;<br>                    //重置帧图片索引，继续从头开始播放gif动画<br>                    self.currentFrameIndex = 0;<br>                &#125;<br>                // Calling `-setNeedsDisplay` will just paint the current frame, not the new frame that we may have moved to.<br>                // Instead, set `needsDisplayWhenImageBecomesAvailable` to `YES` -- this will paint the new image once loaded.<br>                // 展示新图片<br>                self.needsDisplayWhenImageBecomesAvailable = YES;<br>            &#125;<br>        &#125; else &#123;<br>            FLLog(FLLogLevelDebug, @&quot;Waiting for frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>            if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImageView:waitingForFrame:duration:)]) &#123;<br>                [self.debug_delegate debug_animatedImageView:self waitingForFrame:self.currentFrameIndex duration:(NSTimeInterval)displayLink.duration * displayLink.frameInterval];<br>            &#125;<br>#endif<br>        &#125;<br>    &#125; else &#123;<br>        //取不到需要的信息直接开始下一张图片播放<br>        self.currentFrameIndex++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>FLAnimatedImage就是负责生产数据是生产者。</li><li>FLAnimatedImageView负责消费数据是消费者。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/">https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/</a><br><a href="http://engineering.flipboard.com/2014/05/animated-gif/">http://engineering.flipboard.com/2014/05/animated-gif/</a><br><a href="https://github.com/Flipboard/FLAnimatedImage">https://github.com/Flipboard/FLAnimatedImage</a><br><a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/">http://blog.ibireme.com/2015/11/02/ios_image_tips/</a><br><a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 网络框架－AFNetworking 3.1.0 源码解读</title>
    <link href="/2016/07/31/reading-source-code-of-AFNetworking/"/>
    <url>/2016/07/31/reading-source-code-of-AFNetworking/</url>
    
    <content type="html"><![CDATA[<h1 id="AFNetworking-解读"><a href="#AFNetworking-解读" class="headerlink" title="AFNetworking 解读"></a>AFNetworking 解读</h1><p>AFNetworking 基本是 iOS 开发中的网络第三方库标配,本文基于 <a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">AFNetworking3.1.0</a> 版本。废话不多说，这篇文章主要从使用的角度来介绍 AFNetworking 的发起 Get 请求的过程，偏重于解读过程，解读当你使用 AFNetworking 发起一个 Get 请求的时候，AFNetworking 内部的处理过程。而不是对 AFNetworking 源代码的各个类的代码进行深入解析，在源码深度解析方面，网络上已经有很多不错的文章，在文章的末尾我会给出参考链接。</p><h2 id="Get-请求流程图"><a href="#Get-请求流程图" class="headerlink" title="Get 请求流程图"></a>Get 请求流程图</h2><p>这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，我会逐个解读这个流程。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled.webp" class="" title="This is an example image"><h2 id="AFHTTPSessionManager-发起Get请求"><a href="#AFHTTPSessionManager-发起Get请求" class="headerlink" title="AFHTTPSessionManager 发起Get请求"></a>AFHTTPSessionManager 发起Get请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled1.webp" class="" title="This is an example image"><p>这个方法是 AFN 的 Get 请求的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 NSURLSessionDataTask 对象的实例,然后调用 NSURLSessionDataTask 的 resume 方法发起请求。</p><h2 id="创建-NSURLSessionDataTask"><a href="#创建-NSURLSessionDataTask" class="headerlink" title="创建 NSURLSessionDataTask"></a>创建 NSURLSessionDataTask</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled2.webp" class="" title="This is an example image"><p>这个方法是创建 NSURLSessionDataTask 对象实例并返回这个实例。首先创建一个 NSMutableURLRequest 对象的实例，然后配置。之后是使用 NSMutableURLRequest 对象的实例创建 NSURLSessionDataTask 对象实例，然后配置，可以选择性地传入各类 Block 回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。</p><h3 id="配置-NSMutableURLRequest-对象"><a href="#配置-NSMutableURLRequest-对象" class="headerlink" title="配置 NSMutableURLRequest 对象"></a>配置 NSMutableURLRequest 对象</h3><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled3.webp" class="" title="This is an example image"><p>在这个方法中先使用了url 创建了一个 NSMutableURLRequest 对象的实例,并且设置了 HTTPMethod 为 Get 方法（如果是 Post 方法，那么这里就是设置 Post 方法，以此类推）然后使用 KVC 的方法设置了 NSMutableURLRequest 的一些属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//设置 NSMutableURLRequest 的属性</span><br> <span class="hljs-function"><span class="hljs-type">static</span> NSArray * <span class="hljs-title">AFHTTPRequestSerializerObservedKeyPaths</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        <span class="hljs-comment">//allowsCellularAccess 允许使用数据流量</span><br>        <span class="hljs-comment">//cachePolicy 缓存策略</span><br>        <span class="hljs-comment">//HTTPShouldHandleCookies 处理Cookie</span><br>        <span class="hljs-comment">//HTTPShouldUsePipelining 批量请求</span><br>        <span class="hljs-comment">//networkServiceType 网络状态</span><br>        <span class="hljs-comment">//timeoutInterval 超时</span><br>        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(allowsCellularAccess)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(cachePolicy)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldHandleCookies)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldUsePipelining)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(networkServiceType)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(timeoutInterval))];<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;<br>&#125;```<br><br><br>![配置NSMutableURLRequest对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-a228e54cc99ab038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br>先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于 Get 操作来说，参数是直接拼接在请求地址后面。<br><br>### 配置 NSURLSessionDataTask 对象<br><br>![配置NSURLSessionDataTask对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-df139131c05cc9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>之后配置 NSMutableURLRequest 对象就需要配置 NSURLSessionDataTask 对象了。主要分为 <span class="hljs-number">2</span> 个步骤，第一个步骤是创建 NSURLSessionDataTask 对象实例，第二个步骤是给 NSURLSessionDataTask 对象实例设置 Delegate。用于实时了解网络请求的过程。<br><br><br>![给NSURLSessionDataTask对象实例设置Delegate](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-d75418e6972979c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>AFN 的代理统一使用 AFURLSessionManagerTaskDelegate 对象来管理，使用AFURLSessionManagerTaskDelegate 对象来接管 NSURLSessionTask 网络请求过程中的回调，然后再传入 AFN 内部进行管理。<br><br>```CPP<br>@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;<br></code></pre></td></tr></table></figure><p>如代码所示 AFURLSessionManagerTaskDelegate 接管了 NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 NSURLSessionTask 的 taskIdentifier 标识符对 delegate 进行管理，只要是用于识别该NSURLSessionTask 的代理，</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled4.webp" class="" title="This is an example image"><p>设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task添加暂停和恢复的通知</span><br>- (<span class="hljs-type">void</span>)addNotificationObserverForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];<br>&#125;<br></code></pre></td></tr></table></figure><p>监听 NSURLSessionTask 被挂起和恢复的通知</p><h2 id="网络请求开始"><a href="#网络请求开始" class="headerlink" title="网络请求开始"></a>网络请求开始</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)GET:(<span class="hljs-built_in">NSString</span> *)URLString<br>                   parameters:(<span class="hljs-type">id</span>)parameters<br>                     progress:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> * _Nonnull))downloadProgress<br>                      success:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="hljs-type">id</span> _Nullable))success<br>                      failure:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nullable, <span class="hljs-built_in">NSError</span> * _Nonnull))failure<br>&#123;<br><br>    <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask = [<span class="hljs-keyword">self</span> dataTaskWithHTTPMethod:<span class="hljs-string">@&quot;GET&quot;</span><br>                                                        URLString:URLString<br>                                                       parameters:parameters<br>                                                   uploadProgress:<span class="hljs-literal">nil</span><br>                                                 downloadProgress:downloadProgress<br>                                                          success:success<br>                                                          failure:failure];<br><br>    [dataTask resume];<br><br>    <span class="hljs-keyword">return</span> dataTask;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 NSURLSessionTask 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 resume方法，NSURLSessionTask 才会开始执行。</p><h2 id="网络请求回调"><a href="#网络请求回调" class="headerlink" title="网络请求回调"></a>网络请求回调</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled5.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled6.webp" class="" title="This is an example image"><p>AFN 里面有关 NSURLSessionDelegate 的回调方法非常的多，这里我们只调和<br> NSURLSessionTask 相关的部分方法和 KVO 处理来进行说明，其他的大家可以参考源码细看。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled7.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled8.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled9.webp" class="" title="This is an example image"><p>对于我们的 Get 请求来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//KVO监听的属性值发生变化</span><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([object isKindOfClass:[<span class="hljs-built_in">NSURLSessionTask</span> <span class="hljs-keyword">class</span>]] || [object isKindOfClass:[<span class="hljs-built_in">NSURLSessionDownloadTask</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesReceived))]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesReceived&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中已经收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToReceive&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中期待收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesSent))]) &#123;<br>             <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesSent&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经发送</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToSend&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待发送</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.downloadProgress]) &#123;<br>        <span class="hljs-comment">//下载进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.downloadProgressBlock(object);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.uploadProgress]) &#123;<br>        <span class="hljs-comment">//上传进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.uploadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.uploadProgressBlock(object);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//收到请求响应</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>          dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;收到请求响应&quot;</span>);<br>    <span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionResponseAllow</span>;<span class="hljs-comment">//允许继续加载</span><br><br><span class="hljs-comment">//是否有收到请求响应的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        disposition = <span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);<br>    &#125;<br><span class="hljs-comment">//是否有请求响应完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        completionHandler(disposition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//请求完成</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求完成&quot;</span>);<br><span class="hljs-comment">//取出该NSURLSessionTask的代理对象</span><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br><br>    <span class="hljs-comment">// delegate may be nil when completing a task in the background</span><br>    <span class="hljs-keyword">if</span> (delegate) &#123;<br><span class="hljs-comment">//若是该代理对象存在，那么将对应数据转给该代理对象处理</span><br>        [delegate URLSession:session task:task didCompleteWithError:error];<br><span class="hljs-comment">//NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象</span><br>        [<span class="hljs-keyword">self</span> removeDelegateForTask:task];<br>    &#125;<br><span class="hljs-comment">//是否有请求完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidComplete) &#123;<br><span class="hljs-comment">//若有调用改Block</span><br>        <span class="hljs-keyword">self</span>.taskDidComplete(session, task, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。</p><p>这个是我们的配置过程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task移除delegate</span><br>- (<span class="hljs-type">void</span>)removeDelegateForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    [delegate cleanUpProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> removeNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled10.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled11.webp" class="" title="This is an example image"><h2 id="关于-Post-请求"><a href="#关于-Post-请求" class="headerlink" title="关于 Post 请求"></a>关于 Post 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled12.webp" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - AFURLRequestSerialization</span><br><span class="hljs-comment">//设置Header和请求参数</span><br>- (<span class="hljs-built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                               withParameters:(<span class="hljs-type">id</span>)parameters<br>                                        error:(<span class="hljs-built_in">NSError</span> *__autoreleasing *)error<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(request);<br><br>    <span class="hljs-built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];<br>    [<span class="hljs-keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-type">id</span> field, <span class="hljs-type">id</span> value, <span class="hljs-type">BOOL</span> * __unused stop) &#123;<br>        <span class="hljs-comment">//判断header的field是否存在,如果不存在则设置，存在则跳过</span><br>        <span class="hljs-keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;<br>            <span class="hljs-comment">//设置 header</span><br>            [mutableRequest setValue:value forHTTPHeaderField:field];<br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-built_in">NSString</span> *query = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (parameters) &#123;<br>        <span class="hljs-comment">//用传进来的自定义block格式化请求参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.queryStringSerialization) &#123;<br>            <span class="hljs-built_in">NSError</span> *serializationError;<br>            query = <span class="hljs-keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);<br>            <span class="hljs-keyword">if</span> (serializationError) &#123;<br>                <span class="hljs-keyword">if</span> (error) &#123;<br>                    *error = serializationError;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.queryStringSerializationStyle) &#123;<br>                <span class="hljs-keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:<br>                    <span class="hljs-comment">//默认的格式化方式</span><br>                    query = AFQueryStringFromParameters(parameters);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;<br>       <span class="hljs-comment">//判断是否有参数</span><br>        <span class="hljs-keyword">if</span> (query &amp;&amp; query.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//拼接请求参数</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;query--&gt;%@&quot;</span>,query);<br>            mutableRequest.URL = [<span class="hljs-built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="hljs-string">@&quot;&amp;%@&quot;</span> : <span class="hljs-string">@&quot;?%@&quot;</span>, query]];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span><br>        <span class="hljs-keyword">if</span> (!query) &#123;<br>            query = <span class="hljs-string">@&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//参数带在body上，大多是POST PUT</span><br>        <span class="hljs-keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>]) &#123;<br>            <span class="hljs-comment">//设置Content-Type HTTP头，告诉服务端body的参数编码类型</span><br>            [mutableRequest setValue:<span class="hljs-string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>];<br>        &#125;<br>        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="hljs-keyword">self</span>.stringEncoding]];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mutableRequest;<br>&#125; <br></code></pre></td></tr></table></figure><p>如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 body 上，这个是 Post 和 Get 请求的最大区别了，其他过程和 Get 请求并没有太多区别。</p><h2 id="关于-HTTPS-请求"><a href="#关于-HTTPS-请求" class="headerlink" title="关于 HTTPS 请求"></a>关于 HTTPS 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled13.png" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled14.png" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Http认证处理</span><br><span class="hljs-comment">//认证处理</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *http://www.cnblogs.com/polobymulberry/p/5140806.html</span><br><span class="hljs-comment"> *web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。</span><br><span class="hljs-comment"> *这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</span><br><span class="hljs-comment"> *接收到挑战后，</span><br><span class="hljs-comment"> *客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential</span><br><span class="hljs-comment"> *（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。</span><br><span class="hljs-comment"> *最后调用completionHandler回应服务器端的挑战。</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-comment">//NSURLAuthenticationChallenge 挑战处理类型为 默认</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">//自定义方法，用来如何应对服务器端的认证挑战</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//服务端要求客户端提供证书</span><br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-comment">//客户端评估服务端的安全性</span><br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                <span class="hljs-comment">//客户端产生证书</span><br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>                <span class="hljs-keyword">if</span> (credential) &#123;<br>                    <span class="hljs-comment">//使用指定的证书</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//默认处理</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不处理服务端的认证要求</span><br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//如果没有实现方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *- (void)URLSession:(NSURLSession *)session</span><br><span class="hljs-comment"> *didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="hljs-comment"> *completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//那么URLSession会调用下面的方法进入认证处理</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是 HTTPS 请求的话，那么会先走上面的2个代理方法进行 HTTPS 认证，之后继续其他操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AFN 发起 Get 请求主要分为以下步骤：<br>1.创建 NSURLSessionDataTask<br>2.配置 NSURLSessionDataTask<br>3.设置 NSURLSessionDataTask 的 Delegate<br>4.调用 NSURLSessionDataTask 的 resume 方法开始请求<br>5.在 Delegate 的方法里面处理网络请求的各个过程<br>6.清理 NSURLSessionDataTask 的配置<br>其实也就是使用 NSURLSessionDataTask 的步骤，AFN 在这几个步骤加了一些封装，让整个请求过程更加好用，易用。</p><p>对于 AFN 这类几乎是 iOS 开发网络库标配的开源项目来说，肯定已经有许多非常优秀的源码解析文章了。所以这篇文章是着重讲解和介绍 AFN 的整个网络请求的处理流程而且很多的技术细节。相信如果对流程熟悉的话，那么要想找对应的细节处理过程也就比较简单的，再配合一些调试手段的话，基本上对于 AFN 的细节处理的理解也就不再话下了。由于个人水平有限，文章有不对之处恳请指出，我稍作修改，大家共同进步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://blog.cnbang.net/tech/2320/">http://blog.cnbang.net/tech/2320/</a><br><a href="http://blog.cnbang.net/tech/2371/">http://blog.cnbang.net/tech/2371/</a><br><a href="http://blog.cnbang.net/tech/2416/">http://blog.cnbang.net/tech/2416/</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a><br><a href="http://bugly.qq.com/bbs/forum.php">http://bugly.qq.com/bbs/forum.php</a>?<br><a href="http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6">http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6</a><br><a href="http://www.guokr.com/post/116169/">http://www.guokr.com/post/116169/</a><br><a href="http://www.guokr.com/blog/148613/">http://www.guokr.com/blog/148613/</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html">http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html</a><br><a href="http://www.cnblogs.com/polobymulberry/p/5140806.html">http://www.cnblogs.com/polobymulberry/p/5140806.html</a><br><a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">https://github.com/AFNetworking/AFNetworking/tree/3.1.0</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 图片加载框架－SDWebImage 解读</title>
    <link href="/2016/03/09/reading-source-code-of-SDWebImage/"/>
    <url>/2016/03/09/reading-source-code-of-SDWebImage/</url>
    
    <content type="html"><![CDATA[<h1 id="SDWebImage-解读"><a href="#SDWebImage-解读" class="headerlink" title="SDWebImage 解读"></a>SDWebImage 解读</h1><p>在 iOS 的图片加载框架中，<a href="https://github.com/rs/SDWebImage">SDWebImage</a> 可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的 UIImageView 控件或者 UIButton 控件。在项目中使用 SDWebImage 来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。</p><h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><p>1.提供了一个 UIImageView 的 category 用来加载网络图片并且对网络图片的缓存进行管理<br>2.采用异步方式来下载网络图片<br>3.采用异步方式，使用 memory＋disk 来缓存网络图片，自动管理缓存。<br>4.支持 GIF 动画<br>5.支持 WebP 格式<br>6.同一个 URL 的网络图片不会被重复下载<br>7.失效的 URL 不会被无限重试<br>8.耗时操作都在子线程，确保不会阻塞主线程<br>9.使用 GCD 和 ARC<br>10.支持 Arm64</p><h2 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h2><p>1.使用 ImageView+WebCache category 来加载 UITableView 中 cell 的图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>]];<br></code></pre></td></tr></table></figure><p>2.使用 block,采用这个方案可以在网络图片加载过程中得知图片的下载进度和图片加载成功与否</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>] completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="hljs-built_in">NSURL</span> *imageURL) &#123;<br>    <span class="hljs-comment">//... completion code here ... </span><br> &#125;];<br></code></pre></td></tr></table></figure><p>3.使用 SDWebImageManager,SDWebImageManager 为UIImageView+WebCache category 的实现提供接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SDWebImageManager *manager = [SDWebImageManager sharedManager] ;<br>[manager downloadImageWithURL:imageURL options:<span class="hljs-number">0</span> progress:^(<span class="hljs-built_in">NSInteger</span>   receivedSize, <span class="hljs-built_in">NSInteger</span> expectedSize) &#123; <br>      <span class="hljs-comment">// progression tracking code</span><br> &#125;  completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType,   <span class="hljs-type">BOOL</span> finished, <span class="hljs-built_in">NSURL</span> *imageURL) &#123; <br>   <span class="hljs-keyword">if</span> (image) &#123; <br>    <span class="hljs-comment">// do something with image</span><br>   &#125;<br> &#125;];<br></code></pre></td></tr></table></figure><p>4.加载图片还有使用 SDWebImageDownloader 和 SDImageCache 方式，但那个并不是我们经常用到的。基本上面所讲的3个方法都能满足需求。</p><h2 id="SDWebImage-流程"><a href="#SDWebImage-流程" class="headerlink" title="SDWebImage 流程"></a>SDWebImage 流程</h2><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled.webp" class="" title="This is an example image"><h2 id="SDWebImage-接口"><a href="#SDWebImage-接口" class="headerlink" title="SDWebImage 接口"></a>SDWebImage 接口</h2><p>SDWebImage 是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。</p><ol><li>给 UIImageView 设置图片的接口，SDWebImage 有提供多个给UIImageView 设置图片的接口，最终所有的接口都会调用下图的这个接口，这是大多数框架的做法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled1.webp" class="" title="This is an example image"><ol start="2"><li><p>获取 SDWebImage 的磁盘缓存大小,在项目中有时候会需要统计应用的磁盘缓存内容大小，那么获取图片的缓存大小就是使用这个接口来实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[SDImageCache sharedImageCache] getSize];<br></code></pre></td></tr></table></figure></li><li><p>清理内存缓存，清理内存中缓存的图片资源，释放内存资源。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearMemory];<br></code></pre></td></tr></table></figure></li><li><p>有了清理内存缓存，自然也有清理磁盘缓存的接口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearDisk];<br></code></pre></td></tr></table></figure></li></ol><h2 id="SDWebImage-解析"><a href="#SDWebImage-解析" class="headerlink" title="SDWebImage 解析"></a>SDWebImage 解析</h2><p>解析主要围绕着 SDWebImage 的图片加载流程来分析，介绍SDWebImage 这个框架加载图片过程中的一些处理方法和设计思路。</p><ol><li>给 UIImageView 设置图片，然后 SDWebImage 调用这个最终的图片加载方法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled2.webp" class="" title="This is an example image"><ol start="2"><li>开始加载之前图片先取消对应的 UIImageView 先前的图片下载操作。试想，如果我们给 UIImageView 设置了一张新的图片，那么我们还会在意该 UIImageVIew 先前是要加载哪一张图片么？应该是不在意的吧！那是不是应该尝试把该 UIImageView 先前的加载图片相关操作给取消掉呢?</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> sd_cancelCurrentImageLoad]<br></code></pre></td></tr></table></figure><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled3.webp" class="" title="This is an example image"><p>该方法经过周转，最后调用了以下方法，框架将图片对应的下载操作放到 UIView 的一个自定义字典属性 (operationDictionary) 中，取消下载操作第一步也是从这个 UIView 的自定义字典属性 (operationDictionary)中取出所有的下载操作，然后依次调用取消方法，最后将取消的操作从(operationDictionary) 字典属性中移除。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled4.webp" class="" title="This is an example image"><p>3.移除之前没用的图片下载操作之后就创建一个新的图片下载操作，然后设置到 UIView 的一个自定义字典属性 (operationDictionary) 中。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled5.webp" class="" title="This is an example image"><p>4.看看如何创建一个新的图片下载操作,框架保存了一个失效的 url 列表，如果 url 失效了就会被加入这个列表，保证不会重复多次请求失效的 url。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled6.webp" class="" title="This is an example image"><p>根据给定的 url 生成一个唯一的 key ,之后利用这个 key 到缓存中查找对应的图片缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled7.webp" class="" title="This is an example image"><p>5.读取图片缓存,根据 key 先从内存中读取图片缓存，若没有命中内存缓存则读取磁盘缓存，如果磁盘缓存命中，那么将磁盘缓存读到内存中成为内存缓存。如果都没有命中缓存的话，那么就在执行的 doneBlock中开始下载图片。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled8.webp" class="" title="This is an example image"><p>6.图片下载操作完成后会将图片对应的数据通过 completedBlock 进行回调</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled9.webp" class="" title="This is an example image"><p>在图片下载方法中，调用了一个方法用于添加创建和下载过程中的各类block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled10.webp" class="" title="This is an example image"><p>添加该 url 加载过程的状态回调 block<br> <img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled11.webp" class="" title="This is an example image"></p><p>如果该 url 是第一次加载的话，那么就会执行 createCallback 这个回调block ,然后在 createCallback 里面开始构建网络请求，在下载过程中执行各类进度 block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled12.webp" class="" title="This is an example image"><p>7.当图片下载完成之后会回到 done 的 block 回调中做图片转换处理和缓存操作</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled13.webp" class="" title="This is an example image"><p>回到 UIImageView 控件的设置图片方法 block 回调中，给对应的UIImageView 设置图片，操作流程到此完成。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled14.webp" class="" title="This is an example image"><p> 8.304 的处理<br>SDWebImage在加载图片网络请求的 NSURLConnection 的代理中对httpCode 做了判断，当 httpCode 为 304 的时候放弃下载，读取缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled15.webp" class="" title="This is an example image"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SDWebImage 作为一个优秀的图片加载框架，提供的使用方法和接口对开发者来说非常友好。其内部实现多是采用 block 的方式来实现回调，代码阅读起来可能没有那么直观。此文章旨在给大家讲解 SDWebImage 这个框架的图片大概加载流程，其中具体细节限于篇幅无法详细深究。能力有限，文章中难免有错误，若大家在阅读过程中有发现不合理或者错误的地方恳请在评论中指出，我会在第一时间进行修正,不胜感激。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>注释项目 <a href="https://github.com/junbinchencn/SDWebImage">https://github.com/junbinchencn/SDWebImage</a></li><li><a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS缓存框架－PINCache 解读</title>
    <link href="/2016/01/13/reading-source-code-of-PINCache/"/>
    <url>/2016/01/13/reading-source-code-of-PINCache/</url>
    
    <content type="html"><![CDATA[<h1 id="PINCache-解读"><a href="#PINCache-解读" class="headerlink" title="PINCache 解读"></a>PINCache 解读</h1><p>在项目中总是需要缓存一些网络请求数据以减轻服务器压力，业内也有许多优秀的开源的解决方案。通常的缓存方案都是由内存缓存和磁盘缓存组成的，内存缓存速度快容量小，磁盘缓存容量大速度慢可持久化。常见的内存缓存有 NSCache、<a href="https://github.com/tumblr/TMCache">TMMemoryCache</a>、<a href="https://github.com/pinterest/PINCache">PINMemoryCache</a>、<a href="https://github.com/ibireme/YYCache">YYMemoryCache</a>。常见的磁盘缓存有 TMDiskCache、PINDiskCache、SDWebImage。这次解读先从<a href="https://github.com/pinterest/PINCache">PINCache</a> 这个优秀的开源项目开始。PINCache 项目是在 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的基于 TMCache 的一个内存缓存，修复了 TMCache 存在的性能和死锁问题，可以说是有了一个较大的提升。</p><h3 id="PINCache-概论"><a href="#PINCache-概论" class="headerlink" title="PINCache 概论"></a>PINCache 概论</h3><p>PINCache 是多线程安全的，使用键值对来保存数据。PINCache 内部包含了 2 个类似的对象属性，一个是内存缓存 PINMemoryCache，另一个是磁盘缓存 PINDiskCache。PINCache 本身并没有过多的做处理缓存的具体工作，而是全部交给它内部的2个对象属性来实现，它只是对外提供了一些同步或者异步接口。在 iOS 中，当 App 收到内存警告或者进入后台的时候，PINCache 能够清理掉所有的内存缓存。</p><h3 id="PINCache-使用"><a href="#PINCache-使用" class="headerlink" title="PINCache 使用"></a>PINCache 使用</h3><p>采用 PINCache 项目的 Demo 来说明，这个是从服务器加载数据，再缓存下来，继而做业务逻辑处理，如果下次还需要同样的数据，要是缓存里面还有这个数据的话，那么就不需要再次发起网络请求了，而是直接使用这个数据。<strong>PINCache除了可以按键取值、按键存值、按键删值之外，还可以移除某个日期之前的缓存数据、删除所有缓存、限制缓存大小，限制缓存对象的存活时间等</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP">[[PINCache sharedCache] objectForKey:[url absoluteString]  block:^(PINCache *cache, NSString *key, id object) &#123;<br>                                     <span class="hljs-keyword">if</span> (object) &#123;<br>                                      <span class="hljs-comment">//有缓存，在这里做业务逻辑处理</span><br>                                         <span class="hljs-keyword">return</span>;<br>                                     &#125; <br>                                     <span class="hljs-comment">//没有缓存，那么去服务器加载数据，存入缓存，做业务逻辑处理</span><br>                                    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;cache miss, requesting %@&quot;</span>, url);<br>                                   [[PINCache sharedCache] setObject:data forKey:[url absoluteString]];<br>   &#125;];<br></code></pre></td></tr></table></figure><h3 id="PINCache-结构"><a href="#PINCache-结构" class="headerlink" title="PINCache 结构"></a>PINCache 结构</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled.webp" class="" title="This is an example image"><p>PINCache 的内部结构比较简单，最核心的就是 2 个缓存实现类，这里先给出一个大概的结构，让大家可以有个了解，下面就来讲讲详细的接口。</p><h3 id="PINCache-接口"><a href="#PINCache-接口" class="headerlink" title="PINCache 接口"></a>PINCache 接口</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled1.webp" class="" title="This is an example image"><p><strong>核心属性</strong><br>1.name 是 PINCache 的名字<br>2.concurrentQueue 是一个用来执行异步任务的并行队列<br>3.磁盘缓存<br>4.内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled2.webp" class="" title="This is an example image"><p><strong>初始化方法</strong><br>1.单例对象<br>2.使用名字初始化<br>3.使用名字和缓存路径来初始化</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled3.webp" class="" title="This is an example image"><p><strong>异步方法</strong><br>多数开源缓存框架的方法也就这么几个，大多类似。<br>1.异步按键取值，之后执行 Block<br>2.异步按键设值，之后执行 Block<br>3.异步按键删值，之后执行 Block<br>4.异步删除某个时间之后没有使用的缓存，之后执行 Block<br>5.异步删除所有缓存，之后执行 Block</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled4.webp" class="" title="This is an example image"><p><strong>同步方法</strong><br>这里的同步方法与异步方法的区别除了方法是否立即返回之外，还有一个区别就是异步方法可以传入一个 Block 参数<br>1.同步按键取值<br>2.同步按键设值<br>3.同步按键删值<br>4.同步删除某个时间之后没有使用的缓存<br>5.同步删除所有缓存</p><p><strong>PINCache 主要是包装 PINDiskCache 和 PINMemoryCache 的功能，具体的功能实现是交给对应的对象去实现</strong>。</p><p>###PINDiskCache 解析<br>PINDiskCache 涉及到磁盘缓存的具体实现，这里就不再一一列举所有的属性和方法了（具体的内容可以查看 PINCache 的文档），主要挑重要的取值方法，设值方法，还有删除方法来讲。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled5.webp" class="" title="This is an example image"><p>PINDiskCache 使用 semaphore 来做线程同步控制的，在写磁盘缓存的时候给 diskCache 对象加锁，写完之后解锁。在读磁盘缓存的时候也会给 diskCache 对象加锁，读完之后解锁。<em>读写过程都会加锁</em>。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled6.webp" class="" title="This is an example image"><p>写磁盘缓存的大概步骤是这样的，只是讲解一些思路，具体的详细信息需要大家查看源代码。<br>1.判断给的键值是否为空<br>2.加锁，保证多线程安全<br>3.把数据写入磁盘<br>4.更新缓存信息（包括但不限于保存磁盘缓存的总容量）<br>5.判断现在的磁盘缓存容量是否超过容量限制，若超出，按照缓存时间策略来删除对应的缓存，没有超过则不做操作<br>6.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled7.webp" class="" title="This is an example image"><p>读磁盘缓存相对简单一些，就是找到文件，然后读取。<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把数据从磁盘读到内存对象中<br>4.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled8.webp" class="" title="This is an example image"><p>移除缓存就是文件的删除操作<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把文件从磁盘中删除<br>4.解锁，让其他线程可以进入操作</p><h3 id="PINMemoryCache-解析"><a href="#PINMemoryCache-解析" class="headerlink" title="PINMemoryCache 解析"></a>PINMemoryCache 解析</h3><p>内存缓存相比磁盘缓存多了一个 App 收到内存警告或者 App 进入后台的时候清理缓存的功能。内存缓存的数据保存在字典里面。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled9.webp" class="" title="This is an example image"><p>1.收到系统内存警告通知，清理内存缓存<br>2.收到App进入后台的系统通知,清理内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled10.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.将数据存到缓存池，也就是字典里面<br>4.更新缓存对应的数据<br>5.解锁<br>6.判断内存缓存容量是否超出，超过删除部分</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled11.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.从字典里面取对应值<br>4.更新缓存对应的数据<br>5.解锁</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled12.webp" class="" title="This is an example image"><p>1.取出内存缓存值<br>2.加锁<br>3.更新内存缓存容量<br>4.删除内存缓存<br>5.更新内存缓存对应的数据<br>6.解锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存一般有 2 个部分组成，一个是内存缓存，一个是磁盘缓存。<br>1.对于<strong>内存缓存</strong>来说，一般使用字典来作为数据的缓存池，配合一个保存每个内存缓存数据的缓存时间的字典，一个保存每个内存缓存数据的缓存容量的字典，一个保存内存缓存总容量的变量。对于增删改查操作，基本也都是围绕着字典来的，需要重点注意的就是在这些个操作过程的多线程安全问题，还有同步和异步访问方法，以及异步方法中的 Block 参数的循环引用问题。<br>2.对于<strong>磁盘缓存</strong>来说，使用文件系统来保存缓存数据，配合设置文件的参数，比如文件的修改日期（访问一次即修改一次），文件的大小来管理着这个缓存数据。对缓存数据的增删改查，也就是转化成为对文件的读写删除操作。<br>3.不管是内存缓存还是磁盘缓存，在删除超过限制容量的缓存的时候总是有一个同样的策略。有优先删除缓存最久，最少使用的策略，也有优先删除，容量最大，最少使用的策略。没有什么最好的策略，只有适合你业务产品的策略。<br>最后感谢<a href="https://github.com/pinterest">PINCache的作者们</a>给我们提供了一个优秀的缓存开源框架。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://blog.ibireme.com/2015/10/26/yycache/">http://blog.ibireme.com/2015/10/26/yycache/</a><br><a href="https://github.com/pinterest/PINCache">https://github.com/pinterest/PINCache</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
