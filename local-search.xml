<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博客迁移</title>
    <link href="/2022/05/26/blog-note/"/>
    <url>/2022/05/26/blog-note/</url>
    
    <content type="html"><![CDATA[<p>以前的一些博客平台写着写着就停更了，转而使用封闭的笔记软件进行总结。恰巧这几天有时间，把部分文章从简书平台 <a href="https://www.jianshu.com/u/cea4fc286dd3">要上班的斌哥</a> 迁移到这里来，把自己的一些笔记整理分享出来。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>结构化编程 &amp; 函数式编程</title>
    <link href="/2022/05/25/functional-procedural-programming/"/>
    <url>/2022/05/25/functional-procedural-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="结构化编程-amp-函数式编程"><a href="#结构化编程-amp-函数式编程" class="headerlink" title="结构化编程 &amp; 函数式编程"></a>结构化编程 &amp; 函数式编程</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><ul><li>计算机科学家 dijkstra 认为 goto 语句的无限制跳转会损坏程序的整体结构，应该使用 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句来替代跳转语句。简而言之结构化编程对程序控制权的直接转移进行了限制和规范。</li><li>函数式编程语言中的变量是不可变的，函数式编程是对程序中的赋值操作进行限制。</li></ul><h2 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h2><ul><li><strong>结构化编程的诞生</strong></li></ul><p>dijkstra 提出为了能够证明程序的正确性，就必须把程序模块递归拆分成更小的，可以被证明的单元，dijkstra 经过研究发现，goto 语句可能会导致大模块无法被进一步拆分成更小的，可被证明的单元，同时 goto 语句的用法与 if&#x2F;then&#x2F;else 语句和 do&#x2F;while&#x2F;until 语句的作用又没有明显的区别，所以 goto 是可以被替代的。</p><p>另外一个证明是代码中使用了顺序结构，分支结构，循环结构，那么代码是一定可以被拆解成更小的，可证明的单元，而且程序员可以用顺序结构，分支结构，循环结构这 3 类结构构造出任何程序。到这里有个发现很重要，构建可被证明的模块所需要的控制单元和构建所有程序所需要的控制单元的最小集合是一样的，结构化编程就这样诞生了！！！</p><p>结构化编程范式可以将模块递归降解成可以被推导的单元，这意味着可以把模块按功能进行分解，更进一步说可以把一个大型问题拆分成一系列高级函数组合，而高级函数又可以进一步被拆分为一系列低级函数，每个被拆分出来的函数都可以使用结构化编程范式来构造程序。然后再编写相关的测试来证明这些函数程序是错误的，如果无法证明这些函数代码是错误的，那么我们就可以直接认为这些函数代码是正确的，推导到整个程序是正确的。</p><ul><li><strong>结构化编程的价值</strong></li></ul><p>结构化编程范式中最有价值的点赋予了我们创造可证伪程序单元的能力。延伸到架构设计领域，功能性拆解仍然是验证程序正确性的最佳实践之一。</p><p>我近几年来都是在接触代码重构相关的事情，项目涉及的业务多种多样，但是项目都存在一个明显的问题就是功能模块互相依赖的问题，因为依赖太多导致变更带来非常多的不确定性，同时变更带来的测试成本大无法接受的地步。另外功能模块互相依赖还会带来一个明显部署问题，由于互相依赖，模块无法单独部署，需要所有的模块一起部署。随之而来的还有编译问题，互相依赖过多，一旦被依赖方发生变动，所有的依赖方都必须重新编译，这个最明显的是很多项目中的 common 模块。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li><strong>函数式编程的价值</strong></li></ul><p>函数式编程对变量可变性进行限制，而不可变性正是软件架构设计中需要考虑的重点。为什么软件架构设计中需要考虑可变性呢？因为所有的竞争问题，死锁问题，并发更新问题都是由变量的可变性造成的，如果变量永远不会被改变，那么就不会产生竞争或者并发问题。如果锁的状态是不可变的，那么就不会产生死锁问题。在软件架构设计中需要对并发问题保持高度关注，在实际应用中不可变性这个特点是否具备可行性呢？</p><ul><li><strong>可变性隔离</strong></li></ul><p>可变性隔离一种常见的方式是把应用程序的内部服务进行划分，划分为可变的和不可变的组件。不可变组件用纯函数来执行任务，期间不能修改任何的状态，不可变组件将通过非函数式组件通信的方式来修改变量的状态，由于修改变量的状态会产生一系列编发问题，所以通常采用某种事务型内存来保护可变变量，避免并发和死锁问题。</p><p>一个设计良好的软件架构中应该将状态修改的部分和不需要修改状态的部分分别隔离成单独的组件，然后用合适的机制来保护可变量，所以在架构设计中应该致力于将大部分处理逻辑都归纳到不可变组件中，可变状态组件的逻辑越少越好。</p><ul><li><strong>事件溯源</strong></li></ul><p>随着存储和计算能力的大幅提升，我们有可能做到只存储事务记录，不存储具体状态，当需要具体状态是，我们只要从头开始计算所有的事务即可，这样的设计看起来是很美好，不过实用性是差一些。  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结笔记</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/过程式编程</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E4%BA%8B%E5%8A%A1%E5%86%85%E5%AD%98">https://zh.m.wikipedia.org/zh-hans/事务内存</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/函数式编程</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程</title>
    <link href="/2022/05/24/object-oriented-programming/"/>
    <url>/2022/05/24/object-oriented-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>现在软件开发当中，面向对象编程已经成为一个黄金标准，那究竟什么是面向对象？对于这个问题有很多回答，一种回答是 “数据与函数的组合”，另一种回答是对真实世界进行建模的方式，还有另外一种回答是涉及到封装，继承，多态，也就是说面向对象是这三项的组合。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装这个特性因为在面向对象编程用的多了，导致不少人经常会认为它就是面向对象的一部分，其实不是这样的。C 语言中的 struct 结构体就是支持完整的封装，在引入 point.h 文件的程序中是没有 Point 这个结构体的内部访问权限的，只能调用 makePoint 和 distance 函数，但是不清楚函数内部的具体实现细节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// point.h </span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>;</span><br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span>;<br><br><span class="hljs-comment">// point.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Point* <span class="hljs-title function_">makePoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>    <span class="hljs-comment">// 构造 Point</span><br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Point *p1, <span class="hljs-keyword">struct</span> Point *p2)</span> &#123;<br>    <span class="hljs-comment">// 计算距离</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 作为一个面向对象编程语言，在封装的完整性反而不如 C 语言。稍微改造一下上面的 Point 例子，虽然编译器会禁止外部 x,y 这 2 个变量的范围，但是调用者都知道了它们的存在。不过 C++ 在语法层面引入了 public，private，protected 这些访问控制的关键词，在一定程度上维护了封装性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y);<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>另一个面向对象编程语言 Java 则彻底抛弃了头文件和实现文件分离的编程方式，这也是破坏封装完整性的表现，因为我们无法区分一个类的声明和定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> y;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> &#123;<br>      <span class="hljs-comment">// 构造 Point</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(Point p1, Point p2)</span> &#123;<br>      <span class="hljs-comment">// 计算距离</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的例子，我们基本可以得出强封装并不是面向对象编程的必要条件。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的主要作用是让程序员可以在某个作用域内对外部定义的一组变量与函数进行覆盖。但是实际上 C 语言也可以做到，不仅仅是面向对象编程语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// namedPoint.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span>;</span><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// namedPoint.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> &#123;</span><br>    <span class="hljs-type">double</span> x,y;<br>    <span class="hljs-type">char</span>* name;<br>&#125;<br><br><span class="hljs-keyword">struct</span> NamedPoint* <span class="hljs-title function_">makeNamedPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">char</span> *name)</span> &#123;<br>    <span class="hljs-comment">// 构造 NamedPoint</span><br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">orgin</span> =</span> makeNamedPoint(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;origin&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NamedPoint</span> *<span class="hljs-title">upperRight</span> =</span> makeNamedPoint(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;upperRight&quot;</span>);<br><br>distance((<span class="hljs-keyword">struct</span> Point *)orgin, (<span class="hljs-keyword">struct</span> Point *)upperRight);<br></code></pre></td></tr></table></figure><p>看 main.c 里面的代码，因为 NamedPoint 和 Point 结构体的前 2 个成员顺序一致，所以 NamedPoint 可以被伪装成 Point 来使用，在程序中必须显式把 NamedPoint 强制转换为 Point 类型。通过上面的案例，我们可以了解到继承的特性在面向对象被发明之前就已经在使用了。但是在面向对象编程语言中，这种向上的类型转换是隐式，虽然面向对象编程在继承性上没有突破，但是至少在数据类型的转换上提供了便利。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象编程涉及到封装，继承，多态这 3 个特性，前面提到了封装和继承都不是面向对象编程独有特性，那么多态是不是面向对象编程独有的呢？答案也是否定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ((c = getchar()) != EOF) &#123;<br>        <span class="hljs-built_in">putchar</span>(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getchar() 负责从 STDIN 读数据，putchar() 负责往 STDOUT 写数据，那么 STDIN 和 STDOUT 又具体表示哪些设备呢？显然 getchar 和 putchar 这类函数就具有多态性，因为他们的行为依赖于 STDIN 和 STDOUT 的具体实现。</p><p>以 Unix 为例，每个 IO 设备的驱动程序都要提供 open,close,read,write,seek 这 5 个标准函数实现。在 FILE 数据结构体中也包含了这 5 个标准函数对于的函数指针，这些函数指针用于指向 IO 设备驱动提供标准函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// FILE 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span> &#123;</span><br>    <span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode)<br>    <span class="hljs-type">void</span> (*close)();<br>    <span class="hljs-type">int</span> (*read)();<br>    <span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>);<br>    <span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode);<br>&#125;<br><br><span class="hljs-comment">// 设备驱动程序实现</span><br><span class="hljs-type">void</span> (*open)(<span class="hljs-type">char</span>* name,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// open 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*close)() &#123;<br>    <span class="hljs-comment">// close 实现</span><br>&#125;<br><span class="hljs-type">int</span> (*read)() &#123;<br>    <span class="hljs-comment">// read 实现</span><br>&#125;<br><span class="hljs-type">void</span> (*write)(<span class="hljs-type">char</span>) &#123;<br>    <span class="hljs-comment">// write 实现</span><br>&#125;<br><br><span class="hljs-type">void</span> (*seek)(<span class="hljs-type">long</span> index,<span class="hljs-type">int</span> mode) &#123;<br>    <span class="hljs-comment">// seek 实现</span><br>&#125;<br><br><span class="hljs-comment">//getchar 函数的大致实现</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FILE</span>* <span class="hljs-title">STDIN</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getchar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> STDIN-&gt;read()<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的程序中看，getchar 函数本质上是使用了 STDIN 来调用保存在 FILE 结构中的 read 函数指针所指向的函数实现。说到底，多态其实就是函数指针的一种应用。用函数指针实现多态的最大问题就是函数指针的危险性了，因为函数指针的调用依赖于程序员的约定，程序员必须严格遵守规则按照函数指针的类型来初始化函数指针，并严格按照函数指针的类型来使用函数指针。在编程中可以确定计算机能够遵守规则，但是无法确定程序员会遵守规则。</p><p>同继承一样，面向对象编程本质上还是没有在多态上进行创新，面向对象编程语言为程序员消除了人工遵守规则的必要，它让多态变得更安全，更便于使用了。<strong>结构化编程对程序控制权的直接转移进行了限制和规范，而面向对象编程其实是对程序的间接控制权的转移进行了限制，具体一些就是原来多态的调用只要函数类型一致就可以使用函数指针进行调用，而不需要有什么其他额外关系，但是现在面向对象编程在这个基础上加上了一些数据类型的限制。</strong></p><h3 id="带来的价值"><a href="#带来的价值" class="headerlink" title="带来的价值"></a>带来的价值</h3><ul><li>插件式架构</li></ul><p>Unix 系统将 IO 设备设计成插件式架构，随后在多个操作系统都有应用，即使知道多态有如此多的优点，但是碍于函数指针是一项及其危险的技术，大部分程序员还是不敢将插件式架构引入系统。但是面向对象编程的出现使得插件式架构可以安全地被应用在任何地方。</p><ul><li>依赖反转</li></ul><p>在安全和便利的多态技术出现之前，软件的典型调用树是这样的，HightLayer 模块要调用 MiddleLayer 模块，HightLayer 模块必须要依赖 MiddleLayer 模块 ，程序的源代码依赖不可避免的需要跟随程序的控制流。这让我们这些程序员在软件架构上没有什么其他多余的选择，软件的系统行为决定了程序的控制流，而控制流则决定了源代码依赖关系。</p><p>依赖关系和控制关系如下图所示，实线表示源代码依赖关系，虚线表示控制流关系。</p><img src="/2022/05/24/object-oriented-programming/Untitled.png" class="" title="This is an example image"><p>现在利用面向对象编程语言提供的安全便利的多态实线，无论我们面对怎么样的源代码依赖，我们都可以将其反转（源代码依赖方向和控制流方向相反）。如下图所示，模块 HightLayer 调用模块 MiddleLayer 中的 function 函数，这里的调用在是通过源代码界别的 interface 来实现的，在程序的实际运行过程中，interface 这个概念是不存在的，HightLayer 会直接调用 MiddleLayer 中的 function 函数。</p><img src="/2022/05/24/object-oriented-programming/Untitled01.png" class="" title="This is an example image"><p>延伸一下，这种能力在实际的软件架构设计中有什么作用呢？看下图，我们可以让用户界面和数据库都依赖业务逻辑，业务逻辑不需要引入用户界面和数据库的依赖，这样用户界面和数据库就成为业务逻辑的插件。这样一来，用户界面，业务逻辑，数据库就可以成为 3 个独立的组件，可以单独编译和部署，同时用户界面或者数据库的修改就不会对业务逻辑产生任何的影响。进一步说，当某个组件需要修改是，仅仅需要重新编译和部署该组件，不需要更改其他的组件，这就是独立部署能力。再进一步说，如果组件可以独立部署，那么就意味着组件可以由不同的团队并行开发，这就是架构的独立开发能力，也是架构和团队组织互相影响。</p><img src="/2022/05/24/object-oriented-programming/Untitled02.png" class="" title="This is an example image"><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>来自 <a href="https://book.douban.com/subject/30333919/">架构整洁之道</a> 总结</li><li><a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">https://zh.wikipedia.org/wiki/面向对象程序设计</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程范式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈软件架构的价值</title>
    <link href="/2022/05/23/talking-about-the-value-of-architecture/"/>
    <url>/2022/05/23/talking-about-the-value-of-architecture/</url>
    
    <content type="html"><![CDATA[<p>一个业务功能，新手和高手同样都可以实现，为什么还要招聘高手呢？在项目预算支持的情况下，通常会招聘更多有经验的程序员来进行开发。</p><p>软件行业中，确实是普遍存在上述的这类现象。 调试并实现一个业务功能并不需要非常高深的知识，甚至一名初入行的实习生都可以做到，将需求文档转换为能够实际上线运行的代码也不会多难，实习生写出来的代码可能不够优雅，但是确实能够正常工作。</p><p>在系统运作一段时间之后，新手可能需要 007 疯狂加班来实现需求。高手因为丰富的架构设计经验，提前做好软件架构设计，系统能够适应各类变化，新需求只需要很少的时间就能够上线。</p><h3 id="什么是软件架构"><a href="#什么是软件架构" class="headerlink" title="什么是软件架构"></a>什么是软件架构</h3><p>回想我自己的从业经历，确实经历不少这样的场景。某个软件历史悠久，各个组件互相依赖，到处充满了垃圾代码。即使是小改动，也是牵一发而动全身，让整个项目的产品，设计，开发，测试人员充满痛苦。每逢这个时候就会臆想，这个软件要是采用了好的架构设计，可以大大节省软件的开发和测试成本，每次变更都能控制最小影响范围，用最小的成本满足功能性需求。</p><p>好的架构设计具有这么大的魅力，那究竟什么才是软件架构？类比建筑，软件架构就是软件的组织架构，它关注组件，类，函数，模块，层级的设计。</p><h3 id="软件架构有什么用"><a href="#软件架构有什么用" class="headerlink" title="软件架构有什么用"></a>软件架构有什么用</h3><p>正如前面所提，它的目标就是用最小的人力成本来满足构建和维护系统的需求。软件架构具有 2 个方面的价值，一个价值是架构价值，一个价值是行为价值。</p><p>行为价值比较直观，就是程序员把需求文档转换为上线运行的代码，给用户创造价值，同时获取利润。</p><p>对于架构价值的理解可能比较抽象，提一些具体场景，正常来说第一个版本的系统通常都是没有经过什么设计，匆匆忙忙被构建起来。后面业务有了一定的发展，为了加快发布的速度，团队开始招聘新人，同时迫于业务压力，对代码质量提升和软件架构设计存在长期忽视。团队经常加班，拼命工作，团队中的个人不管投入多少个人时间，救了多少火，产出始终上不去。团队的时间大部分都消耗在对现有系统的修复上，新功能的实现投入时间并没有多少，陷入恶性循环。软件架构的价值之一就是要解决类似这个场景的问题，良好的软件架构设计能够避免系统陷入混乱，让软件容易被修改，新增需求或者变更需求，随之所需的软件变更可以简单而方便的实现。</p><h3 id="坚持软件架构的价值"><a href="#坚持软件架构的价值" class="headerlink" title="坚持软件架构的价值"></a>坚持软件架构的价值</h3><p>软件架构设计是一个重要但不紧急的事情。在业务迭代中，技术团队经常容易陷入不重要但紧急的需求旋涡中。对于技术 leader 来说，就是要坚持架构设计的价值，同时也要说服其他人相信架构设计的价值，这也是技术 leader 的价值之一， 只有这样才有可能在紧凑的业务迭代周期中预留部分架构设计和代码 review 时间，以尽量延长软件的生命时间，降低软件的变更成本，让技术团队能够更愉悦的工作。</p><p>参考</p><ol><li><a href="https://book.douban.com/subject/30333919/">https://book.douban.com/subject/30333919/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑思维</title>
    <link href="/2021/07/10/logic-note/"/>
    <url>/2021/07/10/logic-note/</url>
    
    <content type="html"><![CDATA[<p>一直认为能够有逻辑的交流，或者有逻辑的解决问题是一个优秀工程师的必备品质，所以在内部做了一次关于逻辑思维方面的分享，得到不少积极的反馈。</p><div class="row">    <embed src="./logic-note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    
    <tags>
      
      <tag>效率工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash 快捷键</title>
    <link href="/2019/04/26/bash-hot-keys/"/>
    <url>/2019/04/26/bash-hot-keys/</url>
    
    <content type="html"><![CDATA[<h1 id="Bash-快捷键"><a href="#Bash-快捷键" class="headerlink" title="Bash 快捷键"></a>Bash 快捷键</h1><p><strong>标签</strong></p><ul><li>新建标签：command + t</li><li>关闭标签：command + w</li><li>切换标签：command + 数字 &#x2F; command + 左右方向键</li><li>切换全屏：command + enter</li><li>查找：command + f</li></ul><p><strong>操作</strong></p><ul><li>到行首：ctrl + a</li><li>到行尾：ctrl + e</li><li>清除当前行：ctrl + u</li><li>删除到文本末尾：ctrl + k</li><li>删除当前光标的字符：ctrl + d</li><li>删除光标之前的字符：ctrl + h</li><li>删除光标之前的单词：ctrl + w</li><li>前进后退：ctrl + f&#x2F;b (相当于左右方向键)</li><li>上一条命令：ctrl + p</li><li>搜索命令历史：ctrl + r</li><li>交换光标处文本：ctrl + t</li><li>清屏1：command + r</li><li>清屏2：ctrl + l</li></ul><p><strong>分屏</strong></p><ul><li>垂直分屏：command + d</li><li>水平分屏：command + shift + d</li><li>切换屏幕：command + option + 方向键 command + [ 或 command + ]</li><li>查看历史命令：command + ;</li><li>查看剪贴板历史：command + shift + h</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>效率工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS Ping 框架 - SimplePing 源码解读</title>
    <link href="/2018/03/21/reading-source-code-of-SimplePing/"/>
    <url>/2018/03/21/reading-source-code-of-SimplePing/</url>
    
    <content type="html"><![CDATA[<h1 id="SimplePing-解读"><a href="#SimplePing-解读" class="headerlink" title="SimplePing 解读"></a>SimplePing 解读</h1><p>ping 程序对于开发人员来说应该是不会陌生的, ping 通常用来探测主机到主机之间是否可以通信。如果可以 ping 通，意味着可以和该主机建立网络连接，就像这样的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">➜  ~<span class="hljs-built_in"> ping </span>www.qq.com<span class="hljs-built_in"></span><br><span class="hljs-built_in">PING </span>www.qq.com (182.254.34.74): 56 data bytes<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=0 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=22.996 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=36.688 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=25.390 ms<br>64 bytes <span class="hljs-keyword">from</span> 182.254.34.74: <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=53 <span class="hljs-attribute">time</span>=25.516 ms<br></code></pre></td></tr></table></figure><p>如果不能 ping 通，那就意味着无法和该主机建立网络连接，就像下面这样的。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">➜  ~ ping www.google.com<br>PING www.google.com (<span class="hljs-number">66.220</span><span class="hljs-number">.147</span><span class="hljs-number">.47</span>): <span class="hljs-number">56</span> data bytes<br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">0</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">1</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">2</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">3</span><br>Request <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">for</span> icmp_seq <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>Apple 的 <a href="https://developer.apple.com/library/content/samplecode/SimplePing/Introduction/Intro.html#//apple_ref/doc/uid/DTS10000716">SimplePing</a> 封装了 ping 的功能，它利用 resolve host，create socket(send &amp; recv data), 解析 ICMP 包验证 checksum 等实现了 ping 功能。并且支持 iPv4 和 iPv6。</p><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><p>ping 功能使用是 ICMP 协议（Internet Control Message Protocol），ICMP 协议定义了一组错误信息，当路由器或者主机无法成功处理一个IP 封包的时候，能够将错误信息回送给来源主机，ICMP 常见的错误如下。</p><ol><li>传输线路或者节点故障导致无法到达目的地主机</li><li>路由器封包重组失败</li><li>封包存活时间（Time To Live,TTL）变成 0 (防止封包在网络中永无止境得绕圈)</li><li>IP 首部的错误检查码发现错误</li></ol><h3 id="iOS-SimplePing-的使用"><a href="#iOS-SimplePing-的使用" class="headerlink" title="iOS SimplePing 的使用"></a>iOS SimplePing 的使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1. 利用 HostName 创建 SimplePing</span><br>SimplePing *pinger = [[SimplePing alloc] initWithHostName:<span class="hljs-string">@&quot;www.apple.com&quot;</span>];<br><span class="hljs-keyword">self</span>.pinger = pinger;<br><span class="hljs-comment">// 2. 指定 IP 地址类型</span><br><span class="hljs-keyword">if</span> (isIpv4 &amp;&amp; !isIpv6) &#123;<br>    pinger.addressStyle = SimplePingAddressStyleICMPv4;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isIpv6 &amp;&amp; !isIpv4) &#123;<br>    pinger.addressStyle = SimplePingAddressStyleICMPv6;<br>&#125;<br><span class="hljs-comment">// 3. 设置 delegate,用于接收回调信息</span><br>pinger.delegate = <span class="hljs-keyword">self</span>;<br><span class="hljs-comment">// 4. 开始 ping</span><br>[pinger start];<br></code></pre></td></tr></table></figure><p>SimplePing 的使用还是非常简单的，</p><ol><li>利用 HostName 创建 SimplePing</li><li>指定 IP 地址类型</li><li>设置 delegate,用于接收回调信息</li><li>开始 ping</li></ol><p>delegate 的回调方法体现了 ping 的过程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 解析 HostName 拿到 ip 地址之后，发送封包</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didStartWithAddress:(<span class="hljs-built_in">NSData</span> *)address<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;pinging %@&quot;</span>, displayAddressForAddress(address));<br>    [<span class="hljs-keyword">self</span> sendPing];<br>&#125;<br><span class="hljs-comment">// ping 功能启动失败</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didFailWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;failed: %@&quot;</span>, shortErrorFromError(error));<br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><span class="hljs-comment">// ping 成功发送封包</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didSendPacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u sent&quot;</span>, sequenceNumber);<br>&#125;<br><span class="hljs-comment">// ping 发送封包失败</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didFailToSendPacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber error:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u send failed: %@&quot;</span>, sequenceNumber,shortErrorFromError(error));<br>&#125;<br><span class="hljs-comment">// ping 发送封包之后收到响应</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didReceivePingResponsePacket:(<span class="hljs-built_in">NSData</span> *)packet sequenceNumber:(uint16_t)sequenceNumber<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;#%u received, size=%zu&quot;</span>, sequenceNumber, packet.length);<br>&#125;<br><span class="hljs-comment">// ping 接收响应封包发生异常</span><br>- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didReceiveUnexpectedPacket:(<span class="hljs-built_in">NSData</span> *)packet<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;unexpected packet, size=%zu&quot;</span>, packet.length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SimplePing-的流程"><a href="#SimplePing-的流程" class="headerlink" title="SimplePing 的流程"></a>SimplePing 的流程</h3><img src="/2018/03/21/reading-source-code-of-SimplePing/Untitled.webp" class="" title="image"><p>上图是 SimplePing 执行一次 ping IPv4 地址的流程图，<br>ping 的实现并不负责，一共有以下几个步骤</p><ol><li>解析传入的 HostName，获取第一个可用 IP 地址</li><li>创建传输&#x2F;接收数据的 socket</li><li>发送数据，封装一个 ICMP 包</li><li>解析目标 IP 传回的 ICMP 包</li></ol><h3 id="HostName-的解析"><a href="#HostName-的解析" class="headerlink" title="HostName 的解析"></a>HostName 的解析</h3><p>关于 HostName 的解析，SimplePing 采用 CFHost 这个异步 API 方案，通过CFHost解析主机名主要有以下几个步骤：</p><ol><li>通过调用 CFHostCreateWithName 创建一个 CFHostRef 对象。</li><li>调用 CFHostSetClient 并且提供一个上下文对象和回调函数，这个回调函数在解析结束的时候会被调用。</li><li>调用 CFHostScheduleWithRunLoop 用于在 RunLoop 中执行具体的解析操作。</li><li>调用 CFHostStartInfoResolution 来告诉解析器开始解析，把它的第二个参数设置为 kCFHostAddresses 表明你想要返回一个 IP 地址。</li><li>等待解析器调用你的回调函数，通过你的回调函数，调用 CFHostGetAddressing 函数来获取解析结果。这个函数返回 CFDataRef 对象的一个数组，其中的每一个都包含一个 POSIX 的 sockaddr 结构体。</li></ol><p>下面的这段代码执行的是 1 - 4  过程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)start &#123;<br>    Boolean             success;<br>    <span class="hljs-built_in">CFHostClientContext</span> context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-built_in">CFStreamError</span>       streamError;<br>    <br>    assert(<span class="hljs-keyword">self</span>.host == <span class="hljs-literal">NULL</span>);<br>    assert(<span class="hljs-keyword">self</span>.hostAddress == <span class="hljs-literal">nil</span>);<br><br>    <span class="hljs-keyword">self</span>.host = (<span class="hljs-built_in">CFHostRef</span>) <span class="hljs-built_in">CFAutorelease</span>( <span class="hljs-built_in">CFHostCreateWithName</span>(<span class="hljs-literal">NULL</span>, (__bridge <span class="hljs-built_in">CFStringRef</span>) <span class="hljs-keyword">self</span>.hostName) );<br>    assert(<span class="hljs-keyword">self</span>.host != <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-built_in">CFHostSetClient</span>(<span class="hljs-keyword">self</span>.host, HostResolveCallback, &amp;context);<br>    <br>    <span class="hljs-built_in">CFHostScheduleWithRunLoop</span>(<span class="hljs-keyword">self</span>.host, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode);<br>    <br>    success = <span class="hljs-built_in">CFHostStartInfoResolution</span>(<span class="hljs-keyword">self</span>.host, kCFHostAddresses, &amp;streamError);<br>    <span class="hljs-keyword">if</span> ( ! success ) &#123;<br>        [<span class="hljs-keyword">self</span> didFailWithHostStreamError:streamError];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在系统解析 HostName 成功之后会调用 HostResolveCallback 这个回调，这个回调的作用相当于重定向，将内容从 c 转成适当的 Objective-C 内容。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> HostResolveCallback(<span class="hljs-built_in">CFHostRef</span> theHost, <span class="hljs-built_in">CFHostInfoType</span> typeInfo, <span class="hljs-keyword">const</span> <span class="hljs-built_in">CFStreamError</span> *error, <span class="hljs-type">void</span> *info) &#123;<br>    <span class="hljs-comment">// This C routine is called by CFHost when the host resolution is complete. </span><br>    <span class="hljs-comment">// It just redirects the call to the appropriate Objective-C method.</span><br>    SimplePing *    obj;<br>    obj = (__bridge SimplePing *) info;<br>    assert([obj isKindOfClass:[SimplePing <span class="hljs-keyword">class</span>]]);<br>    <span class="hljs-comment">// 省略代码 ......</span><br>    <span class="hljs-keyword">if</span> ( (error != <span class="hljs-literal">NULL</span>) &amp;&amp; (error-&gt;domain != <span class="hljs-number">0</span>) ) &#123;<br>        [obj didFailWithHostStreamError:*error];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 在这个方法获取 HostName 对应的地址</span><br>        [obj hostResolutionDone];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 CFHostGetAddressing 函数来获取解析结果，这个函数返回一个数组，从这个数组中取得 HostName 对应的 IP。从服务端的角度来说，为了实现负载均衡，一个域名是可以对应多个 IP 的，但是从客户端的角度来说，一个域名就是对应一个 IP。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)hostResolutionDone &#123;<br>    Boolean     resolved;<br>    <span class="hljs-built_in">NSArray</span> *   addresses;<br>    <br>    <span class="hljs-comment">// Find the first appropriate address.</span><br>    <br>    addresses = (__bridge <span class="hljs-built_in">NSArray</span> *) <span class="hljs-built_in">CFHostGetAddressing</span>(<span class="hljs-keyword">self</span>.host, &amp;resolved);<br>    <span class="hljs-keyword">if</span> ( resolved &amp;&amp; (addresses != <span class="hljs-literal">nil</span>) ) &#123;<br>        resolved = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSData</span> * address <span class="hljs-keyword">in</span> addresses) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr * addrPtr;<br>            <br>            addrPtr = (<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *) address.bytes;<br>            <span class="hljs-keyword">if</span> ( address.length &gt;= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr) ) &#123;<br>                <span class="hljs-keyword">switch</span> (addrPtr-&gt;sa_family) &#123;<br>                    <span class="hljs-keyword">case</span> AF_INET: &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.addressStyle != SimplePingAddressStyleICMPv6) &#123;<br>                            <span class="hljs-keyword">self</span>.hostAddress = address;<br>                            resolved = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> AF_INET6: &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.addressStyle != SimplePingAddressStyleICMPv4) &#123;<br>                            <span class="hljs-keyword">self</span>.hostAddress = address;<br>                            resolved = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (resolved) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// We&#x27;re done resolving, so shut that down.</span><br>    <br>    [<span class="hljs-keyword">self</span> stopHostResolution];<br>    <br>    <span class="hljs-comment">// If all is OK, start the send and receive infrastructure, otherwise stop.</span><br>    <br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>        [<span class="hljs-keyword">self</span> startWithHostAddress];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        [<span class="hljs-keyword">self</span> didFailWithError:[<span class="hljs-built_in">NSError</span> errorWithDomain:(<span class="hljs-built_in">NSString</span> *)kCFErrorDomainCFNetwork code:kCFHostErrorHostNotFound userInfo:<span class="hljs-literal">nil</span>]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Socket-操作"><a href="#Socket-操作" class="headerlink" title="Socket 操作"></a>Socket 操作</h3><p>HostName 解析成功拿到对应的 IP 之后，SimplePing 调用startWithHostAddress 创建 socket 。</p><ol><li>使用 CFSocketCreateWithNative 创建一个 CFSocket</li><li>使用 CFSocketCreateRunLoopSource 为 CFSocket 创建一个 CFRunLoopSourceRef，</li><li>使用 CFRunLoopAddSource 将 CFRunLoopSourceRef 添加到 RunLoop 的 kCFRunLoopDefaultMode 模式中。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)startWithHostAddress &#123;<br> <span class="hljs-comment">// 省略代码 ......</span><br>        <span class="hljs-built_in">CFSocketContext</span>         context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br>        <span class="hljs-built_in">CFRunLoopSourceRef</span>      rls;<br>        <span class="hljs-type">id</span>&lt;SimplePingDelegate&gt;  strongDelegate;<br>        <br>        <span class="hljs-comment">// Wrap it in a CFSocket and schedule it on the runloop.</span><br>        <br>        <span class="hljs-keyword">self</span>.socket = (<span class="hljs-built_in">CFSocketRef</span>) <span class="hljs-built_in">CFAutorelease</span>( <span class="hljs-built_in">CFSocketCreateWithNative</span>(<span class="hljs-literal">NULL</span>, fd, kCFSocketReadCallBack, SocketReadCallback, &amp;context) );<br>        assert(<span class="hljs-keyword">self</span>.socket != <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-comment">// The socket will now take care of cleaning up our file descriptor.</span><br>        <br>        assert( <span class="hljs-built_in">CFSocketGetSocketFlags</span>(<span class="hljs-keyword">self</span>.socket) &amp; kCFSocketCloseOnInvalidate );<br>        fd = <span class="hljs-number">-1</span>;<br>        <br>        rls = <span class="hljs-built_in">CFSocketCreateRunLoopSource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">self</span>.socket, <span class="hljs-number">0</span>);<br>        assert(rls != <span class="hljs-literal">NULL</span>);<br>        <br>        <span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), rls, kCFRunLoopDefaultMode);<br>    <br>        <span class="hljs-built_in">CFRelease</span>(rls)；<br> <span class="hljs-comment">// 省略代码 ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 CFSocketCreateWithNative 的官方文档描述中有提到，CFSocketCreateWithNative 在创建 socket 的时候是有一个复用机制的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">The <span class="hljs-built_in">new</span> CFSocket <span class="hljs-keyword">object</span>, <span class="hljs-keyword">or</span> `<span class="hljs-keyword">NULL</span>` <span class="hljs-keyword">if</span> an error occurred. <br><span class="hljs-keyword">If</span> a CFSocket <span class="hljs-keyword">object</span> already <span class="hljs-keyword">exists</span> <span class="hljs-keyword">for</span> `sock`, <br>the <span class="hljs-keyword">function</span> <span class="hljs-keyword">returns</span> the pre-existing <span class="hljs-keyword">object</span> <span class="hljs-keyword">instead</span> <span class="hljs-keyword">of</span> creating a <span class="hljs-built_in">new</span> <span class="hljs-keyword">object</span>; <br></code></pre></td></tr></table></figure><h3 id="封装-ICMP-包"><a href="#封装-ICMP-包" class="headerlink" title="封装 ICMP 包"></a>封装 ICMP 包</h3><p>在 socket 创建完成之后，接下来就要开始组装 IP 封包并发送了。组装 IP 封包并发送的过程需要我们手动在这个回调方法触发。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)simplePing:(SimplePing *)pinger didStartWithAddress:(<span class="hljs-built_in">NSData</span> *)address<br>&#123;<br><span class="hljs-comment">// 调用 - (void)sendPingWithData:(NSData *)data </span><br>&#125;<br></code></pre></td></tr></table></figure><p>sendPingWithData 这个方法做的操作是组装 IP 封包然后发送封包，调用这个过程对应的回调方法。发送封包的过程是调用 sendto 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sendPingWithData:(<span class="hljs-built_in">NSData</span> *)data &#123;<br>    <span class="hljs-comment">// 省略代码 ......</span><br><br>    <span class="hljs-comment">// Send the packet.</span><br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.socket == <span class="hljs-literal">NULL</span>) &#123;<br>        bytesSent = <span class="hljs-number">-1</span>;<br>        err = EBADF;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bytesSent = sendto(<br>            <span class="hljs-built_in">CFSocketGetNative</span>(<span class="hljs-keyword">self</span>.socket),<br>            packet.bytes,<br>            packet.length, <br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-keyword">self</span>.hostAddress.bytes, <br>            (socklen_t) <span class="hljs-keyword">self</span>.hostAddress.length<br>        );<br>        err = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (bytesSent &lt; <span class="hljs-number">0</span>) &#123;<br>            err = errno;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 省略代码 ......</span><br></code></pre></td></tr></table></figure><p>组装 IP 封包是调用下面这个方法来完成，这个方法把数据按照 ICMPHeader 结构体的格式进行初始化并返回 IP 封包，关于 ICMPHeader 的结构这里就不再累赘，通过 ICMPHeader 结构体的定义就可以明白。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSData</span> *)pingPacketWithType:(uint8_t)type <br>                   payload:(<span class="hljs-built_in">NSData</span> *)payload <br>                  requiresChecksum:(<span class="hljs-type">BOOL</span>)requiresChecksum ；<br></code></pre></td></tr></table></figure><h3 id="解析-ICMP-包"><a href="#解析-ICMP-包" class="headerlink" title="解析 ICMP 包"></a>解析 ICMP 包</h3><p>完成了发送操作之后，接下来就是等待 ping 的响应了。当 socket 收到 ping 响应的时候回调 SocketReadCallback ，这个回调的作用相当于重定向，将内容从 c 转成适当的 Objective-C 内容，SocketReadCallback 里面调用了 readData 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> SocketReadCallback(<span class="hljs-built_in">CFSocketRef</span> s, <span class="hljs-built_in">CFSocketCallBackType</span> type, <span class="hljs-built_in">CFDataRef</span> address, <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">void</span> *info) <br></code></pre></td></tr></table></figure><p>在  readData 方法里面做的工作就是读取响应数据，验证响应的数据正确性，执行相应的回调方法。与sendto对应，读取数据使用的是 recvfrom 方法。验证响应数据调用的是下面的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)validatePing4ResponsePacket:(<span class="hljs-built_in">NSMutableData</span> *)packet sequenceNumber:(uint16_t *)sequenceNumberPtr <br></code></pre></td></tr></table></figure><p>这个方法接收 ping 响应数据的时候，会对 ICMP 包进行校验，会跳过 IP 头，毕竟 IP 首部对于 ping 功能来说并不重要，重要的是 ICMP 协议的内容，其中主要验证的字段是 checksum 和 sequenceNumber（iPv6 只需要验证 sequenceNumber）。<br>停止 ping 的时候需要做一些清理工作，包括 socket 和 CFHost 对应的销毁。<br>到这里，整个 ping 的基本流程就结束了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ICMP 协议规定，目的主机必须返回 ICMP 回送应答消息给源主机，如果源主机在一定时间内收到应答，则认为主机可达，而 ping 功能使用的是 ICMP 协议。<br>SimplePing 实现 ping 操作的原理步骤是这样的，先解析出 HostName 对应的 IP 地址，这个才知道数据包要发送给哪个目的主机，接着构造符合 ICMP 协议格式的数据包并发送，等待目的主机响应。一段时间过后，目的主机响应数据到达源主机，源主机接收响应数据包，验证数据包，然后去掉数据包的 IP 首部，拿到 ICMP 数据。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/ResolvingDNSHostnames.html#//apple_ref/doc/uid/TP40012543-SW1">https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/ResolvingDNSHostnames.html#//apple_ref/doc/uid/TP40012543-SW1</a></li><li><a href="https://github.com/iOS-Developer-Documents-Chinese/iOS-Developer-Documents-Chinese/blob/master/Socket/DNS%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E8%A7%A3%E6%9E%90.md">https://github.com/iOS-Developer-Documents-Chinese/iOS-Developer-Documents-Chinese/blob/master/Socket/DNS%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84%E8%A7%A3%E6%9E%90.md</a></li><li><a href="https://www.cnblogs.com/cuihongyu3503319/archive/2012/07/09/2583129.html">https://www.cnblogs.com/cuihongyu3503319/archive/2012/07/09/2583129.html</a></li><li><a href="http://blog.163.com/qhj4433210@126/blog/static/165975282201592251248584/">http://blog.163.com/qhj4433210@126/blog/static/165975282201592251248584/</a></li><li><a href="http://blog.csdn.net/inject2006/article/details/2139149">http://blog.csdn.net/inject2006/article/details/2139149</a></li><li><a href="https://zhaoxinyu.me/2017-04-12-simple-ping/">https://zhaoxinyu.me/2017-04-12-simple-ping/</a></li><li><a href="https://en.wikipedia.org/wiki/IPv4_header_checksum">https://en.wikipedia.org/wiki/IPv4_header_checksum</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解存储器层次结构</title>
    <link href="/2017/10/01/operating-system-storage/"/>
    <url>/2017/10/01/operating-system-storage/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于一个简单的计算机系统模型，我们可以将存储器系统看做是一个线性的字节数组，而 CPU 能够在一个常数时间内访问每个存储器的位置。实际上，存储器系统（memory system）是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU 寄存器保存着最常用的数据。靠近 CPU 的小的、快速的高速缓存存储器（cache memory）做为一部分存储在相对慢速的主存储器（main memory）中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而磁盘常常作为存储在通过网络连接的其他机器的磁盘的缓存。</p><h3 id="Cache-基本模型"><a href="#Cache-基本模型" class="headerlink" title="Cache 基本模型"></a>Cache 基本模型</h3><img src="/2017/10/01/operating-system-storage/Untitled.webp" class="" title="image"><p>CPU 通过总线从主存取指令和数据，完成计算之后再将结果写回内存。这个模型的瓶颈在于 CPU 的超级快的运算速度和主存相对慢的多的运算速度无法匹配，导致大量的时间都浪费在内存上。既然内存比较慢那么就尽量减少 CPU 对内存的访问，于是在 CPU 和 主存之间增加一层 Cache，如下图所示。</p><img src="/2017/10/01/operating-system-storage/Untitled1.webp" class="" title="image"><p>在计算机中，Cache 就是访问速度快的计算机内存被用来保存频繁访问或者最近访问的指令和内存。通常 Cache 的造价比较高，所以相对 Memory 来说，容量比较小,保存的数据也有限。总而言之，由于 CPU 和内存之间的指令和数据访问存在瓶颈，所以增加了一层 Cache，用来尽力消除 CPU 和内存之间的瓶颈。这个模型如下图所示。</p><img src="/2017/10/01/operating-system-storage/Untitled2.webp" class="" title="image"><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>你可能会问为什么在CPU 和内存之间增加一层 Cache，就可以尽力消除 CPU 和内存之间的瓶颈呢？</p><img src="/2017/10/01/operating-system-storage/Untitled3.webp" class="" title="image"><p>如上图所示，是局部性原理（principle of locality）让 Cache 更好的工作。一个编写良好的计算机程序通常都具有良好的局部性（locality）,程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性被称作局部性原理。局部性通常有 2 种不同的形式：时间局部性（temporal locality）和空间局部性 (spatial locality)。在一个具有良好时间局部性的程序中，被引用过一次的内存地址很可能在不远的将来会再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来会引用附近的一个内存位置。</p><p>程序是如何利用这个局部性原理呢？</p><img src="/2017/10/01/operating-system-storage/Untitled4.webp" class="" title="image"><p>从数据方面来说，</p><ol><li>sum 变量在每次循环迭代的时候都会被访问，符合时间局部性。</li><li>采用步长为 1 的方式访问数组 a ，符合空间局部性。</li></ol><p>从指令方面来说，</p><ol><li>循环迭代，符合时间局部性</li><li>线性执行指令，符合空间局部性</li></ol><p>对于程序员来说，编写具有良好的局部性的程序是让程序运行更快的方法之一。</p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><img src="/2017/10/01/operating-system-storage/Untitled5.webp" class="" title="image"><p>上图展示了一个典型的存储器层次结构。一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高层是少量快速的<br> CPU 寄存器，CPU 可以再一个时钟周期内访问它们。接下来是一个或者多个小型到中型的基于 SRAM 的高速缓存存储器，可以再几个 CPU 时钟周期内访问它们。然后是一个大的基于 DRAM 的主存，可以在几十或者几百个时钟周期内访问它们。接下来是慢速但是容量很大的本地磁盘。最后有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们，例如网络文件系统（Network File System,NFS）这样的分布式文件系统，允许程序访问存储在远程的网络服务器上的文件。</p><p>存储器层次结构的核心是，对于每个 k , 位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。也就是说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出文件的缓存，以此类推知道 CPU 寄存器。</p><img src="/2017/10/01/operating-system-storage/Untitled6.webp" class="" title="image"><p>上图展示了存储器层次结构中缓存的一般性概念。第 k+1 层的存储器被划分成连续的数据对象组块（chunk）,称为块（block）。每个块都有一个唯一的名字或者地址以区别其他的块。例如第 k+1 层存储器被划分成 16 个大小固定的块，编号为 0 ~ 15。第 k 层的存储器被划分成较少的块的集合，每个块的大小与 k+1 层的块的大小一样。在任何时刻，第 k 层的缓存包含了第 k+1 层块的一个子集的副本。例如，第 k 层的缓存有 4 个块的控件，当前包含了 8，9，14，3 的副本。</p><p>数据总是以块大小为传输单元在第 k 层 和 第 k+1 层之间来回复制的，虽然在层次结构总任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。例如 L1 和 L2 之间的传送通常使用的是几十个个字大小的块，而 L5 和 L4 之间的传送用的是大小为几百或者几千字节的块。一般而言，层次结构中较低层（离 CPU 较远）的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。</p><img src="/2017/10/01/operating-system-storage/Untitled7.webp" class="" title="image"><p>当程序需要第 k+1 层的某个数据对象 d 时，它首先会在当前存储在第 k 层的一个块中查找 d。如果 d 刚好缓存在第 k 层，那么就是缓存命中。该程序直接从第 k 层读取 d，根据存储器层次结构的性质，从 k 层读取数据显然比从 k+1 层读取数据更快。如上图所示，一个具有良好时间局部性的程序可以从块 14 中读出一个数据对象，得到一个对 k 层的缓存命中 。</p><img src="/2017/10/01/operating-system-storage/Untitled8.webp" class="" title="image"><p>如果第 k 层中没有缓存数据对象 d，那么就是我们所说的缓存不命中 （cache miss）。当发生缓存不命中时，第 k 层的缓存从第 k+1 层缓存中取出包含 d 的那个块，如果第 k 层的缓存已经满了，那么可能会覆盖现存的一个块。覆盖一个现存的一个块的过程称为替换或者驱逐。被替换的块有时也称作牺牲块。决定替换哪个块是由缓存的替换策略来控制的，替换策略有随机替换和最近最少被使用（LRU）替换策略。</p><h3 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h3><p>早期的计算机系统的存储器结构只有三层： CPU 寄存器， DRAM 主存，磁盘。由于 CPU 和主存之间逐渐增大的速度差距，系统设计者在 CPU 和 主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存。随着 CPU 和主存之间逐渐增大的速度差距，系统设计者在 L1 和 主存之间插入了一个更大的 SRAM 高速缓存存储器，称为 L2 高速缓存。</p><img src="/2017/10/01/operating-system-storage/Untitled9.webp" class="" title="image"><p>假设一个计算机系统，其中每个存储器地址 m 位，形成 M &#x3D; 2^m 个不同的地址。如下图所示。一个机器的高速缓存被组织成一个有 S &#x3D; 2^s 个高速缓存组（cache set）的数组。每个组包含 E 个高速缓存行（cache line）,每个行由一个 B &#x3D; 2^b 字节的数据块组成，一个有效位（valid bit）指明这个行是否有效，t &#x3D; m -（s+b）个标记位（tab bit），他们唯一地标识存储在这个高速缓存行中的块。</p><img src="/2017/10/01/operating-system-storage/Untitled10.webp" class="" title="image"><p>根据每个组的高速缓存行数 E，高速缓存可以被分为不同的类，每个组只有一行（E &#x3D; 1）的高速缓存成为直接映射高速缓存。下面我们以直接映射高速缓存来讲解。</p><img src="/2017/10/01/operating-system-storage/Untitled11.webp" class="" title="image"><p>假设有这么一个系统，它有一个 CPU，一个寄存器文件，一个 L1 高速缓存和一个主存。当 CPU 执行一条读内存字 w 的指令，它向 L1 请求这个字，如果 L1 有 w 的副本，那么 L1 高速缓存命中，高速缓存取出 w，返回给 CPU。若是不命中，当 L1 向主存请求包含 w 的块的副本时，CPU 必须等待。当被请求的块从内存到达 L1 时，L1 将这个块存放在它的一个高速缓存行里面，然后取出 w,返回给 CPU 。高速缓存上面的工作过程分为 3 个步骤：</p><ol><li>组选择</li><li>行匹配</li><li>字抽取</li></ol><p>第一步，直接映射高速缓存的组选择。高速缓存从 w 中取出 s 个组索引位。例子中的组索引位 00001 定位到组 1。</p><img src="/2017/10/01/operating-system-storage/Untitled12.webp" class="" title="image"><p>第二步，直接映射高速缓存的行匹配。由于只有一个高速缓存行，而且有效位也设置了，所以这个行是有用的，从 w 中取出标记位 t ，与高速缓存行中的标记位相匹配，所以缓存命中。</p><img src="/2017/10/01/operating-system-storage/Untitled13.webp" class="" title="image"><p>第三步，直接映射高速缓存的字选择。一旦缓存命中，那么我们就知道 w 就在这个块中的某个位置。我们把块看成一个字节的数组，而字节偏移是到这个数组的索引。所以最后一步是确定所需要的字在块中的偏移位置。例子中的块偏移是 100，它说明了 w 的副本是从块中的字节 4 开始的（假设字长为 4 字节）。</p><p>第四步，直接映射高速缓存不命中的行替换。如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在一个高速缓存行中。对于直接映射高速缓存来说，每个组只要一个行，替换策略就是用新取出的行替换当前的行。</p><h3 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h3><p>确保代码高速缓存友好的基本方法有 2 种，</p><ol><li>让最常见的情况运行的快。</li><li>尽量减少每个循环内部的缓存不命中数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sumvec</span><span class="hljs-params">(<span class="hljs-type">int</span> v[n])</span><br>&#123;<br>  <span class="hljs-type">int</span> i, sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>  &#123;<br>      sum += v[i];<br>  &#125; <br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先对于局部变量 i 和 sum，循环体有良好的时间局部性。对数组 v 的步长为 1 的引用，对 v[0] 的引用会不命中，而对应的 v[0] ~ v[3] 的块会被从内存加载到高速缓存中，因此接下来的三个引用都会命中，以此类推，四个引用中，三个会命中，这个是我们能做到的最好的情况了，具有良好的空间局部性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作为一个程序员需要理解存储器的结构层次，因为它对应用程序的性能有巨大的影响。如果你的程序需要的数据是存储在 CPU 寄存器中的，那么在指令的执行期间，在 0 个周期内就可以访问到它们，如果在高速缓存中，需要 4 ~ 75 个周期。如果存储在主存中，需要上百个周期，如果存储在磁盘上，大约需要几千万个周期。如果理解了系统是如何将数据再存储器层次结构中上上下下移动的，那么就可以在编写自己的应用程序的时候使得他们的数据项存储在结构层次中较高的地方，以便 CPU 可以更快的访问到它们。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://courses.cs.washington.edu/courses/cse351/17wi/videos.html">The Hardware &#x2F; Software Interface</a> 课程笔记</li><li><a href="https://book.douban.com/subject/26912767/">https://book.douban.com/subject/26912767/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 网络监控框架 - Reachability 源码解读</title>
    <link href="/2017/09/23/reading-source-code-of-Reachability/"/>
    <url>/2017/09/23/reading-source-code-of-Reachability/</url>
    
    <content type="html"><![CDATA[<h1 id="Reachability-解读"><a href="#Reachability-解读" class="headerlink" title="Reachability 解读"></a>Reachability 解读</h1><p>Reachability 项目是 Apple 提供的一个官方 Demo， 用于演示如何使用 System Configuration framework 来监控 iOS 设备的网络状态。值得注意的是 Reachability 仅仅能检测到数据包是否可以离开本设备，而不能检测到数据包是否能达到目的地。也就是说不能把它当成 Ping 来使用。Reachability 使用起来也特别的简单，接下来我们来看看如何使用 Reachability。</p><h3 id="Reachability-使用"><a href="#Reachability-使用" class="headerlink" title="Reachability 使用"></a>Reachability 使用</h3><p>设置欲检测的域名，启动网络状态监控，Reachability 会在设备的网络状态发生变化的时候会发出一个名为 kReachabilityChangedNotification 的通知，我们可以通过接收这个通知，然后根据设备的网络状态做业务应对处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 接收 kReachabilityChangedNotification 通知</span><br>[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(reachabilityChanged:) name:kReachabilityChangedNotification object:<span class="hljs-literal">nil</span>];<br><br><span class="hljs-comment">// 检测某个域名是否可达</span><br><span class="hljs-keyword">self</span>.hostReachability = [Reachability reachabilityWithHostName:remoteHostName];<br><br><span class="hljs-comment">// 开始监控</span><br>[<span class="hljs-keyword">self</span>.hostReachability startNotifier];<br><br><span class="hljs-comment">// 收到 kReachabilityChangedNotification 通知</span><br>- (<span class="hljs-type">void</span>) reachabilityChanged:(<span class="hljs-built_in">NSNotification</span> *)note<br>&#123;<br>Reachability* curReach = [note object];<br><span class="hljs-built_in">NSParameterAssert</span>([curReach isKindOfClass:[Reachability <span class="hljs-keyword">class</span>]]);<br>      <span class="hljs-comment">// 做业务应对处理 </span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="Reachability-的组成"><a href="#Reachability-的组成" class="headerlink" title="Reachability 的组成"></a>Reachability 的组成</h3><p>Reachability 项目仅仅由一个 Reachability.h 和 Reachability.m 文件组成。麻雀虽小，五脏俱全。Reachability 也是这样的。Reachability 的接口提供了以下的能力：</p><ol><li>检测一个域名是否可达，使用  reachabilityWithHostName:  方法。</li><li>检测一个 IP 是否可达，使用 reachabilityWithAddress: 方法。</li><li>检测设备网络的可到达性，使用 reachabilityForInternetConnection 方法。</li><li>开始监控网络状况，使用 startNotifier 方法。</li><li>停止监控网络状况，使用 stopNotifier 方法。与 startNotifier 方法配合使用。</li><li>获取当前的网络连接方式，使用 currentReachabilityStatus 方法。</li><li>判断设备的网络是否是按需连接方式，使用 connectionRequired 方法。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Reachability</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Use to check the reachability of a given host name.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithHostName:(<span class="hljs-built_in">NSString</span> *)hostName;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Use to check the reachability of a given IP address.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithAddress:(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *)hostAddress;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Checks whether the default route is available. Should be used by applications that do not connect to a particular host.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityForInternetConnection;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * Start listening for reachability notifications on the current run loop.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">BOOL</span>)startNotifier;<br>- (<span class="hljs-type">void</span>)stopNotifier;<br><br>- (NetworkStatus)currentReachabilityStatus;<br><br><span class="hljs-comment">/*!</span><br><span class="hljs-comment"> * WWAN may be available, but not active until a connection has been established. WiFi may require a connection for VPN on Demand.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">BOOL</span>)connectionRequired;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="Reachability-的实现"><a href="#Reachability-的实现" class="headerlink" title="Reachability 的实现"></a>Reachability 的实现</h3><p>Reachability 的实现依赖于系统的 SCNetworkReachability 类，SCNetworkReachability 允许应用程序获取当前系统的网络配置情况，也可以用来判断一个 target host 的可达性。值得注意的是，当应用程序可以将一个 data packet 发送到 network stack,并且该 data packet 可以离开本地设备，这个时候 SCNetworkReachability 就会判断网络是可达的。正是由于这个原因，Reachability 不能保证 data packet 会被送到 target host 。SCNetworkReachability 的使用分为<strong>同步模式和异步模式</strong>。</p><h4 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h4><p>我们先从异步模式开始解读，这毕竟是比较常用的模式！</p><p>第一步<br>我们从  startNotifier 方法开始。把 SCNetworkReachabilityRef 放到当前 runloop 的 kCFRunLoopDefaultMode 模式，当网络连接状态发生变化，SCNetworkReachabilityRef 会执行通过 SCNetworkReachabilitySetCallback 方法设定好的 ReachabilityCallback 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)startNotifier<br>&#123;<br><span class="hljs-type">BOOL</span> returnValue = <span class="hljs-literal">NO</span>;<br><span class="hljs-built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilitySetCallback</span>(_reachabilityRef, ReachabilityCallback, &amp;context))<br>&#123;<br>        <span class="hljs-comment">//把 SCNetworkReachabilityRef 放到当前 runloop 的 kCFRunLoopDefaultMode 模式</span><br>        <span class="hljs-comment">//当 SCNetworkReachabilityRef 判断到网络状态发生变化，会执行 ReachabilityCallback 回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(_reachabilityRef, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode))<br>&#123;<br>returnValue = <span class="hljs-literal">YES</span>;<br>&#125;<br>&#125;<br>    <br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步<br>接下来看 ReachabilityCallback 回调方法，在这里主要是发送一个  名为 kReachabilityChangedNotification 通知，并将 Reachability 对象作为参数，将网络连接状态通知应用程序。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> ReachabilityCallback(<span class="hljs-built_in">SCNetworkReachabilityRef</span> target, <span class="hljs-built_in">SCNetworkReachabilityFlags</span> flags, <span class="hljs-type">void</span>* info)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> unused (target, flags)</span><br><span class="hljs-built_in">NSCAssert</span>(info != <span class="hljs-literal">NULL</span>, <span class="hljs-string">@&quot;info was NULL in ReachabilityCallback&quot;</span>);<br><span class="hljs-built_in">NSCAssert</span>([(__bridge <span class="hljs-built_in">NSObject</span>*) info isKindOfClass: [Reachability <span class="hljs-keyword">class</span>]], <span class="hljs-string">@&quot;info was wrong class in ReachabilityCallback&quot;</span>);<br>    <span class="hljs-comment">// 发送 kReachabilityChangedNotification 通知，并将 Reachability 作为参数</span><br>    Reachability* noteObject = (__bridge Reachability *)info;<br>    <span class="hljs-comment">// Post a notification to notify the client that the network reachability changed.</span><br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName: kReachabilityChangedNotification object: noteObject];<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步<br>startNotifier 和 stopNotifier 方法是配合使用的。stopNotifier 的主要任务是对 startNotifier 做的操作进行逆向处理。把 SCNetworkReachabilityRef 从当前 runloop 的 kCFRunLoopDefaultMode 模式移除。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)stopNotifier<br>&#123;<br><span class="hljs-keyword">if</span> (_reachabilityRef != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(_reachabilityRef, <span class="hljs-built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步<br>上面主要是主流程解读，解读 Reachability 开始网络监控，网络状态发生变化处理，到停止网络监控的流程。这过程 Reachability 都<br> 依赖于 SCNetworkReachabilityRef 的对象，接下来我们来说说 Reachability 怎么创建  SCNetworkReachabilityRef 对象。SCNetworkReachabilityRef 对象的创建依赖于 IP 或者域名。依赖于域名使用 SCNetworkReachabilityCreateWithName 方法，依赖于 IP 使用 SCNetworkReachabilityCreateWithAddress 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 通过域名创建 SCNetworkReachabilityRef 对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithHostName:(<span class="hljs-built_in">NSString</span> *)hostName<br>&#123;<br>Reachability* returnValue = <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">SCNetworkReachabilityRef</span> reachability = <span class="hljs-built_in">SCNetworkReachabilityCreateWithName</span>(<span class="hljs-literal">NULL</span>, [hostName UTF8String]);<br><span class="hljs-keyword">if</span> (reachability != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue= [[<span class="hljs-keyword">self</span> alloc] init];<br><span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue-&gt;_reachabilityRef = reachability;<br>&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">CFRelease</span>(reachability);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br><br><span class="hljs-comment">// 通过 IP 创建 SCNetworkReachabilityRef 对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)reachabilityWithAddress:(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> sockaddr *)hostAddress<br>&#123;<br><span class="hljs-built_in">SCNetworkReachabilityRef</span> reachability = <span class="hljs-built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, hostAddress);<br><br>Reachability* returnValue = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (reachability != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue = [[<span class="hljs-keyword">self</span> alloc] init];<br><span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">NULL</span>)<br>&#123;<br>returnValue-&gt;_reachabilityRef = reachability;<br>&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">CFRelease</span>(reachability);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是异步模式的解读，Reachability 的异步模式顾名思义就是网络连接发生了变化，Reachability 发通知告知应用程序。而同步模式呢？ 那就是应用程序主动找 Reachability 获取当前的网络连接状态。</p><h4 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h4><p>应用程序主动找 Reachability 获取当前的网络连接状态，使用 currentReachabilityStatus 方法。Reachability 能够实现同步模式依赖于 SCNetworkReachabilityRef 的 SCNetworkReachabilityGetFlags 方法。SCNetworkReachabilityGetFlags 方法使用同步模式获取设备的网络连接状态。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (NetworkStatus)currentReachabilityStatus<br>&#123;<br><span class="hljs-built_in">NSAssert</span>(_reachabilityRef != <span class="hljs-literal">NULL</span>, <span class="hljs-string">@&quot;currentNetworkStatus called with NULL SCNetworkReachabilityRef&quot;</span>);<br>NetworkStatus returnValue = NotReachable;<br><span class="hljs-built_in">SCNetworkReachabilityFlags</span> flags;<br>        <span class="hljs-comment">// 同步模式获取网络连接状态</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SCNetworkReachabilityGetFlags</span>(_reachabilityRef, &amp;flags))<br>&#123;<br>        returnValue = [<span class="hljs-keyword">self</span> networkStatusForFlags:flags];<br>&#125;<br>    <br><span class="hljs-keyword">return</span> returnValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Reachability 可以用来检测网络状态变化和网络的可达性的一个框架。但是 Reachability 仅仅能检测到数据包是否可以离开本设备，而不能检测到数据包是否能达到目的地，也就是说不能把它当成 Ping 来使用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>Reachability 的代码和 Demo<br> <a href="https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html">https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html</a></li><li>SCNetworkReachability 参考<br><a href="https://developer.apple.com/documentation/systemconfiguration/scnetworkreachability-g7d">https://developer.apple.com/documentation/systemconfiguration/scnetworkreachability-g7d</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出虚拟内存机制</title>
    <link href="/2017/09/23/operating-system-memory/"/>
    <url>/2017/09/23/operating-system-memory/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>现代操作系统了提供了一种对主存的抽象概念，叫做虚拟内存。它为每个进程提供了一个非常大的，一致的和私有的地址空间。虚拟内存提供了以下的三个关键能力：</p><ol><li>它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</li><li>它为内阁进程提供了一致的地址空间,简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ol><span id="more"></span><h3 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h3><p>计算机的主存可以看做是一个由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址（Physical Address,PA）。第一个字节的地址为 0，接下来的地址为 1，以此类推。CPU 访问内存的最简单的方式是使用物理寻址（physical addressing）。</p><img src="/2017/09/23/operating-system-memory/Untitled.webp" class="" title="image"><p>该图例的上下文是一条加载指令，塔读取从物理地址 4 处开始的 4 字节字。CPU 在执行这条指令的时候，生成一个有效物理地址，通过内存总线，把这个物理地址传递给主存，主存取出从物理地址4处开始的 4 个字节字，然后将它返回给 CPU，CPU 将它存放在一个寄存器里。早期使用物理寻址的系统通常都比较简单，比如数字信号处理器，计算器等嵌入式设备。</p><img src="/2017/09/23/operating-system-memory/Untitled1.webp" class="" title="image"><p>现在处理器采用的是一个程序虚拟寻址（virtual addressing）的寻址方式，如上图所示。CPU 通过生成一个虚拟地址（virtual address,VA）来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做地址翻译（address translation），地址翻译需要 CPU 硬件和操作系统之间的配合。 CPU 芯片上叫做内存管理单元（Menory Management Unit, MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间（address space）是一个非负整数 <strong>地址</strong> 的有序合集：{0，1，2，… }</p><img src="/2017/09/23/operating-system-memory/Untitled2.webp" class="" title="image"><p>在一个带虚拟内存的系统中，CPU 从一个有 N&#x3D; 2 的 n 次方 个地址的地址空间中生成虚拟地址，这个地址空间就称为虚拟地址空间：<br>{0，1，2，3，…., N-1}。<br>一个系统还有一个地理地址空间，对应于系统中物理内存的 M 个字节： {0，1，2，3，…, M-1}。<br>一个地址空间的大小通常是由表示最大地址所需要的位数来描述的，比如，一个包含 N &#x3D; 2 的 n 次方 个地址的虚拟地址空间就叫做一个 n 位地址空间，现代操作系统通常支持 32 位或者 64 位虚拟地址空间。</p><h3 id="虚拟内存做为缓存的工具"><a href="#虚拟内存做为缓存的工具" class="headerlink" title="虚拟内存做为缓存的工具"></a>虚拟内存做为缓存的工具</h3><p>从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中。在存储器结构中，较低层次上的磁盘的数据被分割成块，这些块作为和较高层次的主存之间的传输单元。主存作为虚拟内存的缓存。</p><p>虚拟内存（VM）系统将虚拟内存分割成称为虚拟页（Virtual Page,VP）的大小固定的块，每个虚拟页的大小为 P &#x3D; 2 的 p 次方 字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为 P 字节（物理页也称作页帧（page frame））。</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ol><li>未分配的，VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存空间。</li><li>缓存的，当前已缓存在物理内存中的已分配页。</li><li>未缓存的，未缓存在物理内存中的已分配页。</li></ol><img src="/2017/09/23/operating-system-memory/Untitled3.webp" class="" title="image"><p>上图展示了在一个有 8 个虚拟内存的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被分配了，但是当前并没有缓存在主存中。</p><h4 id="DRAM-缓存的组织结构"><a href="#DRAM-缓存的组织结构" class="headerlink" title="DRAM 缓存的组织结构"></a>DRAM 缓存的组织结构</h4><img src="/2017/09/23/operating-system-memory/Untitled4.webp" class="" title="image"><p>我们使用 SRAM 缓存来表示位于 CPU 和 主存之间的  L1, L2 和 L3 高速缓存，使用 DRAM 缓存来表示虚拟内存系统中的缓存，也就是主存。</p><p>在存储器层次结构中， DRAM 比 SRAM 慢个大约 10x 倍，磁盘比 DRAM 慢大约 10, 000x 倍。因此 DRAM 缓存的不命中比 SRAM 缓存中的不命中要昂贵的多，因为 DRAM 缓存不命中需要和磁盘传送数据，而 SRAM 缓存不命中是和 DRAM 传送数据。</p><p>归根到底， DRAM 缓存的组织结构是由巨大的不命中开销驱动的。</p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><img src="/2017/09/23/operating-system-memory/Untitled5.webp" class="" title="image"><p>VA 是通过什么方式转成 PA 呢 ？<br>同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟也是否缓存在 DRAM 的某个地方。如果命中缓存，那么虚拟内存系统还必须确认这个虚拟页存在哪个物理页中。如果没有命中缓存，那么虚拟内存系统必须判断虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM，替换这个牺牲页。</p><p>这些功能由软硬件联合提供，包括操作系统软件，MMU 中的地址翻译硬件和一个存放在物理内存中叫页表（page table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。</p><img src="/2017/09/23/operating-system-memory/Untitled6.webp" class="" title="image"><p>上图展示了一个页表的基本结构，页表就是一个页表条目（Page Table Entry,PTE）的数组。虚拟地址空间中的每个页在页表中都有一个 PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 DRAM 中。如果有效位为 1，那么地址字段就表示 DRAM 中相应的物理页的起始位置，这个物理页缓存了该虚拟页。如果有效位为 0，那么一个 null 地址表示这个虚拟页还未被分配，否则对应的这个地址就指向该虚拟页在磁盘上的起始位置。</p><p>上图所示中一共有 8 个虚拟页和 4 个物理页的页表，4 个虚拟页 VP1, VP2, VP4, VP7 当前被缓存在 DRAM 中，VP0 和 VP5 还未被分配，而剩下的 VP3 和 VP6 已经被分配了，但是当前未被缓存。</p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><img src="/2017/09/23/operating-system-memory/Untitled7.webp" class="" title="image"><p>当 CPU 想要读取 VP2 中的虚拟内存中的一个字时，地址翻译硬件将虚拟地址作为一个索引来定位到 PTE2, 并从主存中读取它。因为 PTE2 设置了有效位，所以 VP2 是缓存在主存中的，所以地址翻译硬件使用 PTE 中的物理内存地址构造出这个字的物理地址。</p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><img src="/2017/09/23/operating-system-memory/Untitled8.webp" class="" title="image"><p>在虚拟内存中，DRAM 缓存不命中称为缺页（page fault）。如上图所示，CPU 引用了 VP3 中的一个字， VP3 并未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE3, 从有效位判断出 VP3 未被缓存，并且触发了一个缺页异常。缺页异常会调用内核的缺页异常处理程序，该程序会选择一个牺牲页。如下图所示，在这个案例中就是存放在 PP3 中的 VP4。</p><img src="/2017/09/23/operating-system-memory/Untitled9.webp" class="" title="image"><p>此时如果 VP4 已经被修改了，那么内核程序会将它复制回磁盘。接下来，内核程序从磁盘赋值 VP3 到内存中的 PP3并更新 PTE3。随后返回用户进程。当异常处理程序返回时，它会重启执行导致缺页的指令，该指令会将导致缺页的虚拟地址重新发送到地址翻译硬件。如下图所示，现在 VP3 已经在主存中了，那么就是页命中了。</p><img src="/2017/09/23/operating-system-memory/Untitled10.webp" class="" title="image"><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>当我们了解了虚拟内存的运作机制之后，是不是觉得虚拟内存的效率会很低呢？因为页面没有命中的代价非常大。是不是担心虚拟内存会影响程序的性能呢？其实虚拟内存运作的非常好。它充分利用了局部性（ locality ）的原理。</p><img src="/2017/09/23/operating-system-memory/Untitled11.webp" class="" title="image"><p>在程序整个运作过程中，程序引用的不同页面的总数可能超出了物理内存的总大小，但是局部性原则可以保证在任意时刻，程序将趋向于在一个较小的活动页面（active page）集合上工作，这个集合被称作工作集（working set）或者常驻集合（resident set）。在程序初始开销之后也就是将工作集页面调入主存，接下来对这个工作集的访问会产生命中，这样就不会产生额外的磁盘消耗。<br>如果程序有良好的时间局部性，那么虚拟内存将工作的非常好。如果程序没有良好的时间局部性也就是工作集的大小超出了主存的大小，那么程序将会进入一个称作 抖动（thrashing）的状态，这个时候页面将不断地换进换出，程序会出现性能问题。</p><h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><p>虚拟内存大大简化了内存管理，操作系统为每个进程提供了一个独立的虚拟地址空间。</p><img src="/2017/09/23/operating-system-memory/Untitled12.webp" class="" title="image"><p>在上图中，进程 1 的页表将 VP1 映射到 PP2, VP2 映射到 PP6。进程 2 的页表将 VP1 映射到 PP8, VP2 映射到 PP6。在这里可以看到多个虚拟页面可以映射到同一个共享的物理页面上。</p><p>按需页面调度和独立的虚拟地址空间的结合，让 虚拟内存简化了链接和加载，代码和数据共享，以及应用程序的内存分配。</p><ul><li>简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</li><li>简化加载。虚拟内存使得容易向内存中加载可执行文件和共享对象文件。将一组连续的虚拟页面映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供了一个 nmap 的系统调用，允许应用程序自己做内存映射。</li><li>简化共享。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般情况下，每个进程都有自己私有的代码、数据、堆栈。这些内容不与其他进程共享。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</li><li>简化内存分配。虚拟内存向用户进程提供一个简单的分配额外内存的机制。当一个用户程序要求额外的堆空间时候，操作系统分配 k 个适当的连续的虚拟内存页面，并且将他们映射到物理内存的中的 k 个任意页面，操作系统没有必要分配 k 个连续的物理内存页面。</li></ul><h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><p>虚拟内存大大简化了内存管理，操作系统提供独立的地址空间使得区分不同进程的私有内存变得容易，但是地址翻译机制可以使用一种自然的方式拓展到提供更好的访问控制。每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE ，通过在 PTE 上添加一些额外的控制位来控制对一个虚拟页面内容的访问。</p><img src="/2017/09/23/operating-system-memory/Untitled13.webp" class="" title="image"><p>在上图中，每个 PTE 添加了三个控制位， SUP 位表示进程是否必须运行在超级用也就是内核模式下才能访问该页，WRITE 位控制页面的写访问， EXRC 位控制页面的执行。如果有指令违反了这些控制条件，那么 CPU 会触发一个一般保护故障，将控制传递给内核中的异常处理程序。</p><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><img src="/2017/09/23/operating-system-memory/Untitled14.webp" class="" title="image"><p>上图中展示了页面命中的场景，CPU 硬件的执行步骤：</p><ol><li>处理器 生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存&#x2F;主存中请求这个 PTE 。</li><li>高速缓存&#x2F;主存向 MMU 返回 PTE。</li><li>MMU 构造物理地址，并把它传送给高速缓存&#x2F;主存。</li><li>高速缓存&#x2F;主存返回所请求的数据字给处理器。</li></ol><p>页面命中是全部由硬件来处理的，既然有页面命中，那么就有页面不命中的场景。</p><img src="/2017/09/23/operating-system-memory/Untitled15.webp" class="" title="image"><p>上图展示了页面不命中的场景， CPU 硬件的执行步骤：</p><ol><li>处理器 生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存&#x2F;主存中请求这个 PTE 。</li><li>高速缓存&#x2F;主存向 MMU 返回 PTE。</li><li>PTE 中的有效控制位为 0 ，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>缺页处理程序调入新的页面，并更新内存中的 PTE。</li><li>缺页处理程序返回原来的进程，再次执行导致缺页的指令， CPU 将引起缺页的虚拟地址重新发送给 MMU ，因为虚拟页面现在存在主存中，所以会命中，主存将请求字返回给处理器。</li></ol><p>地址翻译的过程执行起来太慢了？怎么解决呢？答案你应该也猜到了，就是添加缓存。在 MMU 中包含了一个 TLB （Translation Lookaside Buffer）缓存。</p><img src="/2017/09/23/operating-system-memory/Untitled16.webp" class="" title="image"><p>我们来看看 TLB 命中的场景，</p><ul><li>第 1 步 CPU 产生一个虚拟地址</li><li>第 2 和 3 步 MMU 从 TLB 中取出对应的 PTE 。</li><li>第 4 步 MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。</li><li>第 5 步 高速缓存&#x2F;主存将所请求的数据字返回 CPU。</li></ul><p>如下图所示，当 TLB 不命中的时候， 多了步骤 3 和 4 ，MMU 必须从 L1 缓存中取出对应的 PTE , 新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的 PTE 。</p><img src="/2017/09/23/operating-system-memory/Untitled17.webp" class="" title="image"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虚拟内存对于计算机系统来说是核心的，虚拟内存也是强大的，同时虚拟内存也是危险的。虚拟内存还包括多级页表，内存映射，动态内存分配，垃圾收集等等内容。限于篇幅，这里只是叙述了一些基本的概念，帮助程序员理解 虚拟内存 这个概念，对具体细节不做深究。若是有兴趣的话，可以参考 《深入理解计算机系统》书籍，了解更多关于计算机虚拟内存要点。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://courses.cs.washington.edu/courses/cse351/17wi/videos.html">The Hardware &#x2F; Software Interface</a> 课程笔记</li><li><a href="https://book.douban.com/subject/26912767/">https://book.douban.com/subject/26912767/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS AOP 框架 - Aspects 源码解读</title>
    <link href="/2017/05/07/reading-source-code-of-Aspects/"/>
    <url>/2017/05/07/reading-source-code-of-Aspects/</url>
    
    <content type="html"><![CDATA[<h1 id="Aspects-解读"><a href="#Aspects-解读" class="headerlink" title="Aspects 解读"></a>Aspects 解读</h1><p><a href="https://github.com/steipete/Aspects">Aspects</a> 是 iOS 上的一个轻量级 AOP 库。它利用 method swizzling 技术为已有的类或者实例方法添加额外的代码，它是著名框架 PSPDFKit （an iOS PDF framework that ships with apps like Dropbox or Evernote）的一部分。</p><h3 id="怎么使用-Aspects"><a href="#怎么使用-Aspects" class="headerlink" title="怎么使用 Aspects"></a>怎么使用 Aspects</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific class.</span><br>+ (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br><br><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br><br></code></pre></td></tr></table></figure><p>Aspects 提供了2个 AOP 方法，一个用于类，一个用于实例。在确定 hook 的 方法之后， Aspects 允许我们选择 hook 的时机是在方法执行之前，还是方法执行之后，甚至可以直接替换掉方法的实现。Aspects 的常见使用情景是 log 和 打点统计 等和业务无关的操作。比如 hook ViewController 的 viewWillLayoutSubviews 方法。</p><span id="more"></span><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[aspectsController aspect_hookSelector:<span class="hljs-keyword">@selector</span>(viewWillLayoutSubviews) withOptions:<span class="hljs-number">0</span> usingBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Controller is layouting!&quot;</span>);<br>        &#125; error:<span class="hljs-literal">NULL</span>];<br></code></pre></td></tr></table></figure><h3 id="Aspects-使用的技术"><a href="#Aspects-使用的技术" class="headerlink" title="Aspects 使用的技术"></a>Aspects 使用的技术</h3><p>在阅读 Aspects 源码之前需要一些 Runtime 的相应知识，可以参考我自己的一些博客。</p><ol><li><a href="http://www.jianshu.com/p/8295f2503594">Objective-C 之 objc_msgSend 简单实现</a></li><li><a href="http://www.jianshu.com/p/e0682171f0a2">Objective-C 方法签名和调用</a></li><li><a href="http://www.jianshu.com/p/6186320a79db">Objective-C 动态实现</a></li><li><a href="http://www.jianshu.com/p/bdf84c417e4f">Objective-C 消息转发</a></li><li><a href="http://www.jianshu.com/p/1d59d266b8be">Objective-C 方法混写</a></li></ol><h3 id="Aspects-的代码"><a href="#Aspects-的代码" class="headerlink" title="Aspects 的代码"></a>Aspects 的代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Adds a block of code before/instead/after the current `selector` for a specific instance.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                      withOptions:(AspectOptions)options<br>                       usingBlock:(<span class="hljs-type">id</span>)block<br>                            error:(<span class="hljs-built_in">NSError</span> **)error;<br></code></pre></td></tr></table></figure><p>接下来的源码解读，主要是分析 Aspects 的 实例方法的执行流程，以及 Aspects 的设计思路。至于 Aspects 的类方法的执行流程和思路也是大同小异，这里就不再累赘了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// @return A token which allows to later deregister the aspect.</span><br>- (<span class="hljs-type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector<br>                           withOptions:(AspectOptions)options<br>                            usingBlock:(<span class="hljs-type">id</span>)block<br>                                 error:(<span class="hljs-built_in">NSError</span> **)error &#123;<br>    <span class="hljs-keyword">return</span> aspect_add(<span class="hljs-keyword">self</span>, selector, options, block, error);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法返回一个 AspectToken 对象，这个对象主要是 aspect 的唯一标识符。 该方法调用了 static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) 方法，这个方法用于给一个实例添加 aspect 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">id</span> aspect_add(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL selector, AspectOptions options, <span class="hljs-type">id</span> block, <span class="hljs-built_in">NSError</span> **error) &#123;<br><br>   <span class="hljs-comment">// ...... 省略代码    </span><br>    __block AspectIdentifier *identifier = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 给 block 加锁</span><br>    aspect_performLocked(^&#123;<br>        <span class="hljs-comment">// 判断 selector 是否可以被 hook</span><br>        <span class="hljs-keyword">if</span> (aspect_isSelectorAllowedAndTrack(<span class="hljs-keyword">self</span>, selector, options, error)) &#123;<br>            <span class="hljs-comment">// 创建一个 AspectsContainer 对象,用 selector 关联到实例对象</span><br>            AspectsContainer *aspectContainer = aspect_getContainerForObject(<span class="hljs-keyword">self</span>, selector);<br>            <span class="hljs-comment">// 创建一个 AspectIdentifier 对象，</span><br>            identifier = [AspectIdentifier identifierWithSelector:selector object:<span class="hljs-keyword">self</span> options:options block:block error:error];<br>            <span class="hljs-keyword">if</span> (identifier) &#123;<br>                <span class="hljs-comment">// 把 AspectIdentifier 对象加入 AspectsContainer 对象中</span><br>                [aspectContainer addAspect:identifier withOptions:options];<br>                <br>                <span class="hljs-comment">// Modify the class to allow message interception.</span><br>                aspect_prepareClassAndHookSelector(<span class="hljs-keyword">self</span>, selector, error);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> identifier;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>给 block 加锁 </li><li>判断 selector 是否符合 hook 的规则</li><li>创建一个 AspectsContainer 对象,用 selector 关联到实例对象。用于管理一个对象或者类的一个方法的所有 aspects </li><li>创建一个 AspectIdentifier 对象，并放入 AspectsContainer 对象管理。AspectIdentifier 对象 表示一个 aspect 的内容</li></ol><p>细看 aspect_isSelectorAllowedAndTrack 方法的内容，看如何判断一个 selector 是否符合 hook 规则</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 判断 selector 是否能被 hook</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">BOOL</span> aspect_isSelectorAllowedAndTrack(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, AspectOptions options, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-comment">// 不能被 hook 的方法集合</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSSet</span> *disallowedSelectorList;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> pred;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;pred, ^&#123;<br>        <span class="hljs-comment">// 这些方法不能被 hook</span><br>        disallowedSelectorList = [<span class="hljs-built_in">NSSet</span> setWithObjects:<span class="hljs-string">@&quot;retain&quot;</span>, <span class="hljs-string">@&quot;release&quot;</span>, <span class="hljs-string">@&quot;autorelease&quot;</span>, <span class="hljs-string">@&quot;forwardInvocation:&quot;</span>, <span class="hljs-literal">nil</span>];<br>    &#125;);<br>    <br>    <span class="hljs-comment">// Check against the blacklist.</span><br>    <span class="hljs-comment">// ...... 省略代码</span><br>    <br>    <span class="hljs-comment">// Additional checks.</span><br>    AspectOptions position = options&amp;AspectPositionFilter;<br>    <span class="hljs-comment">// dealloc 方法不允许在执行之后被 hook，因为对象会被销毁</span><br>    <span class="hljs-keyword">if</span> ([selectorName isEqualToString:<span class="hljs-string">@&quot;dealloc&quot;</span>] &amp;&amp; position != AspectPositionBefore) &#123;<br>       <span class="hljs-comment">// ...... 省略代码</span><br>    &#125;<br>    <span class="hljs-comment">// 被 hook 的方法不存在于类中</span><br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> respondsToSelector:selector] &amp;&amp; ![<span class="hljs-keyword">self</span>.class instancesRespondToSelector:selector]) &#123;<br>       <span class="hljs-comment">// ...... 省略代码</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// Search for the current class and the class hierarchy IF we are modifying a class object</span><br>    <span class="hljs-keyword">if</span> (class_isMetaClass(object_getClass(<span class="hljs-keyword">self</span>))) &#123;<br>        Class klass = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>        <span class="hljs-built_in">NSMutableDictionary</span> *swizzledClassesDict = aspect_getSwizzledClassesDict();<br>        Class currentClass = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>        <br>        AspectTracker *tracker = swizzledClassesDict[currentClass];<br>        <span class="hljs-comment">// 判断子类是否已经 hook 该方法</span><br>        <span class="hljs-keyword">if</span> ([tracker subclassHasHookedSelectorName:selectorName]) &#123;<br>            <span class="hljs-comment">// ...... 省略代码</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 判断是否已经 hook 了该方法</span><br>            tracker = swizzledClassesDict[currentClass];<br>            <span class="hljs-keyword">if</span> ([tracker.selectorNames containsObject:selectorName]) &#123;<br>                <span class="hljs-keyword">if</span> (klass == currentClass) &#123;<br>                    <span class="hljs-comment">// Already modified and topmost!</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>                &#125;<br>                <span class="hljs-built_in">NSString</span> *errorDescription = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;</span>, selectorName, <span class="hljs-built_in">NSStringFromClass</span>(currentClass)];<br>                AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));<br>        <br>        <span class="hljs-comment">// ...... 省略代码</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>selector 不允许被 hook 的判断规则</p><ol><li>@”retain”, @”release”, @”autorelease”, @”forwardInvocation:” 这些方法是不允许被 hook 的</li><li>dealloc 方法不允许在执行之后被 hook</li><li>被 hook 的方法不存在于类中</li><li>一个方法只能被 hook 一次</li></ol><p>接下来看看 static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) 方法实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> aspect_prepareClassAndHookSelector(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(selector);<br>    Class klass = aspect_hookClass(<span class="hljs-keyword">self</span>, error);<span class="hljs-comment">// 1  swizzling forwardInvocation</span><br>    <span class="hljs-comment">// 被 hook 的 selector</span><br>    Method targetMethod = class_getInstanceMethod(klass, selector);<br>    IMP targetMethodIMP = method_getImplementation(targetMethod);<br>    <span class="hljs-keyword">if</span> (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;<span class="hljs-comment">//2  swizzling method</span><br>        <span class="hljs-comment">// 使用一个 aliasSelector 来指向原来 selector 的方法实现</span><br>        <span class="hljs-comment">// Make a method alias for the existing method implementation, it not already copied.</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *typeEncoding = method_getTypeEncoding(targetMethod);<br>        SEL aliasSelector = aspect_aliasForSelector(selector);<br>        <span class="hljs-keyword">if</span> (![klass instancesRespondToSelector:aliasSelector]) &#123;<br>            __unused <span class="hljs-type">BOOL</span> addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);<br>            <span class="hljs-built_in">NSCAssert</span>(addedAlias, <span class="hljs-string">@&quot;Original implementation for %@ is already copied to %@ on %@&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(selector), <span class="hljs-built_in">NSStringFromSelector</span>(aliasSelector), klass);<br>        &#125;<br>        <br>        <span class="hljs-comment">// We use forwardInvocation to hook in.</span><br>        <span class="hljs-comment">// 把 selector 指向 _objc_msgForward 函数</span><br>        <span class="hljs-comment">// 用 _objc_msgForward 函数指针代替 selector 的 imp,然后执行这个 imp</span><br>        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(<span class="hljs-keyword">self</span>, selector), typeEncoding);<br>        AspectLog(<span class="hljs-string">@&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, klass, <span class="hljs-built_in">NSStringFromSelector</span>(selector));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>swizzling forwardInvocation。</li><li>拿到原始 selector 的 方法实现，再生成一个 aliasSelector 来指向原来 selector 的方法实现</li><li>把 selector 指向 _objc_msgForward 函数，用 _objc_msgForward 函数指针代替 selector 的 IMP ，这样执行 selector 的时候就会执行 _objc_msgForward 函数。</li></ol><p>接下来看看 static Class aspect_hookClass(NSObject *self, NSError **error) 的实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><br><span class="hljs-keyword">static</span> Class aspect_hookClass(<span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, <span class="hljs-built_in">NSError</span> **error) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(<span class="hljs-keyword">self</span>);<br>    Class statedClass = <span class="hljs-keyword">self</span>.class;<br>    Class baseClass = object_getClass(<span class="hljs-keyword">self</span>);<br>    <span class="hljs-built_in">NSString</span> *className = <span class="hljs-built_in">NSStringFromClass</span>(baseClass);<br>    <span class="hljs-comment">// 是否有 _Aspects_ 后缀</span><br>    <span class="hljs-comment">// Already subclassed</span><br>    <span class="hljs-keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;<br>        <span class="hljs-keyword">return</span> baseClass;<br>        <span class="hljs-comment">// We swizzle a class object, not a single object.</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (class_isMetaClass(baseClass)) &#123;<br>        <span class="hljs-keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="hljs-keyword">self</span>);<br>        <span class="hljs-comment">// Probably a KVO&#x27;ed class. Swizzle in place. Also swizzle meta classes in place.</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (statedClass != baseClass) &#123;<br>        <span class="hljs-keyword">return</span> aspect_swizzleClassInPlace(baseClass);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的 forwardInvocation 方法</span><br>    <span class="hljs-comment">// Default case. Create dynamic subclass.</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;<br>    Class subclass = objc_getClass(subclassName);<br>    <br>    <span class="hljs-keyword">if</span> (subclass == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-comment">// 生成 baseClass 对象的子类</span><br>        subclass = objc_allocateClassPair(baseClass, subclassName, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (subclass == <span class="hljs-literal">nil</span>) &#123;<br>            <span class="hljs-built_in">NSString</span> *errrorDesc = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;objc_allocateClassPair failed to allocate class %s.&quot;</span>, subclassName];<br>            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <span class="hljs-comment">// 替换子类的 forwardInvocation 方法</span><br>        aspect_swizzleForwardInvocation(subclass);<br>        <span class="hljs-comment">// 修改了 subclass 以及其 subclass metaclass 的 class 方法,使他返回当前对象的 class。</span><br>        aspect_hookedGetClass(subclass, statedClass);<br>        aspect_hookedGetClass(object_getClass(subclass), statedClass);<br>        objc_registerClassPair(subclass);<br>    &#125;<br>    <span class="hljs-comment">// 将当前对象 isa 指针指向了 subclass</span><br>    <span class="hljs-comment">// 将当前 self 设置为子类，这里其实只是更改了 self 的 isa 指针而已</span><br>    object_setClass(<span class="hljs-keyword">self</span>, subclass);<br>    <span class="hljs-keyword">return</span> subclass;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法的作用是动态生成一个当前对象的子类，并将当前对象与子类关联,然后替换子类的 forwardInvocation 方法，这样做的好处是不需要去更改对象本身的实例。该方法调用了static void aspect_swizzleForwardInvocation(Class klass) 方法对子类的 forwardInvocation: 方法进行混写;</p><p>接下来看看 static void aspect_swizzleForwardInvocation(Class klass) 的方法实现，看它如何实现对 forwardInvocation: 方法的混写</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//swizzling forwardinvation 方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> AspectsForwardInvocationSelectorName = <span class="hljs-string">@&quot;__aspects_forwardInvocation:&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(klass);<br>    <span class="hljs-comment">// If there is no method, replace will act like class_addMethod.</span><br>    <span class="hljs-comment">// 使用 __ASPECTS_ARE_BEING_CALLED__ 替换子类的 forwardInvocation 方法实现</span><br>    <span class="hljs-comment">// 由于子类本身并没有实现 forwardInvocation ，</span><br>    <span class="hljs-comment">// 所以返回的 originalImplementation 将为空值，所以子类也不会生成 AspectsForwardInvocationSelectorName 这个方法</span><br>    IMP originalImplementation = class_replaceMethod(klass, <span class="hljs-keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    <span class="hljs-keyword">if</span> (originalImplementation) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class_addMethod&quot;</span>);<br>        class_addMethod(klass, <span class="hljs-built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    &#125;<br>    AspectLog(<span class="hljs-string">@&quot;Aspects: %@ is now aspect aware.&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(klass));<br>&#125;<br></code></pre></td></tr></table></figure><p>关键实现在在这句代码,将 forwardInvocation: 的实现换成 __ASPECTS_ARE_BEING_CALLED__实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">IMP originalImplementation = class_replaceMethod(klass, <span class="hljs-keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="hljs-string">&quot;v@:@&quot;</span>);<br></code></pre></td></tr></table></figure><p>到这里我们可以知道了，知道 hook 了一个方法，那么最后都会执行 <strong>ASPECTS_ARE_BEING_CALLED</strong> 这个方法，代码执行到这里基本就到末尾了。我们看看这个方法实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// This is the swizzled forwardInvocation: method.</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="hljs-keyword">unsafe_unretained</span> <span class="hljs-built_in">NSObject</span> *<span class="hljs-keyword">self</span>, SEL selector, <span class="hljs-built_in">NSInvocation</span> *invocation) &#123;<br>    <span class="hljs-comment">// ... 省略代码</span><br><br>    <span class="hljs-comment">// Before hooks. 在切面之前执行</span><br>    aspect_invoke(classContainer.beforeAspects, info);<br>    aspect_invoke(objectContainer.beforeAspects, info);<br>    <br>    <span class="hljs-comment">// Instead hooks. 替换切面</span><br>    <span class="hljs-type">BOOL</span> respondsToAlias = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;<br>        aspect_invoke(classContainer.insteadAspects, info);<br>        aspect_invoke(objectContainer.insteadAspects, info);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 重新转回原来的 selector 所指向的函数</span><br>        Class klass = object_getClass(invocation.target);<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;<br>                [invocation invoke];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));<br>    &#125;<br>    <br>    <span class="hljs-comment">// After hooks. 在切面之后执行</span><br>    aspect_invoke(classContainer.afterAspects, info);<br>    aspect_invoke(objectContainer.afterAspects, info);<br>    <br>    <span class="hljs-comment">// If no hooks are installed, call original implementation (usually to throw an exception)</span><br>    <span class="hljs-comment">// 找不到 aliasSelector 的方法实现，也就是没有找到被 hook 的 selector 的原始方法实现，那么进行消息转发</span><br>    <span class="hljs-keyword">if</span> (!respondsToAlias) &#123;<br>        invocation.selector = originalSelector;<br>        SEL originalForwardInvocationSEL = <span class="hljs-built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;<br>            ((<span class="hljs-type">void</span>( *)(<span class="hljs-type">id</span>, SEL, <span class="hljs-built_in">NSInvocation</span> *))objc_msgSend)(<span class="hljs-keyword">self</span>, originalForwardInvocationSEL, invocation);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:invocation.selector];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Remove any hooks that are queued for deregistration.</span><br>    [aspectsToRemove makeObjectsPerformSelector:<span class="hljs-keyword">@selector</span>(remove)];<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>根据切面的时机点，执行相应的代码</li><li>执行完额外的代码之后，看下是否需要回到原来的代码上，若是需要则执行原来的代码</li><li>若是没有找到被 hook 的 selector 的原始方法实现，那么进行消息转发</li><li>Aspects 做对应的清理工作</li></ol><h3 id="Aspects-的思路"><a href="#Aspects-的思路" class="headerlink" title="Aspects 的思路"></a>Aspects 的思路</h3><ol><li><p>找到被 hook 的 originalSelector 的 方法实现</p></li><li><p>新建一个 aliasSelector 指向原来的 originalSelector 的方法实现</p></li><li><p>动态创建一个 originalSelector 所在实例的子类，然后 hook 子类的 forwardInvocation: 方法并将方法的实现替换成 <strong>ASPECTS_ARE_BEING_CALLED</strong> 方法</p></li><li><p>originalSelector 指向 _objc_msgForward 方法实现</p></li><li><p>实例的 originalSelector 的方法执行的时候，实际上是指向 <em>objc_msgForward ，而 <em>objc_msgForward 的方法实现被替换成  <strong>ASPECTS_ARE_BEING_CALLED</strong> 的方法实现，也就是说 originalSelector 的方法执行之后，实际上执行的是__ASPECTS_ARE_BEING_CALLED</em></em> 的方法实现。而 aliasSelector 的作用就是用来保存 originalSelector 的方法实现，当 hook 代码执行完成之后，可以回到 originalSelector 的原始方法实现上继续执行。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/steipete/Aspects">https://github.com/steipete/Aspects</a></li><li><a href="https://wereadteam.github.io/2016/06/30/Aspects/">https://wereadteam.github.io/2016/06/30/Aspects/</a></li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></li><li><a href="http://www.jianshu.com/p/8295f2503594">Objective-C 之 objc_msgSend 简单实现</a></li><li><a href="http://www.jianshu.com/p/e0682171f0a2">Objective-C 方法签名和调用</a></li><li><a href="http://www.jianshu.com/p/6186320a79db">Objective-C 动态实现</a></li><li><a href="http://www.jianshu.com/p/bdf84c417e4f">Objective-C 消息转发</a></li><li><a href="http://www.jianshu.com/p/1d59d266b8be">Objective-C 方法混写</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C Swizzling 原理</title>
    <link href="/2017/04/23/oc-swizzle/"/>
    <url>/2017/04/23/oc-swizzle/</url>
    
    <content type="html"><![CDATA[<h3 id="方法混写"><a href="#方法混写" class="headerlink" title="方法混写"></a>方法混写</h3><p>在 Objctive-C 中，混写（Swizzling）指的是偷梁换柱，将一个东西透明的换成另外一个东西，在 Runtime 运行时替换方法实现。<br>这个技术有什么作用呢？我们利用混写技术可以改变那些没有源代码的对象的行为，这其中包括了一些系统对象的行为，也包括了一些第三方 SDK 。</p><h3 id="给-NSNotificationCenter-添加日志"><a href="#给-NSNotificationCenter-添加日志" class="headerlink" title="给 NSNotificationCenter 添加日志"></a>给 NSNotificationCenter 添加日志</h3><p>接下来展示一个案例，每次在给 NSNotificationCenter 添加观察者的时候就打印日志。</p><span id="more"></span><h3 id="创建-NSObject-MethodSwizzle"><a href="#创建-NSObject-MethodSwizzle" class="headerlink" title="创建 NSObject+MethodSwizzle"></a>创建 NSObject+MethodSwizzle</h3><p>创建一个 NSObject 的 Category，叫做 NSObject+MethodSwizzle  用于实现方法混写。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// NSObject+MethodSwizzle.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">// 为 NSObject 添加方法混写实现</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br>+ (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">// NSObject+MethodSwizzle.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+MethodSwizzle.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><br><span class="hljs-comment">// 把 origSelector 的当前实现替换为新的实现</span><br>+(IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP&#123;<br>    <span class="hljs-comment">// 当前 class</span><br>    Class <span class="hljs-keyword">class</span> = [<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>];<br>    <span class="hljs-comment">// 获取 origSelector 的 Method</span><br>    Method origMethod = class_getInstanceMethod(<span class="hljs-keyword">class</span>, origSelector);<br>    <span class="hljs-comment">// 获取 origSelector 的实现</span><br>    IMP origIMP = method_getImplementation(origMethod);<br><br>    <span class="hljs-comment">// 若是 class_addMethod 给 class 成功添加了方法，那么返回 YES，否则返回 NO。</span><br>    <span class="hljs-comment">// class_addMethod 会覆盖父类的方法实现，若是覆写方法会返回 YES。</span><br>    <span class="hljs-comment">// class_addMethod 返回 NO，那么我们可以知道这个类是直接实现了 origSelector 对应的方法</span><br>    <span class="hljs-type">BOOL</span> isAdd = class_addMethod(<span class="hljs-keyword">class</span>, origSelector, newIMP, method_getTypeEncoding(origMethod));<br>    <span class="hljs-keyword">if</span> (!isAdd) &#123;<br>        <span class="hljs-comment">// 替换 origMethod 方法的实现</span><br>        method_setImplementation(origMethod, newIMP);<br>    &#125;<br>    <span class="hljs-comment">// 返回 origSelector 对应的方法的实现</span><br>    <span class="hljs-keyword">return</span> origIMP;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>NSObject+MethodSwizzle 的 + (IMP)swizzleSelector:(SEL)origSelector withIMP:(IMP)newIMP;<br>方法用于把类中的 origSelector 这个 Selector 对应的方法实现替换为 newIMP 这个方法实现。<br>在做方法混写的时候我们需要考虑三个情况：</p><ol><li>该类直接实现了这个方法</li><li>该类的类层次结构中的某个父类实现了这个方法</li><li>该类压根没有实现这个方法<br>我们使用了 class_addMethod 来处理以上三种情况。</li></ol><h3 id="创建-NSNotificationCenter-MethodSwizzle"><a href="#创建-NSNotificationCenter-MethodSwizzle" class="headerlink" title="创建 NSNotificationCenter+MethodSwizzle"></a>创建 NSNotificationCenter+MethodSwizzle</h3><p>创建 NSNotificationCenter 的 Category,叫做 NSNotificationCenter+MethodSwizzle 用于给 NSNotificationCenter 添加混写方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// NSNotificationCenter+MethodSwizzle.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSNotificationCenter</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><span class="hljs-comment">// 给自己添加方法混写</span><br>+ (<span class="hljs-type">void</span>)swizzleAddObserver;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// NSNotificationCenter+MethodSwizzle.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSNotificationCenter+MethodSwizzle.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+MethodSwizzle.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSNotificationCenter</span> (<span class="hljs-title">MethodSwizzle</span>)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (*voidIMP)(<span class="hljs-type">id</span>,SEL,...);<br><span class="hljs-keyword">static</span> voidIMP sOrigAddObserver = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 用于替换 NSNotificationCenter 的 addObserver:selector:name:object: 的默认实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> MyAddObserver(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>,SEL _cmd,<span class="hljs-type">id</span> observer,SEL selector,<span class="hljs-built_in">NSString</span> *name,<span class="hljs-type">id</span> object)&#123;<br>    <span class="hljs-comment">// 打印日志</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;添加观察者：%@&quot;</span>,observer);<br>    <span class="hljs-built_in">NSAssert</span>(sOrigAddObserver, <span class="hljs-string">@&quot;旧方法找不到&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sOrigAddObserver)&#123;<br>        <span class="hljs-comment">// 调用原来的方法实现</span><br>        sOrigAddObserver(<span class="hljs-keyword">self</span>,_cmd,observer,selector,name,object);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 方法混写实现</span><br>+ (<span class="hljs-type">void</span>)swizzleAddObserver&#123;<br>    <span class="hljs-comment">//  swizzleAddObserver 只能被调用一次，可以采用更好的方法来实现这个需求</span><br>    <span class="hljs-built_in">NSAssert</span>(!sOrigAddObserver, <span class="hljs-string">@&quot;swizzleAddObserver 只能调用一次&quot;</span>);<br>    <span class="hljs-comment">// 准备混写的方法</span><br>    SEL sel = <span class="hljs-keyword">@selector</span>(addObserver:selector:name:object:);<br>    <span class="hljs-comment">// 替换方法新实现，并拿到旧方法实现</span><br>    sOrigAddObserver = (<span class="hljs-type">void</span> *)[<span class="hljs-keyword">self</span> swizzleSelector:sel withIMP:(IMP)MyAddObserver];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>NSNotificationCenter+MethodSwizzle 的swizzleAddObserver会将 addObserver:selector:name:object: 的系统默认实现替换为自己的实现 MyAddObserver，<br>MyAddObserver 在每次 NSNotificationCenter 添加观察者时会打印一个日志，然后再调用 addObserver:selector:name:object: 的系统默认实现。</p><h2 id="在-ViewController-中使用"><a href="#在-ViewController-中使用" class="headerlink" title="在 ViewController 中使用"></a>在 ViewController 中使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 加载方法混写</span><br>    [<span class="hljs-built_in">NSNotificationCenter</span> swizzleAddObserver];<br>    <span class="hljs-comment">// 给 NSNotificationCenter 添加一个观察者</span><br>    Observer *observer = [[Observer alloc] init];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:observer<br>                                             selector:<span class="hljs-keyword">@selector</span>(somthingHappened:)<br>                                                 name:<span class="hljs-string">@&quot;SomethingHappenedNotification&quot;</span><br>                                               object:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">添加观察者：&lt;Observer: <span class="hljs-number">0x60800001b660</span>&gt;<br></code></pre></td></tr></table></figure><p>在执行 NSNotificationCenter 添加观察者的代码的同时，控制台输出了我们预埋的日志，<br>可以看出 NSNotificationCenter 的 addObserver:selector:name:object: 方法实现已经被我们替换为自己的方法实现了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方法混写是一个非常强大的技术，但是用不好也会引发一些莫名其妙的 bug 。<br>通常方法混写技术最好不要用于线上代码，但在开发过程中对于调试，性能调优和研究系统框架实现又是有非常大的作用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li>demo 地址 <a href="https://github.com/junbinchencn/Swizzle">https://github.com/junbinchencn/Swizzle</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 视频剪切、旋转，视频添加音频、添加水印，视频导出</title>
    <link href="/2017/04/16/video-editor-ios/"/>
    <url>/2017/04/16/video-editor-ios/</url>
    
    <content type="html"><![CDATA[<h1 id="AVSimpleEditoriOS-解读"><a href="#AVSimpleEditoriOS-解读" class="headerlink" title="AVSimpleEditoriOS 解读"></a>AVSimpleEditoriOS 解读</h1><p>视频处理主要是用到以下这几个类<br><strong>AVMutableComposition</strong>、<strong>AVMutableVideoComposition</strong>、<strong>AVMutableAudioMix</strong>、<strong>AVMutableVideoCompositionInstruction</strong>、<strong>AVMutableVideoCompositionLayerInstruction</strong>、<strong>AVAssetExportSession</strong> 等。其中 AVMutableComposition 可以用来操作音频和视频的组合，AVMutableVideoComposition 可以用来对视频进行操作，AVMutableAudioMix 类是给视频添加音频的，AVMutableVideoCompositionInstruction和AVMutableVideoCompositionLayerInstruction 一般都是配合使用，用来给视频添加水印或者旋转视频方向，AVAssetExportSession 是用来进行视频导出操作的。需要值得注意的是当App进入后台之后，会对使用到GPU的代码操作进行限制，会造成崩溃，而视频处理这些功能多数会使用到GPU,所以需要做对应的防错处理。<br>在这里我会使用Apple的官方Demo “<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html">AVSimpleEditoriOS</a>“ 作为讲解案例，该案例采用Command设计模式来组织代码，其中基类的AVSECommand包含了一些各个子类Command共用的属性。本文就视频相关操作做简要介绍，说明一些相关的操作，并标注一些重点代码，希望本文可以起到抛砖引玉的效果,让大家对视频剪辑处理有个初步印象，然后可以根据Apple官方Demo的内容进行相应的修改。大家可以下载相应的Apple官方Demo运行查看结果。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableComposition</span> *mutableComposition;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableVideoComposition</span> *mutableVideoComposition;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">AVMutableAudioMix</span> *mutableAudioMix;<br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">CALayer</span> *watermarkLayer;<br></code></pre></td></tr></table></figure><img src="/2017/04/16/video-editor-ios/Untitled.webp" class="" title="image"><h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><img src="/2017/04/16/video-editor-ios/Untitled1.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li></ol><h2 id="视频旋转"><a href="#视频旋转" class="headerlink" title="视频旋转"></a>视频旋转</h2><p>在查有关视频旋转的资料的时候查看了一篇很不错的参考资料，在这里给大家安利一下<br><a href="http://blog.csdn.net/likendsl/article/details/7595611">http://blog.csdn.net/likendsl/article/details/7595611</a> 讲的是矩阵运算的原理，对视图的矩阵操作的相关内容。</p><img src="/2017/04/16/video-editor-ios/Untitled2.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled3.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled4.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>设置旋转矩阵变换</li><li>创建AVMutableVideoComposition对象</li><li>设置视频的渲染宽高和Frame</li><li>创建视频组合指令AVMutableVideoCompositionInstruction，并设置指令在视频的作用时间范围和旋转矩阵变换</li><li>创建视频组合图层指令AVMutableVideoCompositionLayerInstruction，并设置图层指令在视频的作用时间范围和旋转矩阵变换</li><li>把视频图层指令放到视频指令中，再放入视频组合对象中</li></ol><p>这里给出不同旋转角度的案例代码，希望能够对你起帮助，节省你的时间。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CGAffineTransform</span> translateToCenter;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.degrees != <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">CGAffineTransform</span> mixedTransform;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">90</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转90°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转90度,home按键在左&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(mixedVideoTrack.naturalSize.height,<span class="hljs-number">0.0</span>);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI_2);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.height,mixedVideoTrack.naturalSize.width);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">180</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转180°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转180度，home按键在上&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(mixedVideoTrack.naturalSize.width, mixedVideoTrack.naturalSize.height);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.width,mixedVideoTrack.naturalSize.height);<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.degrees == <span class="hljs-number">270</span>)&#123;<br>           <span class="hljs-comment">//顺时针旋转270°</span><br>           <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;视频旋转270度，home按键在右&quot;</span>);<br>           translateToCenter = <span class="hljs-built_in">CGAffineTransformMakeTranslation</span>(<span class="hljs-number">0.0</span>, assetVideoTrack.naturalSize.width);<br>           mixedTransform = <span class="hljs-built_in">CGAffineTransformRotate</span>(translateToCenter,M_PI_2*<span class="hljs-number">3.0</span>);<br>           waterMarkVideoComposition.renderSize = <span class="hljs-built_in">CGSizeMake</span>(mixedVideoTrack.naturalSize.height,mixedVideoTrack.naturalSize.width);<br>       &#125;<br>       <span class="hljs-built_in">AVMutableVideoCompositionInstruction</span> *roateInstruction = [<span class="hljs-built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];<br>       roateInstruction.timeRange = <span class="hljs-built_in">CMTimeRangeMake</span>(kCMTimeZero, [mixComposition duration]);<br>      <span class="hljs-built_in">AVMutableVideoCompositionLayerInstruction</span> *roateLayerInstruction = [<span class="hljs-built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:mixedVideoTrack];<br>       <br>       [roateLayerInstruction setTransform:mixedTransform atTime:kCMTimeZero];<br>       <br>       roateInstruction.layerInstructions = @[roateLayerInstruction];<br>       <span class="hljs-comment">//将视频方向旋转加入到视频处理中</span><br>       waterMarkVideoComposition.instructions = @[roateInstruction];<br>       <br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="视频添加音频"><a href="#视频添加音频" class="headerlink" title="视频添加音频"></a>视频添加音频</h2><img src="/2017/04/16/video-editor-ios/Untitled5.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled6.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>往AVMutableComposition对象添加要追加的音频资源，同时设置音频资源的时间段，插入点和混合模式</li></ol><h2 id="视频添加水印"><a href="#视频添加水印" class="headerlink" title="视频添加水印"></a>视频添加水印</h2><img src="/2017/04/16/video-editor-ios/Untitled7.webp" class="" title="image"><img src="/2017/04/16/video-editor-ios/Untitled8.webp" class="" title="image"><ol><li>拿到视频和音频资源</li><li>创建AVMutableComposition对象</li><li>往AVMutableComposition对象添加视频资源，同时设置视频资源的时间段和插入点</li><li>往AVMutableComposition对象添加音频资源，同时设置音频资源的时间段和插入点</li><li>创建视频组合器对象 AVMutableVideoComposition 并设置frame和渲染宽高</li><li>创建视频组合器指令对象，设置指令的作用范围</li><li>创建视频组合器图层指令对象，设置指令的作用范围</li><li>视频组合器图层指令对象 放入 视频组合器指令对象中</li><li>视频组合器指令对象放入视频组合器对象</li><li>创建水印图层Layer并设置frame和水印的位置，并将水印加入视频组合器中</li></ol><h2 id="视频导出"><a href="#视频导出" class="headerlink" title="视频导出"></a>视频导出</h2><img src="/2017/04/16/video-editor-ios/Untitled9.webp" class="" title="image"><ol><li>创建输出路径</li><li>根据AVMutableComposition对象创建AVAssetExportSession视频导出对象</li><li>设置AVAssetExportSession的AVMutableVideoComposition对象，AVMutableAudioMix对象，视频导出路径，视频导出格式</li><li>异步导出视频，根据导出结果做对应处理。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://blog.csdn.net/likendsl/article/details/7595611">http://blog.csdn.net/likendsl/article/details/7595611</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 之 objc_msgSend 简单实现</title>
    <link href="/2017/04/16/oc-msgsend/"/>
    <url>/2017/04/16/oc-msgsend/</url>
    
    <content type="html"><![CDATA[<h3 id="objc-msgSend-函数"><a href="#objc-msgSend-函数" class="headerlink" title="objc_msgSend 函数"></a>objc_msgSend 函数</h3><p>在 Objective-C 中, message 是直到 Runtime 的时候才会绑定实现，编译器会将我们的发送消息 [receiver message] 变成函数调用 objc_msgSend，该函数会有2个默认参数，分别是 receiver 和 selector 。当然，若是该函数有其他的参数，那么其他参数就跟在2个默认参数后面。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">objc_msgSend(receiver, selector, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p>在动态绑定过程中，objc_msgSend 函数的作用如下</p><ol><li>找到 selector 对应的方法实现，</li><li>调用方法实现，传入参数</li><li>接收方法实现的返回值并将这个返回值作为自己的返回值</li></ol><p>objc_msgSend 函数调用过程中依赖于编译器为每个类和对象提供的一些类结构，这个类结构包含了下面 2 个基本元素</p><ol><li>一个指向 superclass 的指针, 这个指针叫做 isa，对象可以用它来来访问 class ，通过 class 可以访问这个 class 类继承层次上的所有其他 class</li><li>一个 class dispatch table , 一个 selector - 方法实现地址 对应的表格， 比如 sestOrigin:: 的 selector 对应的是 setOrigin::的方法实现地址</li></ol><img src="/2017/04/16/oc-msgsend/Untitled.webp" class="" title="image"><p>Messaging 过程如上图所示，当一个对象收到一个消息（message）的时候，objc_msgSend 函数（messaging function） 会根据对象的 isa 指针 到 class dispatch table 里面去查找 method selector 。如果找不到呢？那就根据 isa 指针寻找到 superclass ，若是一直没有找到，那么就会沿着类继承层次来到了 NSObjct 。一旦找到了 method selector,那么就调用 method selector 对应的方法实现并传入对应的参数。这就是 Runtime 寻找方法实现的方式，消息动态绑定到方法实现。</p><p>为了提高 Messaging 过程的速度，消息被首次使用的时候，Runtime 会缓存 selector 和 方法实现地址。Messaging 的时候会先查询缓存，若是没有缓存，那么去 class dispatch table 寻找，若是有缓存，那么直接使用缓存，这个时候 Messaging 的速度只是比直接的函数调用来的慢那么一点点儿，这个差异基本可以忽略。</p><p>Runtime 的核心在于消息分派器 objc_msgSend，它的作用是把选择器映射为函数指针，并调用被函数指针引用的函数。我们来做简单的 objc_msgSend 的实现。</p><h3 id="C-代码实现消息分派器"><a href="#C-代码实现消息分派器" class="headerlink" title="C 代码实现消息分派器"></a>C 代码实现消息分派器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">myMsgSend</span><span class="hljs-params">(id receiver, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>&#123;<br>    <span class="hljs-comment">// selector 是选择器，是方法名的唯一标识符</span><br>    SEL selector = sel_registerName(name);<br>    <span class="hljs-comment">// methodIMP 方法实现，只是一个指向方法某个函数的指针</span><br>    IMP methodIMP = class_getMethodImplementation(object_getClass(receiver), selector);<br>    <span class="hljs-comment">// 执行 methodIMP 方法实现，methodIMP 接受一个对象，一个选择器，可变长参数列表作为参数，并返回一个对象</span><br>    <span class="hljs-keyword">return</span> methodIMP(receiver,selector);<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个 myMsgSend 函数，该函数的作用类似于 objc_msgSend。</p><ol><li>使用 sel_registerName 获取方法的唯一标识符</li><li>使用 class_getMethodImplementation 获取关于某个类或者对象的方法实现</li><li>给对应得方法实现 methodIMP 传入合适的参数，并返回一个对象。</li></ol><p>接下来我们看看如何使用这个简单的 objc_msgSend 实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">RunMyMsgSend</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-comment">// NSObject *object = [[NSObject alloc] init];</span><br>    <span class="hljs-comment">// objectClass 定义了 Objective-C 的类</span><br>    Class objectClass = (Class)objc_getClass(<span class="hljs-string">&quot;NSObject&quot;</span>);<br>    id object = class_createInstance(objectClass, <span class="hljs-number">0</span>);<br>    myMsgSend(object, <span class="hljs-string">&quot;init&quot;</span>);<br>    <br>    <span class="hljs-comment">// id description = [object description];</span><br>    id description = (id)myMsgSend(object, <span class="hljs-string">&quot;description&quot;</span>);<br>    <br>    <span class="hljs-comment">// const char *cstr = [description UTF8String];</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cstr = myMsgSend(description, <span class="hljs-string">&quot;UTF8String&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,cstr);<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看到，我们将 Objective-C 的发送消息过程 ，使用 C 语言来做了简单的类似实现。可以粗略的说，Runtime 真的只是 C 。</p><ol><li><code> NSObject *object = [[NSObject alloc] init] </code> 发送 init 消息使用<code> myMsgSend(object, "init")</code> 实现</li><li><code>id description = [object description]</code> 发送 description 消息使用 <code> myMsgSend(object, "description") </code> 实现</li><li><code> [description UTF8String] </code> 发送 UTF8String 消息使用 <code> myMsgSend(description, "UTF8String")</code> 实现</li></ol><p>运行以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\nRunMyMsgSend()\n&quot;</span>);<br>RunMyMsgSend();<br>NSObject *testObj = [[NSObject alloc] init];<br>NSLog(@<span class="hljs-string">&quot;%@&quot;</span>, testObj);<br></code></pre></td></tr></table></figure><p>输出运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">RunMyMsgSend()<br>&lt;NSObject: <span class="hljs-number">0x60800000fd50</span>&gt;<br>&lt;NSObject: <span class="hljs-number">0x60800000fd60</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="methodForSelector-实现消息分派器"><a href="#methodForSelector-实现消息分派器" class="headerlink" title="methodForSelector: 实现消息分派器"></a>methodForSelector: 实现消息分派器</h3><p>在 Objective-C 中，我们可以使用 methodForSelector: 来实现消息分派,那么使用 methodForSelector: 和 使用 objc_msgSend相比，会有性能提升么？为了这个性能提升直接跳过objc_msgSend值得么? 直接用代码来个测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> NSUInteger kTotalCount = <span class="hljs-number">100000000</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*voidIMP)</span><span class="hljs-params">(id,SEL,...)</span>;<br><br><span class="hljs-comment">// 分别使用objc_msgSend 和 methodForSelector 来做消息分派，对字符串做一亿次操作之后进行耗时比较</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FastCall</span><span class="hljs-params">()</span>&#123;<br>    <br>    NSMutableString *<span class="hljs-built_in">string</span> = [NSMutableString <span class="hljs-built_in">string</span>];<br>    NSTimeInterval totalTime = <span class="hljs-number">0</span>;<br>    NSDate *start = nil;<br>    NSUInteger count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 用 objc_msgSend</span><br>    start = [NSDate date];<br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; kTotalCount; count ++) &#123;<br>        [<span class="hljs-built_in">string</span> setString:@<span class="hljs-string">&quot;stuff&quot;</span>];<br>    &#125;<br>    <span class="hljs-comment">// 计算用 objc_msgSend 耗时时间</span><br>    totalTime = -[start timeIntervalSinceNow];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w/ objc_msgSend = %f\n&quot;</span>, totalTime);<br><br>    <span class="hljs-comment">// 跳过 objc_msgSend, 使用 methodForSelector 来做消息分派</span><br>    start = [NSDate date];<br>    SEL selector = @selector(setString:);<br>    voidIMP setStringMethod = (voidIMP)[<span class="hljs-built_in">string</span> methodForSelector:selector];<br>    <span class="hljs-keyword">for</span> (count = <span class="hljs-number">0</span>; count &lt; kTotalCount; count ++) &#123;<br>        setStringMethod(<span class="hljs-built_in">string</span>,selector,@<span class="hljs-string">&quot;stuff&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 计算用 跳过 objc_msgSend 耗时时间</span><br>    totalTime = -[start timeIntervalSinceNow];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w/ objc_msgSend = %f\n&quot;</span>,totalTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>多次运行之后，结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">用 objc_msgSend 耗时 = <span class="hljs-number">6.885367</span><br>跳过 objc_msgSend 耗时 = <span class="hljs-number">6.475993</span><br></code></pre></td></tr></table></figure><p>可以为这个例子做个总结。<strong>多数情况下，我们会把 Objective-C 的方法重写成函数，这样可以得到更好更可靠的性能提升，但是不要想着绕过消息分派器 objc_msgSend ，因为 objc_msgSend 的性能开销已经小到可以忽略不计了，不需要再去优化这个过程了</strong>。</p><p>那么什么时候需要绕过消息分派器 objc_msgSend 呢？那就是循环内的大量方法调用，我们以一个<code>setFilled: </code>方法来做示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> (*setter)(id, SEL, BOOL);<br><span class="hljs-type">int</span> i;<br> <br>setter = (<span class="hljs-type">void</span> (*)(id, SEL, BOOL))[target<br>methodForSelector:@selector(setFilled:)];<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++ )<br>    setter(targetList[i], @selector(setFilled:), YES);<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 方法签名和调用</title>
    <link href="/2017/04/16/oc-signature-invocation/"/>
    <url>/2017/04/16/oc-signature-invocation/</url>
    
    <content type="html"><![CDATA[<h2 id="Objective-C-方法签名和调用"><a href="#Objective-C-方法签名和调用" class="headerlink" title="Objective-C 方法签名和调用"></a>Objective-C 方法签名和调用</h2><p>NSInvocation 是命令模式的一种实现。它把一个目标、一个选择器、一个方法签名、所有的参数都放到一个对象里面。当 NSInvocation 被调用的时候，Objective-C Runtime会执行正确的方法实现。<br>NSInvocation 包含的一个目标是一个接受消息的对象，包含的选择器是被发送的消息。在这里我们可以把选择器看成一个方法的名称，也就是一个字符串。那 NSInvocation 包含的方法签名是什么呢？方法签名 NSMethodSignature 是一个方法的返回类型和参数类型，不包括方法名称。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//  -[NSString  initWithUTF8String:] 的方法签名</span><br><span class="hljs-built_in">NSMethodSignature</span> *signature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;@@:*&quot;</span>];<br></code></pre></td></tr></table></figure><p>方法签名的 “ @@:* “ 字符串怎么理解呢？ 第一个字符 @ 表明返回值是一个 id。对于消息传递系统来说，所以的 Objective-C 对象都是 id 类型。 接下来的二个字符 @： 表明该方法接受一个 id 和一个 SEL 。其实每个 Objective-C 方法都把 id 和 SEL 作为头2个参数。最后一个字符 *   表示该方法的一个显式的参数是一个字符串（char *）。那如何获取这些类型编码呢，可以参考官方文档 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a> ，也可以直接使用类型编码 @encode(type) 获取表示该类型的字符串，而不必硬编码。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;id Type encoding --&gt;%s&quot;</span>,<span class="hljs-keyword">@encode</span>(<span class="hljs-type">id</span>));<br><span class="hljs-comment">//  输出结果 id Type encoding --&gt;@</span><br></code></pre></td></tr></table></figure><p>在平常的开发中我们基本是不需要去使用 signatureWithObjCTypes： 方法去手动创建一个方法签名的，我们可以直接使用 methodSignatureForSelector: 来获取类方法的签名或者实例方法的签名，对于实例方法的签名获取也可以直接使用 instanceMethodForSelector: 获取。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SEL initSEL = <span class="hljs-keyword">@selector</span>(init);<span class="hljs-comment">// init 方法的选择器</span><br>SEL allocSEL = <span class="hljs-keyword">@selector</span>(alloc);<span class="hljs-comment">// alloc 方法的选择器</span><br><br><span class="hljs-built_in">NSMethodSignature</span> *initSignature, *allocSignature;<br><span class="hljs-comment">// 从实例中获取实例方法签名</span><br>initSignature = [<span class="hljs-string">@&quot;Signature&quot;</span> methodSignatureForSelector:initSEL];<br><span class="hljs-comment">// 从类中获取实例方法签名</span><br>initSignature = [<span class="hljs-built_in">NSString</span> instanceMethodSignatureForSelector:initSEL];<br><span class="hljs-comment">// 从类中获取类方法签名</span><br>allocSignature = [<span class="hljs-built_in">NSString</span> methodSignatureForSelector:allocSEL];<br></code></pre></td></tr></table></figure><p>知道了方法签名的概念之后，我们可以构建一个 NSInvocation 对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//  创建数组</span><br>    <span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;array.count---&gt;%ld&quot;</span>,array.count);<br><span class="hljs-comment">//  创建一个 NSString 对象，该对象后面加入 array</span><br>    <span class="hljs-built_in">NSString</span> *stuff = <span class="hljs-string">@&quot;Stuff&quot;</span>;<br><span class="hljs-comment">//  获取 NSMutableArray 的 addObject: 方法签名</span><br>    SEL selector = <span class="hljs-keyword">@selector</span>(addObject:);<br>    <span class="hljs-built_in">NSMethodSignature</span> *signature = [array methodSignatureForSelector:selector];<br><br><span class="hljs-comment">//  创建 NSInvocation 对象</span><br>    <span class="hljs-comment">//  使用方法签名</span><br>    <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:signature];<br>    <span class="hljs-comment">// array 是接收消息的对象</span><br>    [invocation setTarget:array];<br>    <span class="hljs-comment">// 被 invocation 发送的消息 selector</span><br>    [invocation setSelector:selector];<br>    <span class="hljs-comment">// 默认 index = 0 位置的参数是 目标（self）， index = 1 位置的参数是 selector（_cmd）,从 index =2 开始才是第一个参数</span><br>    [invocation setArgument:&amp;stuff atIndex:<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// 调用 NSInvocation</span><br>    [invocation invoke];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;array.count---&gt;%ld&quot;</span>,array.count);<br><span class="hljs-comment">//  运行结果</span><br><span class="hljs-comment">//   array.count---&gt;0</span><br><span class="hljs-comment">//   array.count---&gt;1</span><br></code></pre></td></tr></table></figure><p>Objective-C 的蹦床技术<br>蹦床顾名思义就是把一个消息从一个对象反弹到另一个对象。蹦床技术一般使用 forwardInvocation: 方法来处理消息。如果一个对象在 Objective-C 提示错误之前不响应一个选择器，那么就会创建一个 NSInvocation 对象 并且传递给该对象的 forwardInvocation: 。我们可以使用这个 NSInvocation 对象做消息转发。</p><p>接下来使用蹦床这个技术实现一个类似 NSNotification 的功能。我们创建一个 RNObserverManager 的蹦床，把发送到 RNObserverManager 的消息转发到响应选择器的已注册观察者。</p><p>第一步创建 RNObserverManager</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// RNObserverManager.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNObserverManager</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">// 初始化的时候 需要一个协议和一组观察者</span><br>- (<span class="hljs-type">id</span>)initWithProtocol:(Protocol *)protocol observers:(<span class="hljs-built_in">NSSet</span> *)observers;<br><span class="hljs-comment">// 添加观察者</span><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-type">id</span>)observer;<br><span class="hljs-comment">// 删除观察者</span><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-type">id</span>)observer;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RNObserverManager.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RNObserverManager</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableSet</span> *observers;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Protocol *protocol;<br><br><span class="hljs-keyword">@end</span><br><span class="hljs-comment">// 蹦床把一条消息从一个对象反弹到另一个对象。</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RNObserverManager</span></span><br><br>- (<span class="hljs-type">id</span>)initWithProtocol:(Protocol *)protocol observers:(<span class="hljs-built_in">NSSet</span> *)observers&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.protocol = protocol;<br>        <span class="hljs-keyword">self</span>.observers = [<span class="hljs-built_in">NSMutableSet</span> setWithSet:observers];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><br>- (<span class="hljs-type">void</span>)addObserver:(<span class="hljs-type">id</span>)observer&#123;<br>    <span class="hljs-keyword">if</span> ([observer conformsToProtocol:<span class="hljs-keyword">self</span>.protocol]) &#123;<br>        [<span class="hljs-keyword">self</span>.observers addObject:observer];<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)removeObserver:(<span class="hljs-type">id</span>)observer&#123;<br>    [<span class="hljs-keyword">self</span>.observers removeObject:observer];<br>&#125;<br><br><span class="hljs-comment">// Objective-C 的消息分派器使用这个方法为未知的选择器构造一个 NSInvocation</span><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *result = [<span class="hljs-variable language_">super</span> methodSignatureForSelector:aSelector];<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">// 查找所需方法</span><br>    <span class="hljs-keyword">struct</span> objc_method_description desc = protocol_getMethodDescription(<span class="hljs-keyword">self</span>.protocol, aSelector, <span class="hljs-literal">YES</span>, <span class="hljs-literal">YES</span>);<br><br>    <span class="hljs-keyword">if</span>(desc.name == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 有可能是协议的可选方法</span><br>        desc = protocol_getMethodDescription(<span class="hljs-keyword">self</span>.protocol, aSelector, <span class="hljs-literal">NO</span>, <span class="hljs-literal">YES</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(desc.name == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 找不到方法，那么抛出异常</span><br>        [<span class="hljs-keyword">self</span> doesNotRecognizeSelector:aSelector];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:desc.types];<br>&#125;<br><span class="hljs-comment">// 把方法调用转发到响应选择器的观察者</span><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation&#123;<br>    SEL selector = [anInvocation selector];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">id</span> responder <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers)&#123;<br>        <span class="hljs-keyword">if</span> ([responder respondsToSelector:selector]) &#123;<br>            [anInvocation setTarget:responder];<br>            [anInvocation invoke];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>RNObserverManager 对象在 Objective-C 提示错误之前不响应一个选择器的话， Objective-C 会用 NSObject 类的 <code> - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector  </code> 方法获取该未知选择器的方法签名， 然后为这个未知的选择器构造一个 NSInvocation 对象，最后将这个 NSInvocation 对象传递给 NSObject 的 <code>- (void)forwardInvocation:(NSInvocation *)anInvocation </code> 方法。</p><p>那么怎么使用 RNObserverManager 这个蹦床呢？我们先定义协议，观察者实现协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 观察者需要实现的协议</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">MyProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-type">void</span>)doSomething;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 观察者</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">MyProtocol</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-comment">// 观测者实现协议方法</span><br>- (<span class="hljs-type">void</span>)doSomething&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;doSomething :%@&quot;</span>, <span class="hljs-keyword">self</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>接下来在 ViewController 里面使用这些内容</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-comment">// 使用 id 类型可以避免编译器警告</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> observerManager;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">// 创建消息观察者集合</span><br>    <span class="hljs-built_in">NSSet</span>  *observers = [<span class="hljs-built_in">NSSet</span> setWithObjects:[MyClass new],[MyClass new], <span class="hljs-literal">nil</span>];<br>    <span class="hljs-comment">// 创建 RNObserverManager 蹦床</span><br>    <span class="hljs-keyword">self</span>.observerManager = [[RNObserverManager alloc]<br>                            initWithProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">MyProtocol</span>) <span class="hljs-title">observers</span>:<span class="hljs-title">observers</span>];</span><br>    <span class="hljs-comment">// 给 RNObserverManager 发送 doSomething 消息，实际上都会被转发到 MyClass 的 doSomething 方法</span><br>    [<span class="hljs-keyword">self</span>.observerManager doSomething];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>查看控制台输出结果</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">doSomething <span class="hljs-symbol">:&lt;MyClass</span>: <span class="hljs-number">0x6080000157c0</span>&gt;<br>doSomething <span class="hljs-symbol">:&lt;MyClass</span>: <span class="hljs-number">0x6080000157f0</span>&gt;<br></code></pre></td></tr></table></figure><p>从结果上看，我们给 RNObserverManager 发送 doSomething 消息，实际上都会被转发到 MyClass 的 doSomething 方法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://book.douban.com/subject/25976913/">iOS 编程实战</a> 读书笔记</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C 消息转发流程</title>
    <link href="/2017/04/16/oc-fast-forwarding/"/>
    <url>/2017/04/16/oc-fast-forwarding/</url>
    
    <content type="html"><![CDATA[<h3 id="快速转发"><a href="#快速转发" class="headerlink" title="快速转发"></a>快速转发</h3><p>什么是快速转发呢？我们假设有这么一个对象 CacheProxy，若是有未知的选择器发送到 CacheProxy，objc_msgSend 都会调用 CacheProxy 的 forwardingTargetForSelector: 方法，如果这个方法返回一个对象，那么 objc_msgSend 会试着将这个未知的选择器发送给返回的那个对象这就是快速转发（fast forwarding）。那么我们可以利用这个快速转发的特性来代理对象。</p><p>我们使用 CacheProxy 这个对象来说明如何利用快速转发的特性来缓存其他对象的 setter 和 getter 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CacheProxy.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">// 快速转发 ：若是有未知的选择器发送到 CacheProxy，objc_msgSend 都会调用 CacheProxy 的 forwardingTargetForSelector: 方法，如果这个方法返回一个对象，那么 objc_msgSend 会试着将这个未知的选择器发送给返回的那个对象。</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CacheProxy</span> : <span class="hljs-title">NSProxy</span></span><br><span class="hljs-comment">// 初始化方法 ，返回类型为 id 类型，可以避免编译器报错</span><br>- (<span class="hljs-type">id</span>)initWithObject:(<span class="hljs-type">id</span>)anObject properties:(<span class="hljs-built_in">NSArray</span> *)properties;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>值的注意的是  CacheProxy 并不是 NSObject 的子类，而是 NSProxy 的子类，NSProxy 是一个轻量级的根类，是为那些转发大部分方法调用的类而设计的。CacheProxy 本身就是一个代理对象，适合成为 NSProxy 的子类。</p><span id="more"></span> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CacheProxy.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CacheProxy.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CacheProxy</span> ()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> object;<span class="hljs-comment">//被代理的对象</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *valueForProperty;<span class="hljs-comment">// 用于保存被代理对象的属性值</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CacheProxy</span></span><br><br><span class="hljs-comment">// setFoo: -&gt; foo</span><br><span class="hljs-comment">// 通过 selector 得到属性名</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *propertyNameForSelector(SEL selector)&#123;<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br><br><span class="hljs-comment">// foo -&gt; setFoo:</span><br><span class="hljs-comment">// 通过属性名得到 selector</span><br><span class="hljs-keyword">static</span> SEL setterForPropertyName(<span class="hljs-built_in">NSString</span> *property)&#123;<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br><br><span class="hljs-comment">// getter 方法实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">id</span> propertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL _cmd)&#123;<br>    <span class="hljs-built_in">NSString</span> *propertyName = <span class="hljs-built_in">NSStringFromSelector</span>(_cmd);<br>    <span class="hljs-type">id</span> value = [[<span class="hljs-keyword">self</span> valueForProperty] valueForKey:propertyName];<br>    <span class="hljs-comment">// NSMutableDictionary 不能存储 nil，所以使用 NSNull 来处理 nil</span><br>    <span class="hljs-keyword">if</span> (value == [<span class="hljs-built_in">NSNull</span> null]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (value) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 从缓存对象取不到属性值的话，那么从原对象取属性值</span><br>    value = [[<span class="hljs-keyword">self</span> object] valueForKey:propertyName];<br>    <span class="hljs-comment">// 从原对象取属性值之后，将属性值缓存到缓存对象</span><br>    [[<span class="hljs-keyword">self</span> valueForProperty] setValue:value forKey:propertyName];<br><br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-comment">// setter 方法实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> setPropertyIMP(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>, SEL _cmd, <span class="hljs-type">id</span> aValue)&#123;<br>    <span class="hljs-type">id</span> value = [aValue <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSString</span> *propertyName = propertyNameForSelector(_cmd);<br>    <span class="hljs-comment">// 先将属性值设置到缓存对象，再将属性值设置到原对象</span><br>    [[<span class="hljs-keyword">self</span> valueForProperty] setValue:(value != <span class="hljs-literal">nil</span> ? value : [<span class="hljs-built_in">NSNull</span> null]) forKey:propertyName];<br>    [[<span class="hljs-keyword">self</span> object] setValue:value forKey:propertyName];<br>&#125;<br><br><br>- (<span class="hljs-type">id</span>)initWithObject:(<span class="hljs-type">id</span>)anObject properties:(<span class="hljs-built_in">NSArray</span> *)properties&#123;<br>    _object = anObject;<br>    _valueForProperty = [<span class="hljs-built_in">NSMutableDictionary</span> new];<br>    <span class="hljs-comment">// 缓存对象为 anObject 的所有属性生成 setter 和 getter 方法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSString</span> *property <span class="hljs-keyword">in</span> properties)&#123;<br>        <span class="hljs-comment">// 添加 getter 方法</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], <span class="hljs-built_in">NSSelectorFromString</span>(property), (IMP)propertyIMP, <span class="hljs-string">&quot;@@:&quot;</span>);<br>        <span class="hljs-comment">// 添加 setter 方法</span><br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], setterForPropertyName(property), (IMP)setPropertyIMP, <span class="hljs-string">&quot;v@:@&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 覆写以下方法，CacheProxy 缓存对象对外可以被识别为 object 对象</span><br>- (<span class="hljs-built_in">NSString</span> *)description&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ (%@)&quot;</span>,[<span class="hljs-variable language_">super</span> description],<span class="hljs-keyword">self</span>.object];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isEqual:(<span class="hljs-type">id</span>)object&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isEqual:object];<br>&#125;<br><br>- (<span class="hljs-built_in">NSUInteger</span>)hash&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object hash];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object respondsToSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isKindOfClass:(Class)aClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isKindOfClass:aClass];<br>&#125;<br><br><br><span class="hljs-comment">// 如果有未知的选择器发送到 CacheProxy 缓存对象，在这里把所有的未知选择器都发送给代理对象。</span><br><span class="hljs-comment">// 快速转发</span><br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.object;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation setTarget:<span class="hljs-keyword">self</span>.object];<br>    [invocation invoke];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ol><li><p>方法 static NSString *propertyNameForSelector(SEL selector) 用于通过 selector 得到属性名。</p></li><li><p>方法 static SEL setterForPropertyName(NSString *property)用于通过属性名得到 selector。</p></li><li><p>方法 static id propertyIMP(id self, SEL _cmd) 是一个 getter 方法实现。由于 NSMutableDictionary 不能存储 nil，所以使用 NSNull 来处理 nil。从 CacheProxy 这个缓存对象对象取不到属性值的话，那么从被代理对象取属性值。 从被代理对象取属性值之后，将属性值缓存到缓存对象。</p></li><li><p>方法 static void setPropertyIMP(id self, SEL _cmd, id aValue) 是一个 setter 方法实现。 先将属性值设置到缓存对象，再将属性值设置到被代理对象。</p></li><li><p>forwardingTargetForSelector: 方法，如果有未知的选择器发送到 CacheProxy 缓存对象，在这里把所有的未知选择器都发送给被代理对象。</p></li><li><p>如果被代理的对象不响应 CacheProxy 发送过来的未知选择器，那么 objc_msgSend会调用 methodSignatureForSelector: 和 forwardInvocation: 进行普通转发。</p></li><li><p>初始化方法 initWithObject: properties: 做的工作是代理对象生成被代理对象的属性 setter 和 getter 方法。</p></li><li><p>由于 NSProxy 有一些方法的默认实现，有默认实现的方法则不会被转发到代理对象，所以需要覆写以下方法。</p></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSString</span> *)description&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ (%@)&quot;</span>,[<span class="hljs-variable language_">super</span> description],<span class="hljs-keyword">self</span>.object];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isEqual:(<span class="hljs-type">id</span>)object&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isEqual:object];<br>&#125;<br><br>- (<span class="hljs-built_in">NSUInteger</span>)hash&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object hash];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object respondsToSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isKindOfClass:(Class)aClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.object isKindOfClass:aClass];<br>&#125;```<br><br><br>创建完了 CacheProxy 这个代理对象，我们再创建一个 被代理对象 CachePerson<br>```objectivec<br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CachePerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">// 2个属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *firstName;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *lastName;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>接下来看看如何使用 CacheProxy 这个代理对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 说明 CacheProxy 如何缓存其他对象的 setter 和 getter 方法</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------------------------------------------&quot;</span>);<br><span class="hljs-type">id</span> cachePerson = [[CachePerson alloc] init];<br><span class="hljs-type">id</span> cacheProxy = [[CacheProxy alloc] initWithObject:cachePerson properties:@[<span class="hljs-string">@&quot;firstName&quot;</span>,<span class="hljs-string">@&quot;lastName&quot;</span>]];<br><span class="hljs-comment">// 设置 CacheProxy 对象的属性， cachePerson 这个被代理对象的属性也有值</span><br>[cacheProxy setFirstName:<span class="hljs-string">@&quot;CCCC&quot;</span>];<br>[cacheProxy setLastName:<span class="hljs-string">@&quot;DDDD&quot;</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CacheProxy : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cacheProxy firstName],[cacheProxy lastName]);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CachePerson : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cachePerson firstName],[cachePerson lastName]);<br><br><span class="hljs-comment">// 说明快速转发</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;------------------------------------------&quot;</span>);<br><span class="hljs-comment">// 只设置被代理对象 CachePerson 的属性，利用快速转发的特性 CacheProxy 也能拿到 CachePerson 的属性</span><br><span class="hljs-type">id</span> cachePerson2 = [[CachePerson alloc] init];<br>[cachePerson2 setFirstName:<span class="hljs-string">@&quot;EEEE&quot;</span>];<br>[cachePerson2 setLastName:<span class="hljs-string">@&quot;FFFF&quot;</span>];<br><br><span class="hljs-type">id</span> cacheProxy2 = [[CacheProxy alloc] initWithObject:cachePerson2 properties:@[<span class="hljs-string">@&quot;firstName&quot;</span>]];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CacheProxy2 : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cacheProxy2 firstName],[cacheProxy2 lastName]);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CachePerson2 : firstName--&gt;%@,  lastName---&gt;%@&quot;</span>,[cachePerson2 firstName],[cachePerson2 lastName]);<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> ------------------------------------------<br>CacheProxy : firstName--&gt;CCCC,  lastName---&gt;DDDD<br>CachePerson : firstName--&gt;CCCC,  lastName---&gt;DDDD<br> ------------------------------------------<br>CacheProxy2 : firstName--&gt;EEEE,  lastName---&gt;FFFF<br>CachePerson2 : firstName--&gt;EEEE,  lastName---&gt;FFFF<br></code></pre></td></tr></table></figure><p>从运行结果来看，第一个案例，我们设置了 CacheProxy 对象的属性 firstName 和 lastName， cachePerson 这个被代理对象的属性 firstName 和 lastName 也拿到了对应的值。第二个案例，我们只设置被代理对象 CachePerson 的属性 firstName 和 lastName 的值，但是利用快速转发的特性 CacheProxy 也能拿到 CachePerson 的属性 firstName 和 lastName 的值。</p><h3 id="普通转发"><a href="#普通转发" class="headerlink" title="普通转发"></a>普通转发</h3><p>在前面的快速转发失效之后，也就是经过 resolveInstanceMethod: 和 forwardingTargetForSelector： 方法之后还是无法找到未知选择器的响应对象，那么 Runtime 就会尝试最慢的转发方式 forwardInvocation: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation setTarget:<span class="hljs-keyword">self</span>.object];<br>    [invocation invoke];<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面代码所示，在 forwardInvocation: 方法会收到一个 NSInvocation 参数，这个 NSInvocation 类把目标，选择器，方法签名和方法参数封装在一起。我们可以在方法内部改变 NSInvocation 的目标然后再调用。</p><p>若是类有实现 forwardInvocation: 方法，那么也需要实现 methodSignatureForSelector: 方法， NSInvocation 类的方法签名就是来自于这个方法。</p><p>在 forwardInvocation：方法中，我们可以看到该方法没有任何返回值，但是 Runtime 会把 NSInvocation 的结果返回给最初的调用者。</p><h3 id="转发失败"><a href="#转发失败" class="headerlink" title="转发失败"></a>转发失败</h3><p>在整个消息转发过程都没有为未知选择器找到响应对象，那么接下来要怎么办？<br>由于 forwardInvocation：是消息转发过程的最后一环，若是它不处理这个未知选择器的话，那么就什么也不会发生，也可以利用这个特点来丢弃某些方法。但是 forwardInvocation: 的默认实现会有一些动作，它会调用 doesNotReconizeSelector：方法，该方法会抛出 NSInvalidArgumentException。</p><p>我们平常也可以使用 doesNotReconizeSelector：方法做一些自己的事情，比如某个类的 init 方法不允许调用，那么有如下实现方案。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">id</span>)init&#123;<br>    [<span class="hljs-keyword">self</span> doesNotReconizeSelector:_cmd];<br>&#125;<br></code></pre></td></tr></table></figure><p>要是有人调用 init 方法， Runtime 会报错。<br>其实要实现这个效果还可以这么做，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">id</span>)init&#123;<br>    <span class="hljs-built_in">NSAssert</span>(<span class="hljs-literal">NO</span>,<span class="hljs-string">&quot;不要直接调用 init 方法&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后值得注意的是，当有一个类无法响应未知的选择器的时候应该在 forwardInvocation：中调用 doesNotReconizeSelector: 。除非你非常清楚你想要做什么，不然不要直接返回，直接返回可能会导致一些非常蛋疼的 bug 。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>demo <a href="https://github.com/junbinchencn/DynamicWork">https://github.com/junbinchencn/DynamicWork</a></li><li><a href="https://book.douban.com/subject/25976913/">iOS编程实战</a> 读书笔记</li><li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW2">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW2</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Objective-C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iPad 分屏框架 - SPStackedNav 源码解读</title>
    <link href="/2017/03/26/reading-source-code-of-SPStackedNav/"/>
    <url>/2017/03/26/reading-source-code-of-SPStackedNav/</url>
    
    <content type="html"><![CDATA[<h1 id="SPStackedNav-解读"><a href="#SPStackedNav-解读" class="headerlink" title="SPStackedNav 解读"></a>SPStackedNav 解读</h1><p><a href="https://github.com/spotify/SPStackedNav">SPStackedNav</a> 是全球最大的流音乐服务商 Spotify 开源的一个 iPad 分屏框架，用于 Spotify 的 iPad 版 App 中，网易云音乐 iPad 版 App 也是采用相似的分屏交互方案，该框架的交互表现如下图所示：</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled.webp" class="" title="image"><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>根据 <a href="https://github.com/spotify/SPStackedNav">GitHub</a> 上面的说明完成项目导入之后，那么就可以开始搭建UI框架了。</p><ol><li><p>创建 SPSideTabController,  SPSideTabController 的用法和UITabController的用法没有什么大的区别。</p></li><li><p>分别创建 SPSideTabController 的 RootViewController，设置 UITabBarItem 属性。</p></li><li><p>给 SPSideTabController 的 viewControllers 属性赋值对应的 RootViewController 数组。</p></li><li><p>Demo 的 AppDelegate 代码如下：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>&#123;<br>    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];<br>    <span class="hljs-comment">// Override point for customization after application launch.</span><br>    self.window.backgroundColor = [UIColor whiteColor];<br><br>    <span class="hljs-comment">// 步骤 1 创建 SPSideTabController</span><br>    self.tabs = [[SPSideTabController alloc] init];<br>    <br>    <span class="hljs-comment">// 步骤 2 分别创建 SPSideTabController 的 RootViewController，设置 UITabBarItem 属性</span><br>    RootTestViewController *root1 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root1.title = @<span class="hljs-string">&quot;Root 1&quot;</span>;<br>    root1.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;114-balloon&quot;</span>];<br>    <br>    RootTestViewController *root2 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root2.title = @<span class="hljs-string">&quot;Root 2&quot;</span>;<br>    root2.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;185-printer&quot;</span>];<br>    root2.tabBarItem.badgeValue = @<span class="hljs-string">&quot;5&quot;</span>;<br>    root2.tabBarItem.badgeColor = [UIColor redColor];<br><br>    RootTestViewController *root3 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root3.title = @<span class="hljs-string">&quot;Root 3&quot;</span>;<br>    root3.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;114-balloon&quot;</span>];<br>    <br>    <span class="hljs-comment">// 步骤 3 给 SPSideTabController 的 viewControllers 属性赋值对应的 RootViewController 数组</span><br>    self.tabs.viewControllers = @[<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root1],<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root2],<br>        [[SPStackedNavigationController alloc] initWithRootViewController:root3]<br>    ];<br><br>    self.window.rootViewController = self.tabs;<br>    [self.window makeKeyAndVisible];<br>    <br>    <br>    <span class="hljs-keyword">return</span> YES;<br>&#125;```<br><br><br><span class="hljs-number">5.</span>效果图<br><br>&#123;% asset_img Untitled1.webp image %&#125;<br><br><br>&#123;% asset_img Untitled2.webp image %&#125;<br><br><br>### 设计<br><br>&#123;% asset_img Untitled3.webp image %&#125;<br><br>从图中的 View 层次结构图可以看到，左边的侧边栏 View 是一个  SPSideTabBar,该 SPSideTabBar 包含若干个 SPSideTabItemButton 。右边的容器 View 是一个 SPStackedNavigationScrollView ，该 SPStackedNavigationScrollView 里面包含了若干个 SPStackedPageContainer ， 一个 SPStackedPageContainer 可以简单的看做一个ViewController。<br><br>当我们在 Demo 项目中的 RootTestViewController 里面 push 一个 ViewController 的时候。其实就相当于往 SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 view。SPStackedPageContainer的显示内容来自于 ViewController 的 view 属性。<br><br>```CPP<br>    ChildTestViewController *vc = [ChildTestViewController <span class="hljs-keyword">new</span>];<br>    [self.stackedNavigationController pushViewController:vc animated:YES];<br></code></pre></td></tr></table></figure><h3 id="SPSideTabBar-和-SPSideTabItemButton-解析"><a href="#SPSideTabBar-和-SPSideTabItemButton-解析" class="headerlink" title="SPSideTabBar 和 SPSideTabItemButton 解析"></a>SPSideTabBar 和 SPSideTabItemButton 解析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP">RootTestViewController *root2 = [RootTestViewController <span class="hljs-keyword">new</span>];<br>    root2.title = @<span class="hljs-string">&quot;Root 2&quot;</span>;<br>    root2.tabBarItem.image = [UIImage imageNamed:@<span class="hljs-string">&quot;185-printer&quot;</span>];<br>    root2.tabBarItem.badgeValue = @<span class="hljs-string">&quot;5&quot;</span>;<br>    root2.tabBarItem.badgeColor = [UIColor redColor];<br></code></pre></td></tr></table></figure><p>Demo 代码里面的 AppDelegate 设置的明明是 UITabBarItem 的各类属性， 但是为什么在 SPSideTabBar 里面没有看到关于 UITabBarItem 的信息呢？</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled4.webp" class="" title="image"><p>再来看看 SPSideTabBar 这个 View 的层级结构图，可以猜出 SPSideTabBar 将 UITabBarItem 的属性设置映射成 SPSideTabItemButton 的属性设置了。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled5.webp" class="" title="image"><p>查看 SPSideTabController.m 文件的 viewDidLoad 方法，我们可以看到 _tabBar.items &#x3D; validItems 这个属性设置方法将 SPSideTabController 的 tabBarItem 的对象数组传给SPSideTabBar 的 items属性。</p><p>来到 SPSideTabBar.m 实现文件查看 - (void)setItems:(NSArray*)items 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//将 UITabBarItem 数组转成 SPSideTabItemButton 数组</span><br>- (<span class="hljs-type">void</span>)setItems:(NSArray*)items<br>&#123;<br>    <br>    <span class="hljs-keyword">if</span> ([items isEqual:_items]) <span class="hljs-keyword">return</span>;<br>    <br>    self.selectedItem = nil;<br>    <br>    _items = [items copy];<br>    <br>    <span class="hljs-keyword">for</span>(UIView *b in _itemButtons) [b removeFromSuperview];<br>    self.itemButtons = nil;<br><br>    <span class="hljs-keyword">if</span> (_items) &#123;<br>        NSMutableArray *itemButtons = [NSMutableArray array];<br>        CGRect pen = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>);<br>        <span class="hljs-keyword">for</span>(UITabBarItem *item in _items) &#123;<br>            <span class="hljs-comment">//关键步骤 将 UITabBarItem 转成 SPSideTabItemButton</span><br>            UIView *b = [self buttonForItem:item withFrame:pen];<br>            [itemButtons addObject:b];<br>            [self addSubview:b];<br>            pen.origin.y += pen.size.height + <span class="hljs-number">10</span>;<br>        &#125;<br>        self.itemButtons = itemButtons;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续跟踪查看方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">UIView *b = [self buttonForItem:item withFrame:pen];<br>```         <br><br>```CPP<br><span class="hljs-comment">// 设置 SPTabBarItem 的 frame，并返回 SPTabBarItem 的 View</span><br>- (UIView*)buttonForItem:(UITabBarItem*)item withFrame:(CGRect)pen<br>&#123;<br>    <span class="hljs-keyword">if</span> ([item isKindOfClass:[SPTabBarItem <span class="hljs-keyword">class</span>]] &amp;&amp; [(SPTabBarItem*)item view]) &#123;<br>        UIView *view = [(SPTabBarItem*)item view];<br>        [view setFrame:pen];<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>    <br>    SPSideTabItemButton *b = [[SPSideTabItemButton alloc] initWithFrame:pen];<br>    <br>     <span class="hljs-comment">// 省略 UITabBarItem 的属性转成 SPSideTabItemButton 的属性过程，</span><br>     <span class="hljs-comment">// 具体细节可以详看源码</span><br>    <br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 SPSideTabBar 自定义 View 来替代系统的 UITabBar, 使用 SPTabBarItem 自定义 View 来替代系统的 UITabBarItem，SPSideTabBar 将 UITabBarItem 的属性设置映射到 SPTabBarItem。这个就是常见的自定义 TabBar  的思路。</p><h3 id="SPStackedNavigationController-解析"><a href="#SPStackedNavigationController-解析" class="headerlink" title="SPStackedNavigationController 解析"></a>SPStackedNavigationController 解析</h3><p>SPStackedNavigationController 继承与 UIViewController，并定义和实现了一系列和 NavigationController 相关的方法,简而言之就是自己实现一个 NavigationController，这里做重讲解2个主要的方法.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate<br><br>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;<br></code></pre></td></tr></table></figure><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled6.webp" class="" title="image"><p>当 SPStackedNavigationController 做 push 操作的时候，就是往 SPStackedNavigationScrollView 这个仿 ScrollView 的 View 添加一个 SPStackedPageContainer 子View。从上图中的左边的 View 层次结构中可以看到SPStackedNavigationScrollView 里面有2个 SPStackedPageContainer 子 View。而上图中右边的 View 表现正好印证了这个结构。</p><p>查看 SPStackedNavigationController.m 文件的 - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate 实现方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushViewController:(UIViewController *)viewController animated:(BOOL)animated activate:(BOOL)activate<br>&#123;<br>    <span class="hljs-comment">// 省略代码</span><br>    <span class="hljs-comment">// 添加 viewController 到 viewControllers 的数组</span><br>    [self willChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    [self addChildViewController:viewController];<br>    <br>    <span class="hljs-comment">//将 viewController 添加到 self,</span><br>    <span class="hljs-keyword">if</span> ([self isViewLoaded])<br>    <span class="hljs-comment">// 关键步骤 SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 View</span><br>        [self pushPageContainerWithViewController:viewController];<br>    <br>    <span class="hljs-keyword">if</span> (activate)<br>        [self setActiveViewController:viewController position:activePosition animated:animated];<br>    <span class="hljs-comment">// 调用 viewController 生命周期方法</span><br>    [viewController didMoveToParentViewController:self];<br>    [self didChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看看  SPStackedNavigationController.m 文件  - (void)pushPageContainerWithViewController:(UIViewController*)viewController 的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)pushPageContainerWithViewController:(UIViewController*)viewController<br>&#123;<br>    CGSize size = self.view.frame.size;<br>    CGRect frame = <span class="hljs-built_in">CGRectMake</span>(self.view.bounds.size.width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size.height);<br>    frame.size.width = (viewController.stackedNavigationPageSize == kStackedPageHalfSize ?<br>                        kSPStackedNavigationHalfPageWidth :<br>                        size.width);<br>    <br>    SPStackedPageContainer *pageC = [[SPStackedPageContainer alloc] initWithFrame:frame VC:viewController];<br>    <span class="hljs-comment">//SPStackedNavigationScrollView 添加一个 SPStackedPageContainer 子 View</span><br>    [_scroll addSubview:pageC];<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以验证我们上文所述，当 SPStackedNavigationController 做 push 操作的时候，就是往 SPStackedNavigationScrollView 这个 View 添加一个 SPStackedPageContainer 子 View。</p><p>我们现在是否可以这样猜测，当 SPStackedNavigationController 做 pop 操作的时候，就是在 SPStackedNavigationScrollView 这个View 移除一个 SPStackedPageContainer View。</p><p>接下来查看 SPStackedNavigationController.m 文件的  - (UIViewController *)popViewControllerAnimated:(BOOL)animated 方法来验证一下我们的猜测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (UIViewController *)popViewControllerAnimated:(BOOL)animated<br>&#123;<br>    UIViewController *viewController = [[self childViewControllers] lastObject];<br>    <span class="hljs-keyword">if</span> (!viewController)<br>        <span class="hljs-keyword">return</span> nil;<br>    <br>    [self willChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    [viewController willMoveToParentViewController:nil];<br>    <br>    <span class="hljs-keyword">if</span> ([self isViewLoaded])<br>    &#123;<br>        <span class="hljs-comment">// 关键步骤 ，将 SPStackedPageContainer 标记为移除状态，后续 SPStackedNavigationScrollView 会将它移除</span><br>        SPStackedPageContainer *pageC = [_scroll containerForViewController:viewController];<br>        pageC.markedForSuperviewRemoval = YES;<br>    &#125;<br>    <br>    <span class="hljs-comment">//关键步骤，移除 viewController</span><br>    [viewController removeFromParentViewController];<br>    [self didChangeValueForKey:@<span class="hljs-string">&quot;viewControllers&quot;</span>];<br>    <br>    [self setActiveViewController:[self.childViewControllers lastObject]<br>                         position:SPStackedNavigationPagePositionRight<br>                         animated:animated];<br>    <br>    <span class="hljs-keyword">return</span> viewController;<br>&#125;<br></code></pre></td></tr></table></figure><p>如我们猜测 SPStackedNavigationController 做 pop 操作的时候，就是在 SPStackedNavigationScrollView 这个View 移除一个 SPStackedPageContainer View。并让  SPStackedPageContainer 对应的 ViewController 发一个  removeFromParentViewController 的消息。</p><h3 id="SPStackedPageContainer-解析"><a href="#SPStackedPageContainer-解析" class="headerlink" title="SPStackedPageContainer 解析"></a>SPStackedPageContainer 解析</h3><p>SPStackedPageContainer 的作用是承载 ViewController 的 View，并对一些手势动作进行处理，在这里 SPStackedPageContainer 这个概念在这里等同于一个分屏 View。<br>打开 SPStackedPageContainer.m 查看 - (void)setVCVisible:(BOOL)VCVisible 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//将VC的View加到Container里面</span><br>- (<span class="hljs-type">void</span>)setVCVisible:(BOOL)VCVisible<br>&#123;<br>    <span class="hljs-keyword">if</span> (VCVisible == self.VCVisible) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-keyword">if</span> (VCVisible) &#123;<br>        [self.screenshot removeFromSuperview];<br>        self.screenshot = nil;<br>        <span class="hljs-keyword">if</span> (!self.markedForSuperviewRemoval || [_vc isViewLoaded])<br>        &#123;<br>            _vcContainer.backgroundColor = _vc.view.backgroundColor;<br>            _vc.view.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.bounds.size.width, self.bounds.size.height);<br>            <span class="hljs-keyword">if</span> (!_vc.view.superview)<br>                <span class="hljs-comment">// 关键步骤 添加 View</span><br>                [_vcContainer insertSubview:_vc.view atIndex:<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([_vc isViewLoaded])<br>            <span class="hljs-comment">// 关键步骤 移除 View</span><br>            [_vc.view removeFromSuperview];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SPStackedNavigationScrollView-解析"><a href="#SPStackedNavigationScrollView-解析" class="headerlink" title="SPStackedNavigationScrollView 解析"></a>SPStackedNavigationScrollView 解析</h3><p>SPStackedNavigationScrollView 是一个模仿 UIScrollView 实现的 View。关于 UIScrollView 的深入理解，推荐 ObjC 中国的文章 <a href="https://www.objccn.io/issue-3-2/">理解 Scroll Views</a>， 这里就不再详述，默认大家都是能理解 UIScrollView 的相关概念。</p><p>当使用 SPStackedNavigationController 做3次 Push 操作的时候， SPStackedNavigationScrollView 的 View 层次结构是这样的。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled7.webp" class="" title="image"><p>SPStackedNavigationController 的 rootView 就是 Container0 这个 View。而 Push 的 View 分别是 Container1，Container2,Container3。左边的半屏 View 的位置从底往上分别是 Container1 –&gt; Container2。右边的半屏 View 则是 Container3。若是 SPStackedNavigationController 再 Push 一个 View 的话，那么 左边的半屏 View 的位置从底往上分别是 Container1 –&gt; Container2 –&gt; Container3 。右边的半屏 View 则是 Container4，<strong>Container 这个概念在这里等同于一个分屏 View</strong>。 在这个时候 SPStackedNavigationScrollView 的View 的简单示意图如下</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled8.webp" class="" title="image"><p>从上面的 View 结构示意图中可以看出，SPStackedNavigationScrollView 对 UIScrollView 的模仿主要体现在 UIScrollView 的滑动机制上。<br>当 SPStackedNavigationController 做 push 操作的时候，SPStackedNavigationScrollView 右边半屏的 View 会从右向左滑动到左边半屏的位置，而右边半屏则从右向左显示一个新的 push 进来的 View。<br> 当 SPStackedNavigationController 做 pop 操作的时候，SPStackedNavigationScrollView 右边半屏的 View 会从左向右滑动出屏幕显示范围，而左边半屏的 View 则会从左向右滑动到右边半屏。</p><img src="/2017/03/26/reading-source-code-of-SPStackedNav/Untitled9.webp" class="" title="image"><p>讲完了 SPStackedNavigationScrollView 的大概表现之后，若是大家还是不怎么了解的话，可以运行 Demo 详细体会SPStackedNavigationScrollView 的UI变化。<br>我们接下来查看 SPStackedNavigationScrollView.h 文件，寻找和 UIScrollView 相关的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP">@interface SPStackedNavigationScrollView : UIView<br> <span class="hljs-comment">// ...... 省略代码</span><br>@<span class="hljs-built_in">property</span>(nonatomic) CGPoint contentOffset;<br>- (<span class="hljs-type">void</span>)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;<br>- (NSRange)scrollRange;<br><span class="hljs-comment">// ...... 省略代码</span><br>@end<br></code></pre></td></tr></table></figure><p>从 SPStackedNavigationScrollView 的头文件中，我们可以看到  SPStackedNavigationScrollView 继承于 UIView。和 UIScrollView 相关的概念有 contentOffset 和 scrollRange。关于 UIScrollView 的深入理解，推荐 查看 ObjC 中国的文章 <a href="https://www.objccn.io/issue-3-2/">理解 Scroll Views</a> ，这里就不再详述，默认大家都是能理解 UIScrollView 的相关概念。</p><p>接下来开始讲解 SPStackedNavigationScrollView 的具体实现。<br>看下面的图，当屏幕上只有 rootView 没有分屏的 View 的时候 SPStackedNavigationScrollView 的 frame 的坐标原点是在 rootView 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; 0。</p><p>接着看图，当屏幕上出现一个分屏的 View 的时候，我们叫这个 View 为 Container1。 SPStackedNavigationScrollView 的 frame 的坐标原点是在 Container1 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; rootView.width &#x2F; 2。</p><p>接着看图，当屏幕上出现二个分屏的 View 的时候，我们分别叫这二个 View 为 Container1 和 Container2。 SPStackedNavigationScrollView 的 frame 的坐标原点是在 Container1 的左上角，这个时候SPStackedNavigationScrollView 的 contentOffset &#x3D; rootView.width。</p><p>从上面的示意图中不难看出理解 SPStackedNavigationScrollView 的重点在于理解 SPStackedNavigationScrollView 不断变化的 frame 原点 和 contentOffset。只要 contentOffset 发生了变化，那么 SPStackedNavigationScrollView 就会发生滚动。</p><p>查看 SPStackedNavigationScrollView.m 文件，看到了2个和contentOffset相关的变量 _actualOffset 和 _targetOffset，接下来跟踪这2个变量的变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP">@implementation SPStackedNavigationScrollView &#123;<br>    CGPoint _actualOffset; <span class="hljs-comment">//模拟 ScrollView 当前的 contentOffset</span><br>    CGPoint _targetOffset;<span class="hljs-comment">// 模拟 ScrollView 将要滚动到的 contentOffset</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查看 SPStackedNavigationScrollView 的 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated 方法,作用是赋值 _targetOffset 和 _actualOffset 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 模仿 UIScrollView 滚动到指定位置</span><br>- (<span class="hljs-type">void</span>)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated<br>&#123;<br>    <span class="hljs-comment">//  给 _targetOffset 赋值</span><br>    _targetOffset = contentOffset;<br>    <span class="hljs-keyword">if</span> (animated)<br>        [self animateToTargetScrollOffset];<br>    <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//  给 _actualOffset 赋值</span><br>        _actualOffset = _targetOffset;<br>        <span class="hljs-keyword">if</span> (_onScrollDone)<br>        &#123;<br>            self.<span class="hljs-built_in">onScrollDone</span>();<br>            self.onScrollDone = nil;<br>        &#125;<br>       <span class="hljs-comment">// 关键步骤</span><br>        [self setNeedsLayout];<br>    &#125;                                                                                                                         <br>&#125;<br></code></pre></td></tr></table></figure><p>UIView 在调用 setNeedsLayout 方法之后，会调用 layoutSubviews 方法。接下看查看该方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)layoutSubviews<br>&#123;<br>    <span class="hljs-comment">// pen 的作用是stretch scroll at start and end</span><br>    <span class="hljs-comment">// 用于在第一屏从左向右拉扯和最后一屏从右向左拉扯，</span><br>    <span class="hljs-comment">// 让手势拖动的距离2倍于View移动的距离。</span><br>    <span class="hljs-comment">// _actualOffset 改变之后，通过特定的规则计算 pen 的 frame,然后将 frame 赋值给 View ，</span><br>    <span class="hljs-comment">// 总之作用就是调整 View 的 frame 位置</span><br>    <span class="hljs-comment">// 可以说 pen 就是对应的每个分屏的 frame</span><br>    CGRect pen = CGRectZero;<br><br>    <span class="hljs-comment">// 为什么需要 -  _actualOffset.x ？</span><br>    <span class="hljs-comment">// 为了得到每个分屏 View 的坐标的 X 值 （坐标原点是 SPStackedNavigationScrollView 的坐标原点，即在屏幕范围内的最左边的分屏 View 的左上角位置）</span><br>    <span class="hljs-comment">// 详见 ContentOffset 的计算方法</span><br>    pen.origin.x = -_actualOffset.x;<br>    <br>    <span class="hljs-comment">// stretch scroll at start and end</span><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 第一页从左向右拉扯 _actualOffset.x &lt; 0 才成立，</span><br>        <span class="hljs-comment">// _actualOffset 就是当前模仿的 UIScrollView 的 contentOffset</span><br>        <span class="hljs-comment">// 手势拖动的距离2倍于 View 移动的距离</span><br>        pen.origin.x = -_actualOffset.x/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    CGFloat maxScroll = [self scrollOffsetForAligningPageWithRightEdge:self.subviews.lastObject];<br>    <span class="hljs-keyword">if</span> (_actualOffset.x &gt; maxScroll)&#123;<br>            pen.origin.x = -(maxScroll + (_actualOffset.x-maxScroll)/<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// markedForSuperviewRemovalOffset 标记 pageC 自己的 offset 坐标</span><br>    <span class="hljs-comment">// 用来给 superview 把 pageC 从当前位置移动到 markedForSuperviewRemovalOffset 指定的坐标</span><br>    <span class="hljs-comment">// 可以让自己的 View 对边缘层叠效果做出对应的位置</span><br>    <span class="hljs-comment">// 也可以让 pageC 自己全屏或者半屏,</span><br>    CGFloat markedForSuperviewRemovalOffset = pen.origin.x;<span class="hljs-comment">// View 的坐标位置x</span><br>    NSMutableArray *stackedViews = [NSMutableArray array];<br>    <br>    <span class="hljs-keyword">for</span>(SPStackedPageContainer *pageC in self.subviews) &#123;<br>        pen.size = pageC.bounds.size;<br>        pen.size.height = self.frame.size.height;<br>        <span class="hljs-keyword">if</span> (pageC.vc.stackedNavigationPageSize == kStackedPageFullSize)<br>            pen.size.width = self.frame.size.width;<br>        <br>        CGRect actualPen = pen;<br>        <span class="hljs-keyword">if</span> (pageC.markedForSuperviewRemoval)<br>            actualPen.origin.x = markedForSuperviewRemovalOffset;<br>        <span class="hljs-comment">// Stack on the left</span><br>        <span class="hljs-comment">// 小于 （0，1，2，3）*3</span><br>        <span class="hljs-comment">// 左边是一个 stackedViews，最多有3层边缘层叠效果</span><br>        <span class="hljs-keyword">if</span> (actualPen.origin.x &lt; (<span class="hljs-built_in">MIN</span>(i, <span class="hljs-number">3</span>))*<span class="hljs-number">3</span>)&#123;<br>           <span class="hljs-comment">// 如果actualPen.origin.x 小于 (MIN(i, 3))*3 那么说明该 pageC 的位置不是在 stackedViews 最顶部的三个以内</span><br>           [stackedViews addObject:pageC];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>           pageC.hidden = NO;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (self.scrollAnimationTimer == nil)<br>            <span class="hljs-comment">// floorf取整操作</span><br>            actualPen.origin.x = <span class="hljs-built_in">floorf</span>(actualPen.origin.x);<br>        <span class="hljs-comment">// 改变pageC.frame，那么pageC就会动了</span><br>        pageC.frame = actualPen;<br>   <br>        markedForSuperviewRemovalOffset += pen.size.width;<br>        <span class="hljs-comment">// NavVC 做 POP 操作的时候会将 markedForSuperviewRemoval 置为 YES</span><br>        <span class="hljs-comment">// 前面 pen.origin.x = -_actualOffset.x;</span><br>        <span class="hljs-comment">// 这里计算下一个屏幕的位置 frame 的 x 值</span><br>        <span class="hljs-comment">// 所以需要加上 pen.size.width</span><br>        <span class="hljs-keyword">if</span> (!pageC.markedForSuperviewRemoval)<br>            pen.origin.x += pen.size.width;<br>        <br>        <span class="hljs-comment">// 覆盖不透明度</span><br>        <span class="hljs-keyword">if</span> (actualPen.origin.x &lt;= <span class="hljs-number">0</span> &amp;&amp; pageC != [self.subviews lastObject]) &#123;<br>            <span class="hljs-comment">// abs()绝对值函数</span><br>            pageC.overlayOpacity = <span class="hljs-number">0.3</span>/actualPen.size.width*<span class="hljs-built_in">abs</span>(actualPen.origin.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pageC.overlayOpacity = <span class="hljs-number">0.0</span>;<br>        &#125;<br><br>        i++;<br>    &#125;<br>    <br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (NSInteger index = <span class="hljs-number">0</span>; index &lt; [stackedViews count]; index++)<br>    &#123;<br>        SPStackedPageContainer *pageC = stackedViews[index];<br>        <span class="hljs-comment">// stackedViews 包括 RootVC 的 View;</span><br>        <span class="hljs-comment">// stackedViews 里面的最后3个 View 显示</span><br>        <span class="hljs-keyword">if</span> ([stackedViews count] &gt; <span class="hljs-number">3</span> &amp;&amp; index &lt; ([stackedViews count]<span class="hljs-number">-3</span>))<br>            pageC.hidden = YES;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 左边是一个 stackedViews，最多有3层边缘层叠效果</span><br>            pageC.hidden = NO;<br>            CGRect frame = pageC.frame;<br>            <span class="hljs-comment">// 调整坐标，显示层叠效果</span><br>            frame.origin.x = <span class="hljs-number">0</span> + <span class="hljs-built_in">MIN</span>(i, <span class="hljs-number">3</span>)*<span class="hljs-number">3</span>;<br>            pageC.frame = frame;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Only make sure we show what we need to, don&#x27;t unload stuff until we&#x27;re done animating</span><br>    [self updateContainerVisibilityByShowing:YES byHiding:NO];<br>&#125;<br></code></pre></td></tr></table></figure><p>在 layoutSubviews 方法里面 根据 _actualOffset 计算好每个分屏的 frame ，以及哪些分屏是可以显示在屏幕上的，哪些分屏是需要移除的，哪些分屏的位置是在屏幕显示的分屏的左边，哪些分屏的位置是在屏幕显示的分屏的右边。</p><p>在layoutSubviews 方法里面调用了一个方法用于控制分屏 View 的显示与隐藏，在这里分屏 View的概念可以等同于SPStackedPageContainer。这个方法是 - (void)updateContainerVisibilityByShowing:(BOOL)doShow byHiding:(BOOL)doHide 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (<span class="hljs-type">void</span>)updateContainerVisibilityByShowing:(BOOL)doShow byHiding:(BOOL)doHide<br>&#123;<br>    <span class="hljs-comment">// fabsf 浮点数的绝对值</span><br>    <span class="hljs-comment">// 分屏 View 是否需要弹跳效果</span><br>    BOOL bouncing = self.scrollAnimationTimer &amp;&amp; <span class="hljs-built_in">fabsf</span>(_targetOffset.x - _actualOffset.x) &lt; <span class="hljs-number">30</span>;<br>    <br>    <span class="hljs-comment">// layoutSubViews的 pen 是一个 frame、</span><br>    <span class="hljs-comment">// 这里的 pen 是一个 frame 的 x 坐标</span><br>    <span class="hljs-comment">// 但是用法和 layoutSubViews 的 pen 没什么区别</span><br>    CGFloat pen = -_actualOffset.x;<br>    <br>    <span class="hljs-comment">// stretch scroll at start and end</span><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &lt; <span class="hljs-number">0</span>)<br>        pen = -_actualOffset.x/<span class="hljs-number">2</span>;<br>    <br>    CGFloat maxScroll = [self scrollOffsetForAligningPageWithRightEdge:self.subviews.lastObject];<br><br>    <span class="hljs-keyword">if</span> (_actualOffset.x &gt; maxScroll)<br>        pen = -(maxScroll + (_actualOffset.x-maxScroll)/<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 用来让 SuperView 移动 pageC 的 x 坐标，原点是屏幕显示的最左边的分屏的 X 坐标</span><br>    CGFloat markedForSuperviewRemovalOffset = pen;<br>    <br>    NSMutableArray *viewsToDelete = [NSMutableArray array];<br>    <span class="hljs-keyword">for</span>(SPStackedPageContainer *pageC in self.subviews) &#123;<br>        CGFloat currentPen = pen;<br>        <span class="hljs-comment">// 该 pageC 被做了 POP 操作，需要被 SuperView移除</span><br>        <span class="hljs-keyword">if</span> (pageC.markedForSuperviewRemoval)<br>            currentPen = markedForSuperviewRemovalOffset;<br>        <span class="hljs-comment">// 该分屏是否是在屏幕可见的分屏的右边同时无法看见该分屏</span><br>        BOOL isOffScreenToTheRight = currentPen &gt;= self.bounds.size.width;<br><br>        NSRange scrollRange = [self scrollRangeForPageContainer:pageC];<br>        <span class="hljs-comment">// View 是否被其他 View 覆盖了</span><br>        BOOL isCovered = currentPen + scrollRange.length &lt;= <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// View 现在是否可见</span><br>        BOOL isVisible = !isOffScreenToTheRight &amp;&amp; !isCovered;<br>        <br><br>        <span class="hljs-comment">// pageC 的可见性发生变化 &amp;&amp; （ (isVisible == NO  &amp;&amp; doHide == Yes)  ||  isVisible == Yes &amp;&amp; doShow ==Yes）</span><br>        <span class="hljs-comment">// 只要 pageC 的可见性发生变化，不管是隐藏还是显示都执行下面的if条件分支</span><br>        <span class="hljs-keyword">if</span> (pageC.VCVisible != isVisible &amp;&amp; ((!isVisible &amp;&amp; doHide) || (isVisible &amp;&amp; doShow)))<br>        &#123;<br>            <br>            <span class="hljs-comment">// pageC分屏将出现</span><br>            <span class="hljs-comment">// pageC分屏将离开屏幕</span><br>            <span class="hljs-comment">//(isVisible == No || bouncing == No || (isVisible ==Yes &amp;&amp; needsInitialPresentation == Yes))</span><br>            <span class="hljs-keyword">if</span> (!isVisible || !bouncing || (isVisible &amp;&amp; pageC.needsInitialPresentation)) &#123;<br>                pageC.needsInitialPresentation = NO;<br>                pageC.VCVisible = isVisible;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 要隐藏 pageC 并且该 pageC 被标记为销毁的</span><br>        <span class="hljs-comment">//(doHide ==Yes &amp;&amp; pageC.markedForSuperviewRemoval ==Yes)</span><br>        <span class="hljs-comment">// 将 pageC 加入销毁数组 viewsToDelete</span><br>        <span class="hljs-keyword">if</span> (doHide &amp;&amp; pageC.markedForSuperviewRemoval)<br>            [viewsToDelete addObject:pageC];<br>        <br>        <span class="hljs-comment">//经过 Demo 验证 pen 和 markedForSuperviewRemovalOffset 的值一样</span><br>        markedForSuperviewRemovalOffset += pageC.frame.size.width;<br>        <br>        <span class="hljs-comment">// markedForSuperviewRemoval = No</span><br>        <span class="hljs-comment">// 计算 pen 的值，该值为下一个分屏的 X 坐标</span><br>        <span class="hljs-keyword">if</span> (!pageC.markedForSuperviewRemoval)<br>            pen += pageC.frame.size.width;<br>    &#125;<br>    <span class="hljs-comment">// 对viewsToDelete数组里面的View执行销毁操作</span><br>    [viewsToDelete makeObjectsPerformSelector:@<span class="hljs-built_in">selector</span>(removeFromSuperview)];<br>&#125;<br></code></pre></td></tr></table></figure><p>限于篇幅关系无法一一介绍SPStackedNavigationScrollView 的各种实现。<br>未介绍的细节知识点包括但不限于 NSRunLoop，用于 SPStackedNavigationScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。SPStackedNavigationScrollView 的 scrollRange 的计算细节，SPStackedNavigationScrollView 的手势处理等等，大家若是有兴趣可以在我的 <a href="https://github.com/junbinchencn/SPStackedNav-Note">GitHub</a> 上下载对应注释版本源码,地址 <a href="https://github.com/junbinchencn/SPStackedNav-Note">https://github.com/junbinchencn/SPStackedNav-Note</a> 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SPStackedNav 项目是一个用于 iPad 分屏的 UI 解决方案。该方案的核心在于 SPStackedNavigationScrollView 这个类。SPStackedNavigationScrollView 模仿了 UIScrollView 的实现。SPStackedNav 的分屏方案的设计非常精巧，实现思路清晰明确，实现过程中的很多细节还是非常具有参考和学习价值的，一些 contentOffset 的计算方法还是非常巧妙的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>理解 Scroll Views <a href="https://www.objccn.io/issue-3-2/">https://www.objccn.io/issue-3-2/</a><br>SPStackedNav <a href="https://github.com/spotify/SPStackedNav">https://github.com/spotify/SPStackedNav</a><br>SPStackedNav-Note <a href="https://github.com/junbinchencn/SPStackedNav-Note">https://github.com/junbinchencn/SPStackedNav-Note</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 模型框架- Mantle 解读</title>
    <link href="/2016/11/04/reading-source-code-of-Mantle/"/>
    <url>/2016/11/04/reading-source-code-of-Mantle/</url>
    
    <content type="html"><![CDATA[<h1 id="Mantle-解读"><a href="#Mantle-解读" class="headerlink" title="Mantle 解读"></a>Mantle 解读</h1><p><a href="https://github.com/Mantle/Mantle/">Mantle</a> 是由 Github 开发一款模型框架，Mantle 的主要作用在于让开发者更简单的构建应用的 model 层。本文主要介绍 Mantle 中最常使用的 JSON 功能–字典转模型。</p><h3 id="Mantle-的使用"><a href="#Mantle-的使用" class="headerlink" title="Mantle 的使用"></a>Mantle 的使用</h3><p>先以知乎的一个 <a href="http://news-at.zhihu.com/api/4/news/latest">API</a> 为例，讲解如何使用 Mantle 为这个 API 构建 model 。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled.webp" class="" title="API的数据结构"><p>1.按照 Mantle 要求构建对应的 model，Mantle 要求所有的 Model 都要继承于 MTLModel 并实现 MTLJSONSerializing 协议</p><p>构建 ZhihuLatestNews model 对应返回的 JSONKeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled1.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled2.webp" class="" title="image"><p>构建 ZhihuStory model 对应 sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled3.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled4.webp" class="" title="image"><p>构建 ZhihuStory model 对应 top_sotries 的JSONkeyPath</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled5.webp" class="" title="image"><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled6.webp" class="" title="image"><p>2.将网络请求的结果使用 Manlte 转化成 model</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled7.webp" class="" title="image"><h3 id="Mantle的接口"><a href="#Mantle的接口" class="headerlink" title="Mantle的接口"></a>Mantle的接口</h3><p>Mantle 通过 MTLJSONAdapter 实现 字典和 model 之间的转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">ZhihuLatestNews *lateNews = [MTLJSONAdapter modelOfClass:ZhihuLatestNews.<span class="hljs-keyword">class</span> fromJSONDictionary:dict error:&amp;merror];<br></code></pre></td></tr></table></figure><h3 id="Mantle的核心操作步骤"><a href="#Mantle的核心操作步骤" class="headerlink" title="Mantle的核心操作步骤"></a>Mantle的核心操作步骤</h3><p>1.获取 model 的属性–&gt; JSONKeyPath 映射字典<br>2.获取 model 的属性列表<br>3.根据 model 的方法给网络请求中返回的 JSON 字典中的 value 做值类型转化操作<br>4.使用 KVC 把值赋给 model 的属性，完成操作</p><h3 id="Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程"><a href="#Mantle-的-JSON字典–-gt-model-方法调用层级-Mantle-源码解读过程中主要是参考这个调用过程" class="headerlink" title="Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程"></a>Mantle 的 JSON字典–&gt; model 方法调用层级,Mantle 源码解读过程中主要是参考这个调用过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>| +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<span class="hljs-comment">// Mantle 调用入口</span><br>|   [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; initWithModelClass:]<span class="hljs-comment">// 创建 MTLJSONAdapter </span><br>|     +[ZhihuLatestNews JSONKeyPathsByPropertyKey]<span class="hljs-comment">// 获取 属性-&gt; JSONKeyPath 映射字典</span><br>|     +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|       +[ZhihuLatestNews enumeratePropertiesUsingBlock:]<br>|         +[ZhihuLatestNews storageBehaviorForPropertyWithKey:] <span class="hljs-comment">// 判断 model 的属性是否 Mantle 要求</span><br><br>| From: -[MTLJSONAdapter initWithModelClass:]<br>| +[MTLJSONAdapter valueTransformersForModelClass:] <span class="hljs-comment">//值转化</span><br>|   +[ZhihuLatestNews propertyKeys]<br>|   +[MTLJSONAdapter transformerForModelPropertiesOfClass:]<br><br>| From: +[MTLJSONAdapter modelOfClass:fromJSONDictionary:error:]<br>| [&lt;MTLJSONAdapter <span class="hljs-number">0x7fe68bd64340</span>&gt; modelFromJSONDictionary:error:] <br>|   +[ZhihuLatestNews propertyKeys] <span class="hljs-comment">// 获取 model 的所有 Mantle 可用属性</span><br>|   +[ZhihuLatestNews modelWithDictionary:error:] <span class="hljs-comment">//生成 model 对象</span><br>|     [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; initWithDictionary:error:]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; init]<br>|       [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; setDate:]<br>|   [&lt;ZhihuLatestNews <span class="hljs-number">0x7fe68bf2dea0</span>&gt; validate:]<br>|     +[ZhihuLatestNews propertyKeys]<br><br></code></pre></td></tr></table></figure><h3 id="Mantle的源码解读"><a href="#Mantle的源码解读" class="headerlink" title="Mantle的源码解读"></a>Mantle的源码解读</h3><p>1.初始化 MTLJSONAdapter</p><p>MTLJSONAdapter 是 字典和 model 之间的适配器，将 JSON 字典 转成应用的 model 对象</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled8.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (id)modelOfClass:(Class)modelClass fromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>     <span class="hljs-comment">//初始化MTLJSONAdapter</span><br>MTLJSONAdapter *adapter = [[self alloc] initWithModelClass:modelClass];<br><br><span class="hljs-keyword">return</span> [adapter modelFromJSONDictionary:JSONDictionary error:error];<br>&#125;<br></code></pre></td></tr></table></figure><p>2.initWithModelClass:(Class)modelClass 的作用是使用给定的 modelClass 初始化 MTLJSONAdapter</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled9.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)initWithModelClass:(Class)modelClass &#123;<br>  <br>    <span class="hljs-comment">//对modelClass进行判空操作</span><br><span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-comment">//是否实现MTLJSONSerializing协议的判断，对是否继承了MTLModel进行确认</span><br><span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br><br>self = [super init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br><br>    <span class="hljs-comment">//使用变量保存modelClass，以便后续使用</span><br>     _modelClass = modelClass;<br><br>    <span class="hljs-comment">//获取属性值和JSONKeyPaths的映射字典，并使用_JSONKeyPathsByPropertyKey保存</span><br>    <span class="hljs-comment">//JSONKeyPathsByPropertyKey 是 MTLJSONSerializing 协议中定义的一个方法，在MTLModel的子类中实现</span><br>_JSONKeyPathsByPropertyKey = [modelClass JSONKeyPathsByPropertyKey];<br><br>   <span class="hljs-comment">//获取 model 的属性，保存在propertyKeys变量中</span><br>   <span class="hljs-comment">//  **该方法后文有详细的实现解读**</span><br>NSSet *propertyKeys = [self.modelClass propertyKeys];<br><br>     <span class="hljs-comment">//判断 _JSONKeyPathsByPropertyKey 是否包含在 propertyKeys 里面,</span><br>     <span class="hljs-comment">//用来确认 _JSONKeyPathsByPropertyKey 里面的 key 都是 model 的属性</span><br><span class="hljs-keyword">for</span> (NSString *mappedPropertyKey in _JSONKeyPathsByPropertyKey) &#123;<br><span class="hljs-keyword">if</span> (![propertyKeys containsObject:mappedPropertyKey]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ is not a property of %@.&quot;</span>, mappedPropertyKey, modelClass);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>        <span class="hljs-comment">//根据 model 的属性 key 取出 JSONKeyPath</span><br>id value = _JSONKeyPathsByPropertyKey[mappedPropertyKey];<br>        <span class="hljs-comment">//TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？在文章末尾说明1</span><br><span class="hljs-keyword">if</span> ([value isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-keyword">for</span> (NSString *keyPath in value) &#123;<br><span class="hljs-keyword">if</span> ([keyPath isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>, mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (![value isKindOfClass:NSString.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-built_in">NSAssert</span>(NO, @<span class="hljs-string">&quot;%@ must either map to a JSON key path or a JSON array of key paths, got: %@.&quot;</span>,mappedPropertyKey, value);<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//获取 model 属性的 valueTransformers 用于做类型转化</span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>_valueTransformersByPropertyKey = [self.<span class="hljs-keyword">class</span> valueTransformersForModelClass:modelClass];<br>    <span class="hljs-comment">//A new map table object which has strong references to the keys and values.</span><br>_JSONAdaptersByModelClass = [NSMapTable strongToStrongObjectsMapTable];<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.MTLModel的propertyKeys类方法,该方法会返回一个包含 model 属性列表的 NSSet 数据，但是这个 NSSet 数据不包含 被 readonly 修饰的属性，没有 ivars 变量的属性，以及 MTLModel 类自身的属性。除此之外的所有通过 @property 声明的属性都会存在 NSSet 数据中，</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled10.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">/// Returns the keys for all @property declarations, except for `readonly`</span><br><span class="hljs-comment">/// properties without ivars, or properties on MTLModel itself.</span><br>+ (NSSet *)propertyKeys &#123;<br>    <span class="hljs-comment">// 判断 model 中 是否有属性列表的缓存，若有直接返回</span><br>NSSet *cachedKeys = <span class="hljs-built_in">objc_getAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey);<br><span class="hljs-keyword">if</span> (cachedKeys != nil) <span class="hljs-keyword">return</span> cachedKeys;<br><br>NSMutableSet *keys = [NSMutableSet set];<br>    <span class="hljs-comment">//遍历 model 所有的属性，判断哪些属性是符合要求的，加入 keys 变量中</span><br>   <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>[self enumeratePropertiesUsingBlock:^(<span class="hljs-type">objc_property_t</span> property, BOOL *stop) &#123;<br>        <span class="hljs-comment">//获取属性名字</span><br>NSString *key = @(<span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-comment">//判断哪些属性是可以做映射的，即不是 MTLPropertyStorageNone 的都可以做映射</span><br>        <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br><span class="hljs-keyword">if</span> ([self storageBehaviorForPropertyWithKey:key] != MTLPropertyStorageNone) &#123;<br> [keys addObject:key];<br>&#125;<br>&#125;];<br><br><span class="hljs-comment">// It doesn&#x27;t really matter if we replace another thread&#x27;s work, since we do</span><br><span class="hljs-comment">// it atomically and the result should be the same.</span><br>    <span class="hljs-comment">// 给这个对象设置属性列表的缓存</span><br><span class="hljs-built_in">objc_setAssociatedObject</span>(self, MTLModelCachedPropertyKeysKey, keys, OBJC_ASSOCIATION_COPY);<br><br><span class="hljs-keyword">return</span> keys;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.MTLModel 的enumeratePropertiesUsingBlock类方法，该方法用来遍历 model 的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (<span class="hljs-type">void</span>)enumeratePropertiesUsingBlock:(<span class="hljs-built_in">void</span> (^)(<span class="hljs-type">objc_property_t</span> property, BOOL *stop))block &#123;<br>Class cls = self;<br>BOOL stop = NO;<br>    <span class="hljs-comment">//按 mode l的继承层级，遍历 model 的属性</span><br><span class="hljs-keyword">while</span> (!stop &amp;&amp; ![cls isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br><span class="hljs-type">unsigned</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取属性列表</span><br><span class="hljs-type">objc_property_t</span> *properties = <span class="hljs-built_in">class_copyPropertyList</span>(cls, &amp;count);<br>cls = cls.superclass;<br><span class="hljs-keyword">if</span> (properties == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(properties);<br>&#125;;<br>        <span class="hljs-comment">//block回调</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br><span class="hljs-built_in">block</span>(properties[i], &amp;stop);<br><span class="hljs-keyword">if</span> (stop) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.MTLModel 的 storageBehaviorForPropertyWithKey 类方法，用于判断 model 的属性是否可以用来做转化</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled11.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs CPP">+ (MTLPropertyStorage)storageBehaviorForPropertyWithKey:(NSString *)propertyKey &#123;<br>    <span class="hljs-comment">//根据属性名获取属性的相关内容</span><br><span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(self.<span class="hljs-keyword">class</span>, propertyKey.UTF8String);<br><span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>  <span class="hljs-comment">//将属性的 runtime 表示方法 转成 Mantle 的表示方法</span><br>  <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>@onExit &#123;<br><span class="hljs-built_in">free</span>(attributes);<br>&#125;;<br>  <span class="hljs-comment">//是否有 setter 和 getter 方法</span><br>BOOL hasGetter = [self instancesRespondToSelector:attributes-&gt;getter];<br>BOOL hasSetter = [self instancesRespondToSelector:attributes-&gt;setter]; <br><span class="hljs-keyword">if</span> (!attributes-&gt;dynamic &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span> &amp;&amp; !hasGetter &amp;&amp; !hasSetter) &#123;<br>        <span class="hljs-comment">// attributes 不是 dynamic ( @dynamic 就是要来告诉编译器，代码中用 @dynamic 修饰的属性，其 getter 和 setter 方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译)</span><br>        <span class="hljs-comment">// attributes-&gt;ivar 为空</span><br>        <span class="hljs-comment">//没有 getter 方法</span><br>        <span class="hljs-comment">//没有 setter 方法</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (attributes-&gt;readonly &amp;&amp; attributes-&gt;ivar == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">//attributes 是 readonly</span><br>        <span class="hljs-comment">//attributes-&gt;ivar 变量为空</span><br><span class="hljs-keyword">if</span> ([self isEqual:MTLModel.<span class="hljs-keyword">class</span>]) &#123;<br>            <span class="hljs-comment">//是否是 MTLModel 的属性</span><br><span class="hljs-keyword">return</span> MTLPropertyStorageNone;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Check superclass in case the subclass redeclares a property that</span><br><span class="hljs-comment">// falls through</span><br>            <span class="hljs-comment">// 检查一下超类属性，防止超类属性被子类重新声明</span><br><span class="hljs-keyword">return</span> [self.superclass storageBehaviorForPropertyWithKey:propertyKey];<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> MTLPropertyStoragePermanent;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.EXTRuntimeExtensions 的 mtl_copyPropertyAttributes 方法，作用是将属性的runtime表示形式转成更好理解的 Mantle 表示形式。该方法比较枯燥无味且相对来说难以理解，可以略过，不影响 Mantle 解读。<br>该方法需要结合苹果的官方<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Runtime</a>开发文档再进行单步调试才能更好的理解。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled12.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//以属性date为例,说明整个转化过程，具体的信息可以参考苹果官方的 runtime 文档</span><br><span class="hljs-comment">// @property (nonatomic,strong) NSString *date </span><br><br><span class="hljs-function">mtl_propertyAttributes *<span class="hljs-title">mtl_copyPropertyAttributes</span> <span class="hljs-params">(<span class="hljs-type">objc_property_t</span> property)</span> </span>&#123;<br>    <span class="hljs-comment">//The string starts with a T followed by the @encode type and a comma(逗号), and finishes with a V followed by the name of the backing instance variable.</span><br>    <span class="hljs-comment">//属性 date 的 runtime 表示形式为 &quot;T@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> attrString = <span class="hljs-built_in">property_getAttributes</span>(property);<br>    <span class="hljs-keyword">if</span> (!attrString) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not get attribute string from property %s\n&quot;</span>, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//必须以 T 开头</span><br>    <span class="hljs-keyword">if</span> (attrString[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;T&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Expected attribute string \&quot;%s\&quot; for property %s to start with &#x27;T&#x27;\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//去掉 T 变成 &quot;@\&quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *typeString = attrString + <span class="hljs-number">1</span>;<span class="hljs-comment">//attrString代表字符串的起始地址，地址加1表示字符串截取</span><br><br>    <span class="hljs-comment">// Obtains the actual size and the aligned size of an encoded type.</span><br>    <span class="hljs-comment">// 去掉 @encode 字符串 变成 &quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *next = <span class="hljs-built_in">NSGetSizeAndAlignment</span>(typeString, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!next) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read past type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   <span class="hljs-comment">// 以属性 date 为例差11个字符</span><br>    <span class="hljs-type">size_t</span> typeLength = next - typeString;<br>    <span class="hljs-keyword">if</span> (!typeLength) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Invalid type in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// allocate enough space for the structure and the type string (plus a NUL)</span><br>    <span class="hljs-comment">// 将propertyAttributes变成mtl_propertyAttributes类型</span><br>    <span class="hljs-comment">// TODO 长度的计算？为什么是这样计算？</span><br>    mtl_propertyAttributes *attributes = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(mtl_propertyAttributes) + typeLength + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (!attributes) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not allocate mtl_propertyAttributes structure for attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the type string</span><br>    <span class="hljs-comment">// 复制属性的类型</span><br>    <span class="hljs-built_in">strncpy</span>(attributes-&gt;type, typeString, typeLength);<br>    attributes-&gt;type[typeLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//字符串结尾</span><br><br>    <span class="hljs-comment">// if this is an object type, and immediately followed by a quoted string...</span><br>    <span class="hljs-keyword">if</span> (typeString[<span class="hljs-number">0</span>] == *(@<span class="hljs-built_in">encode</span>(id)) &amp;&amp; typeString[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;<br>        <span class="hljs-comment">// we should be able to extract a class name</span><br>        <span class="hljs-comment">// &quot;NSString\&quot;,&amp;,N,V_date&quot;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *className = typeString + <span class="hljs-number">2</span>;<span class="hljs-comment">//字符串截取</span><br><br>        <span class="hljs-comment">//extern char *strchr(const char *s,char c);查找字符串s中首次出现字符c的位置。</span><br>        <span class="hljs-comment">//&quot;\&quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(className, <span class="hljs-string">&#x27;&quot;&#x27;</span>);<br><br>        <span class="hljs-keyword">if</span> (!next) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Could not read class name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (className != next) &#123;<br>            <span class="hljs-comment">// 通过内存地址相减 0x0000000104f0347e((const char *) next) - 0x0000000104f03476((const char *) className) = 8</span><br>            <span class="hljs-type">size_t</span> classNameLength = next - className;<br>            <span class="hljs-type">char</span> trimmedName[classNameLength + <span class="hljs-number">1</span>];<span class="hljs-comment">//创建用于存放属性类型的数组</span><br><br>            <span class="hljs-built_in">strncpy</span>(trimmedName, className, classNameLength);<span class="hljs-comment">//复制属性类型到trimmedName</span><br>            trimmedName[classNameLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<span class="hljs-comment">//数组末尾结束符号</span><br><br>            <span class="hljs-comment">// attempt to look up the class in the runtime</span><br>            attributes-&gt;objectClass = <span class="hljs-built_in">objc_getClass</span>(trimmedName);<span class="hljs-comment">//设置属性类型</span><br>        &#125;<br>    &#125;<br>     <span class="hljs-comment">// &quot;\&quot;,&amp;,N,V_date&quot;</span><br>    <span class="hljs-keyword">if</span> (*next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-comment">// skip past any junk before the first flag</span><br>        <span class="hljs-comment">// &quot;,&amp;,N,V_date&quot;</span><br>        next = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (next &amp;&amp; *next == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>        <span class="hljs-comment">//第一次循环 &amp;</span><br>        <span class="hljs-comment">//第一次循环 N</span><br>        <span class="hljs-comment">//第一次循环 V</span><br>        <span class="hljs-type">char</span> flag = next[<span class="hljs-number">1</span>];<br>        next += <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">switch</span> (flag) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\0&#x27;</span>:<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>            <span class="hljs-comment">//The property is read-only (readonly).</span><br>            attributes-&gt;readonly = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            <span class="hljs-comment">//The property is a copy of the value last assigned (copy).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyCopy;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;&#x27;</span>:<br>            <span class="hljs-comment">//The property is a reference to the value last assigned (retain).</span><br>            attributes-&gt;memoryManagementPolicy = mtl_propertyMemoryManagementPolicyRetain;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;N&#x27;</span>:<br>            <span class="hljs-comment">//The property is non-atomic (nonatomic).</span><br>            attributes-&gt;nonatomic = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>            <span class="hljs-comment">//The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).</span><br>            &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *nextFlag = <span class="hljs-built_in">strchr</span>(next, <span class="hljs-string">&#x27;,&#x27;</span>);<br>                SEL name = <span class="hljs-literal">NULL</span>;<br><br>                <span class="hljs-keyword">if</span> (!nextFlag) &#123;<br>                    <span class="hljs-comment">// assume that the rest of the string is the selector</span><br>                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *selectorString = next;<br>                    next = <span class="hljs-string">&quot;&quot;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">size_t</span> selectorLength = nextFlag - next;<br>                    <span class="hljs-keyword">if</span> (!selectorLength) &#123;<br>                        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Found zero length selector name in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>                        <span class="hljs-keyword">goto</span> errorOut;<br>                    &#125;<br><br>                    <span class="hljs-type">char</span> selectorString[selectorLength + <span class="hljs-number">1</span>];<br><br>                    <span class="hljs-built_in">strncpy</span>(selectorString, next, selectorLength);<br>                    selectorString[selectorLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>                    name = <span class="hljs-built_in">sel_registerName</span>(selectorString);<br>                    next = nextFlag;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&#x27;G&#x27;</span>)<br>                    attributes-&gt;getter = name;<br>                <span class="hljs-keyword">else</span><br>                    attributes-&gt;setter = name;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>            <span class="hljs-comment">//The property is dynamic (@dynamic).</span><br>            attributes-&gt;dynamic = YES;<br>            attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:<br>            <span class="hljs-comment">// assume that the rest of the string (if present) is the ivar name</span><br>            <span class="hljs-comment">// V 之后的是变量名称</span><br>            <span class="hljs-keyword">if</span> (*next == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>                <span class="hljs-comment">// if there&#x27;s nothing there, let&#x27;s assume this is dynamic</span><br>                attributes-&gt;ivar = <span class="hljs-literal">NULL</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//取得变量名称</span><br>                attributes-&gt;ivar = next;<br>                next = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>             <span class="hljs-comment">//The property is a weak reference (__weak).</span><br>            attributes-&gt;weak = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;P&#x27;</span>:<br>            <span class="hljs-comment">//The property is eligible for garbage collection.</span><br>            attributes-&gt;canBeCollected = YES;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Old-style type encoding is unsupported in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, attrString, <span class="hljs-built_in">property_getName</span>(property));<br><br>            <span class="hljs-comment">// skip over this type encoding</span><br>            <span class="hljs-keyword">while</span> (*next != <span class="hljs-string">&#x27;,&#x27;</span> &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                ++next;<br><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;ERROR: Unrecognized attribute string flag &#x27;%c&#x27; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, flag, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (next &amp;&amp; *next != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Warning: Unparsed data \&quot;%s\&quot; in attribute string \&quot;%s\&quot; for property %s\n&quot;</span>, next, attrString, <span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;getter) &#123;<br>        <span class="hljs-comment">// use the property name as the getter by default</span><br>        <span class="hljs-comment">//使用默认的 getter 方法</span><br>        attributes-&gt;getter = <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-built_in">property_getName</span>(property));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!attributes-&gt;setter) &#123;<br>        <span class="hljs-comment">//使用默认的 setter 方法</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *propertyName = <span class="hljs-built_in">property_getName</span>(property);<br>        <span class="hljs-type">size_t</span> propertyNameLength = <span class="hljs-built_in">strlen</span>(propertyName);<br><br>        <span class="hljs-comment">// we want to transform the name to setProperty: style</span><br>        <span class="hljs-type">size_t</span> setterLength = propertyNameLength + <span class="hljs-number">4</span>;<br><br>        <span class="hljs-type">char</span> setterName[setterLength + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strncpy</span>(setterName, <span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">strncpy</span>(setterName + <span class="hljs-number">3</span>, propertyName, propertyNameLength);<br><br>        <span class="hljs-comment">// capitalize property name for the setter</span><br>        setterName[<span class="hljs-number">3</span>] = (<span class="hljs-type">char</span>)<span class="hljs-built_in">toupper</span>(setterName[<span class="hljs-number">3</span>]);<br><br>        setterName[setterLength - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;:&#x27;</span>;<br>        setterName[setterLength] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        attributes-&gt;setter = <span class="hljs-built_in">sel_registerName</span>(setterName);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> attributes;<br><br>errorOut:<br>    <span class="hljs-built_in">free</span>(attributes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.在获取了 Mantle 需要的属性之后，接下来就需要做一些转化操作了。MTLJSONAdapter 的类方法 valueTransformersForModelClass 主要是将 JSONKeyPath 的值转成 model 的属性声明的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//对值做类型转化,值类型的转化方法由 model 提供</span><br>+ (NSDictionary *)valueTransformersForModelClass:(Class)modelClass &#123;<br>    <span class="hljs-comment">//基本判断</span><br>    <span class="hljs-built_in">NSParameterAssert</span>(modelClass != nil);<br>    <span class="hljs-built_in">NSParameterAssert</span>([modelClass conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)]);<br>    NSMutableDictionary *result = [NSMutableDictionary dictionary];<br>    <br>    <span class="hljs-comment">//依次为每个属性拼接值类型转化方法并判断 model 是否实现了该方法</span><br>    <span class="hljs-keyword">for</span> (NSString *key in [modelClass propertyKeys]) &#123;<br>   <br>        <span class="hljs-comment">// 1、判断 model 是否实现了 +&lt;key&gt;JSONTransformer 类型方法</span><br>        SEL selector = <span class="hljs-built_in">MTLSelectorWithKeyPattern</span>(key, <span class="hljs-string">&quot;JSONTransformer&quot;</span>);<br>        <span class="hljs-comment">//判断是否有实现该方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:selector]) &#123;<br>            <span class="hljs-comment">//取得该方法的实现，调用该方法并获取该方法的返回值</span><br>            IMP imp = [modelClass methodForSelector:selector];<br>            NSValueTransformer * (*function)(id, SEL) = (__typeof__(function))imp;<br>            NSValueTransformer *transformer = <span class="hljs-built_in">function</span>(modelClass, selector);<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、判断 model 是否实现了 +JSONTransformerForKey: 类型方法</span><br>        <span class="hljs-keyword">if</span> ([modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(JSONTransformerForKey:)]) &#123;<br>            NSValueTransformer *transformer = [modelClass JSONTransformerForKey:key];<br>            <span class="hljs-comment">// 为属性保存 NSValueTransformer 对象</span><br>            <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">objc_property_t</span> property = <span class="hljs-built_in">class_getProperty</span>(modelClass, key.UTF8String);<br>        <span class="hljs-keyword">if</span> (property == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>       <span class="hljs-comment">//将属性的runtime 表示形式 转成 Mantle 的表示形式</span><br>        mtl_propertyAttributes *attributes = <span class="hljs-built_in">mtl_copyPropertyAttributes</span>(property);<br>        @onExit &#123;<br>            <span class="hljs-built_in">free</span>(attributes);<br>        &#125;;<br>      <span class="hljs-comment">//3、其他值类型转化</span><br>        NSValueTransformer *transformer = nil;<br>        <span class="hljs-keyword">if</span> (*(attributes-&gt;type) == *(@<span class="hljs-built_in">encode</span>(id))) &#123;<br>            Class propertyClass = attributes-&gt;objectClass;<br>            <span class="hljs-keyword">if</span> (propertyClass != nil) &#123;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                <span class="hljs-comment">//如果是对象类型，那么取出类型转化的 NSValueTransformer 对象</span><br>                transformer = [self transformerForModelPropertiesOfClass:propertyClass];<br>            &#125;<br>             <span class="hljs-comment">//用于做属性的值类型转换</span><br>            <span class="hljs-keyword">if</span> (transformer == nil) transformer = [NSValueTransformer mtl_validatingTransformerForClass:propertyClass ?: NSObject.<span class="hljs-keyword">class</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//区分BOOL类型</span><br>            transformer = [self transformerForModelPropertiesOfObjCType:attributes-&gt;type] ?: [NSValueTransformer mtl_validatingTransformerForClass:NSValue.<span class="hljs-keyword">class</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (transformer != nil) result[key] = transformer;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>8.MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 方法完成字典转成 model 操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>- (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error &#123;<br>    <span class="hljs-comment">//判断是否实现 classForParsingJSONDictionary: 协议</span><br>    <span class="hljs-keyword">if</span> ([self.modelClass respondsToSelector:@<span class="hljs-built_in">selector</span>(classForParsingJSONDictionary:)]) &#123;<br>        <span class="hljs-comment">//获取Class</span><br>        Class <span class="hljs-keyword">class</span> = [self.modelClass classForParsingJSONDictionary:JSONDictionary];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> == nil) &#123;<br>            <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">//错误处理</span><br>                NSDictionary *userInfo = @&#123;<br>                    NSLocalizedDescriptionKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;Could not parse JSON&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>),<br>                    NSLocalizedFailureReasonErrorKey: <span class="hljs-built_in">NSLocalizedString</span>(@<span class="hljs-string">&quot;No model class could be found to parse the JSON dictionary.&quot;</span>, @<span class="hljs-string">&quot;&quot;</span>)<br>                &#125;;<br>                *error = [NSError errorWithDomain:MTLJSONAdapterErrorDomain code:MTLJSONAdapterErrorNoClassFound userInfo:userInfo];<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> != self.modelClass) &#123;<br>            <span class="hljs-comment">//实现协议判断</span><br>            <span class="hljs-built_in">NSAssert</span>([<span class="hljs-keyword">class</span> conformsToProtocol:@<span class="hljs-built_in">protocol</span>(MTLJSONSerializing)], @<span class="hljs-string">&quot;Class %@ returned from +classForParsingJSONDictionary: does not conform to &lt;MTLJSONSerializing&gt;&quot;</span>, <span class="hljs-keyword">class</span>);<br><br>            MTLJSONAdapter *otherAdapter = [self JSONAdapterForModelClass:<span class="hljs-keyword">class</span> error:error];<br><br>            <span class="hljs-keyword">return</span> [otherAdapter modelFromJSONDictionary:JSONDictionary error:error];<br>        &#125;<br>    &#125;<br><br>    NSMutableDictionary *dictionaryValue = [[NSMutableDictionary alloc] initWithCapacity:JSONDictionary.count];<br>    <span class="hljs-comment">//取出 model 的属性 key</span><br>    <span class="hljs-keyword">for</span> (NSString *propertyKey in [self.modelClass propertyKeys]) &#123;<br>        <span class="hljs-comment">//取出JSONKeyPath</span><br>        id JSONKeyPaths = self.JSONKeyPathsByPropertyKey[propertyKey];<br><br>        <span class="hljs-keyword">if</span> (JSONKeyPaths == nil) <span class="hljs-keyword">continue</span>;<br><br>        id value;<br>        <span class="hljs-comment">//TODO 这个判断数组的用处？</span><br>        <span class="hljs-keyword">if</span> ([JSONKeyPaths isKindOfClass:NSArray.<span class="hljs-keyword">class</span>]) &#123;<br>            NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];<br>            <span class="hljs-keyword">for</span> (NSString *keyPath in JSONKeyPaths) &#123;<br>                BOOL success;<br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                id value = [JSONDictionary mtl_valueForJSONKeyPath:keyPath success:&amp;success error:error];<br>                <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                <span class="hljs-keyword">if</span> (value != nil) dictionary[keyPath] = value;<br>            &#125;<br>            value = dictionary;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            BOOL success;<br>           <span class="hljs-comment">//取出字典中JSONKeyPaths对应的值</span><br>           <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>            value = [JSONDictionary mtl_valueForJSONKeyPath:JSONKeyPaths success:&amp;success error:error];<br>            <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value == nil) <span class="hljs-keyword">continue</span>;<br>        @<span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//取出值转化的 NSValueTransformer 对象，若是对象为空则说明该 propertyKey 不需要做值转化</span><br>            NSValueTransformer *transformer = self.valueTransformersByPropertyKey[propertyKey];<br>            <span class="hljs-keyword">if</span> (transformer != nil) &#123;<br>                <span class="hljs-comment">// Map NSNull -&gt; nil for the transformer, and then back for the</span><br>                <span class="hljs-comment">// dictionary we&#x27;re going to insert into.</span><br>                <span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil;<br>                <span class="hljs-comment">//值转化操作</span><br>                <span class="hljs-keyword">if</span> ([transformer respondsToSelector:@<span class="hljs-built_in">selector</span>(transformedValue:success:error:)]) &#123;<br>                <span class="hljs-comment">//转化过程有回调 </span><br>                    id&lt;MTLTransformerErrorHandling&gt; errorHandlingTransformer = (id)transformer;<br>                    BOOL success = YES;<br>                    value = [errorHandlingTransformer transformedValue:value success:&amp;success error:error];<br>                    <span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不需要转化过程回调，直接转化</span><br>                <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>                    value = [transformer transformedValue:value];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (value == nil) value = NSNull.null;<br>            &#125;<br>            <span class="hljs-comment">// 保存被 NSValueTransformer 转化过的 JSONKeyPath 的值</span><br>            dictionaryValue[propertyKey] = value;<br>        &#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br>           <span class="hljs-comment">//省略错误处理代码</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception %@ parsing JSON key path \&quot;%@\&quot; from: %@&quot;</span>, ex, JSONKeyPaths, JSONDictionary);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//将字典转换成 model </span><br>    <span class="hljs-comment">// **该方法后文有详细的实现解读**</span><br>    id model = [self.modelClass modelWithDictionary:dictionaryValue error:error];<br>    <span class="hljs-comment">//进行错误验证</span><br>    <span class="hljs-keyword">return</span> [model validate:error] ? model : nil;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>9.NSDictionary+MTLJSONKeyPath 的 - (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error; 方法作用在于根据 JSONKeyPath 从 JSON 字典中取出对应的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs CPP">- (id)mtl_valueForJSONKeyPath:(NSString *)JSONKeyPath success:(BOOL *)success error:(NSError **)error &#123;<br>    <span class="hljs-comment">//TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</span><br>NSArray *components = [JSONKeyPath componentsSeparatedByString:@<span class="hljs-string">&quot;.&quot;</span>];<br>id result = self;<span class="hljs-comment">//字典</span><br><span class="hljs-keyword">for</span> (NSString *component in components) &#123;<br><span class="hljs-comment">// Check the result before resolving the key path component to not</span><br><span class="hljs-comment">// affect the last value of the path.</span><br><span class="hljs-keyword">if</span> (result == nil || result == NSNull.null) <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">if</span> (![result isKindOfClass:NSDictionary.<span class="hljs-keyword">class</span>]) &#123;<br>                 <span class="hljs-comment">//错误处理代码</span><br>&#125;<br>        <span class="hljs-comment">//以JSONKeyPath为key取出JSON字典中的值</span><br>result = result[component];<br>&#125;<br><br><span class="hljs-keyword">if</span> (success != <span class="hljs-literal">NULL</span>) *success = YES;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>10.在取得了JSONKeyPath对应的 value 之后，那么下一步操作就是要根据 model 值转化方法返回的 NSValueTransformer 对象做值转化操作</p><p>MTLValueTransformer 是一个基于 block 操作的值转化对象，实现 JSON字典–&gt;model 的转化。而MTLReversibleValueTransformer<br>实现逆向转化操作。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled13.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br>@implementation MTLValueTransformer<br><br><span class="hljs-comment">//转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.forwardBlock(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)transformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.forwardBlock(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br><br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br><br><span class="hljs-comment">//反向转化 model --&gt; JSON 字典</span><br>@implementation MTLReversibleValueTransformer<br><span class="hljs-comment">//反向转化操作，由 model 的 block 具体实现转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br><br><span class="hljs-keyword">return</span> self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br>&#125;<br><span class="hljs-comment">//带回调的转化操作，由 model 的 block 具体实现反向转化操作，返回值为转化后的值</span><br>- (id)reverseTransformedValue:(id)value success:(BOOL *)outerSuccess error:(NSError **)outerError &#123;<br>NSError *error = nil;<br>BOOL success = YES;<br>    <span class="hljs-comment">//转化后的值</span><br>id transformedValue = self.<span class="hljs-built_in">reverseBlock</span>(value, &amp;success, &amp;error);<br><br><span class="hljs-keyword">if</span> (outerSuccess != <span class="hljs-literal">NULL</span>) *outerSuccess = success;<br><span class="hljs-keyword">if</span> (outerError != <span class="hljs-literal">NULL</span>) *outerError = error;<br>    <br><span class="hljs-keyword">return</span> transformedValue;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>11.在处理的值转化之后，那么接下来就是要将从 JSON 字典中获取的 model 属性值赋值给对应的 model 对象了。在 MTLJSONAdapter 的 - (id)modelFromJSONDictionary:(NSDictionary *)JSONDictionary error:(NSError **)error 的实现中的最后一部分代码就是用来生成对应的 model 对象的。</p><img src="/2016/11/04/reading-source-code-of-Mantle/Untitled14.webp" class="" title="image"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//MTLModel  代码片段</span><br><br><span class="hljs-comment">//使用字典初始化 model </span><br>+ (instancetype)modelWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br><span class="hljs-keyword">return</span> [[self alloc] initWithDictionary:dictionary error:error];<br>&#125;<br>......<br><span class="hljs-comment">//使用字典初始化 model </span><br>- (instancetype)initWithDictionary:(NSDictionary *)dictionary error:(NSError **)error &#123;<br>self = [self init];<br><span class="hljs-keyword">if</span> (self == nil) <span class="hljs-keyword">return</span> nil;<br>       <span class="hljs-comment">//取出NSDictionary的key</span><br><span class="hljs-keyword">for</span> (NSString *key in dictionary) &#123;<br><span class="hljs-comment">// Mark this as being autoreleased, because validateValue may return</span><br><span class="hljs-comment">// a new object to be stored in this variable (and we don&#x27;t want ARC to</span><br><span class="hljs-comment">// double-free or leak the old or new values).</span><br>__autoreleasing id value = [dictionary objectForKey:key];<br><span class="hljs-keyword">if</span> ([value isEqual:NSNull.null]) value = nil; <br>        <span class="hljs-comment">//判断 model 的这个属性是否可以采用 KVC 来给属性赋值</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, YES, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> nil;<br>&#125;<br><br><span class="hljs-keyword">return</span> self;<br>&#125;<br><br><br><span class="hljs-comment">//判断 model 的某个属性是否可以采用 KVC 来给属性赋值，然后根据赋值条件给予赋值</span><br><span class="hljs-function"><span class="hljs-type">static</span> BOOL <span class="hljs-title">MTLValidateAndSetValue</span><span class="hljs-params">(id obj, NSString *key, id value, BOOL forceUpdate, NSError **error)</span> </span>&#123;<br>__autoreleasing id validatedValue = value;<br>@<span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当开发者需要验证能不能用KVC设定某个值时，可以调用validateValue: forKey:这个方法来验证</span><br>        <span class="hljs-comment">// 这个方法的默认实现是去类里面寻找是否有一个这样的方法：-(BOOL)validate&lt;Key&gt;:error:</span><br>        <span class="hljs-comment">// 如果有这个方法，就以这个方法的返回值作为判断标准，没有的话就直接返回YES</span><br><span class="hljs-keyword">if</span> (![obj validateValue:&amp;validatedValue forKey:key error:error]) <span class="hljs-keyword">return</span> NO;<br>        <span class="hljs-comment">// 设置新值</span><br>        <span class="hljs-comment">// obj 返回的 validatedValue 与 传进来的参数 value 进行对比，若不一致采用validatedValue的值</span><br>        <span class="hljs-comment">// forceUpdate 为 YES 那么也是直接给 key 设置值</span><br><span class="hljs-keyword">if</span> (forceUpdate || value != validatedValue) &#123;<br>[obj setValue:validatedValue forKey:key];<br>&#125;<br><span class="hljs-keyword">return</span> YES;<br>&#125; @<span class="hljs-built_in">catch</span> (NSException *ex) &#123;<br><span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;*** Caught exception setting key \&quot;%@\&quot; : %@&quot;</span>, key, ex);<br><span class="hljs-comment">//错误处理代码</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// model 的属性验证，只做验证处理，不做赋值操作</span><br>- (BOOL)validate:(NSError **)error &#123;<br><span class="hljs-keyword">for</span> (NSString *key in self.<span class="hljs-keyword">class</span>.propertyKeys) &#123;<br>id value = [self valueForKey:key];<br>        <span class="hljs-comment">//验证 model 是否有某个属性不能使用 KVC 赋值，若是有属性无法通过 KVC 赋值那么返回 NO。 此时 JSON 字典 --&gt; model 过程会得到一个 nil 对象，model 转化失败</span><br>BOOL success = <span class="hljs-built_in">MTLValidateAndSetValue</span>(self, key, value, NO, error);<br><span class="hljs-keyword">if</span> (!success) <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br><span class="hljs-keyword">return</span> YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>12.Mantle完成最后的 model 属性验证之后，返回相关的 model 对象。至此 Mantle 的 JSON 字典 –&gt; model 过程就完成了。</p><p>13.TODO 的应用场景说明<br> 在文中有 2 个 TODO  说明，限于篇幅统一放在这里说明。可以搜索 TODO 关键字找到文章做 TODO 标记文职<br>&#x2F;&#x2F; TODO [value isKindOfClass:NSArray.class] 这个是判断什么呢？在哪里用到呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                               @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span><br>                          &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下可能想把 temp 和 temp_max 放到一个字典当中。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSDictionary *temp;<br><br>@end<br><span class="hljs-comment">// temp 和 temp_max 放到一个字典当中 ,那么 JSONKeyPathsByPropertyKey 方法做如下实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:[NSArray arrayWithObjects:@<span class="hljs-string">&quot;temp&quot;</span>, @<span class="hljs-string">&quot;temp_max&quot;</span>,nil]<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; TODO 这个按.分割字符串是什么意思呢？在哪里用到呢？在文章末尾说明2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//JSON字典</span><br>NSDictionary *JSONDict = @&#123;<br>                               @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-number">200</span>,<br>                               @<span class="hljs-string">&quot;weather&quot;</span>:@&#123;<br>                                       @<span class="hljs-string">&quot;temp&quot;</span> : @<span class="hljs-string">&quot;59.07&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_max&quot;</span> : @<span class="hljs-string">&quot;63.32&quot;</span>,<br>                                       @<span class="hljs-string">&quot;temp_min&quot;</span> : @<span class="hljs-string">&quot;53.01&quot;</span><br>                                       &#125;<br>                               &#125;;<br><br><br><span class="hljs-comment">//根据上面的 JSON字典 按照正常的处理办法会再给 TestModel 新建一个名为 weather 的对象属性</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) Weather *weather;<br>@end<br><br><br><span class="hljs-comment">//但是有些情况下并不想给 TestModel 新建对象属性，而是把 JSON 字典中所有层级的 JSONKeyPath 都放到第一层级来。</span><br>@interface TestModel : MTLModel&lt;MTLJSONSerializing&gt;<br>@<span class="hljs-built_in">property</span> (nonatomic,assign) NSInteger code;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_max;<br>@<span class="hljs-built_in">property</span> (nonatomic,strong) NSString *temp_min;<br>@end<br><span class="hljs-comment">//JSON 字典中所有层级的 JSONKeyPath 都放到第一层级,那么 JSONKeyPathsByPropertyKey 方法需要做好对应的层级关系实现</span><br>@implementation TestModel<br>+(NSDictionary *)JSONKeyPathsByPropertyKey&#123;<br>    <span class="hljs-keyword">return</span> @&#123;<br>             @<span class="hljs-string">&quot;code&quot;</span>:@<span class="hljs-string">&quot;code&quot;</span>,<br>             @<span class="hljs-string">&quot;temp&quot;</span>:@<span class="hljs-string">&quot;weather.temp&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_max&quot;</span>:@<span class="hljs-string">&quot;weather.temp_max&quot;</span>,<br>             @<span class="hljs-string">&quot;temp_min&quot;</span>:@<span class="hljs-string">&quot;weather.temp_min&quot;</span>,<br>             &#125;;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Mantle 作为一款经典的 JSON 字典 &lt;–&gt; model 转化模型框架，主要是利用 KVC 特性为 model 赋值,其框架设计有不少优点，比如值转化过程的设计等，阅读优秀的开源项目不仅可以扩大技术眼界，也可以增加对代码细节的把控能力。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://github.com/Mantle/Mantle">https://github.com/Mantle/Mantle</a><br><a href="http://southpeak.github.io/2015/01/11/sourcecode-mantle/">http://southpeak.github.io/2015/01/11/sourcecode-mantle/</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a><br><a href="http://www.jianshu.com/p/f49ddbf8a2ea">http://www.jianshu.com/p/f49ddbf8a2ea</a><br><a href="http://www.jianshu.com/p/9f039124efef">http://www.jianshu.com/p/9f039124efef</a><br><a href="https://github.com/johnno1962/Xtrace">https://github.com/johnno1962/Xtrace</a><br><a href="http://nshipster.com/nsvaluetransformer/">http://nshipster.com/nsvaluetransformer/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS GIF 动画加载框架 - FLAnimatedImage 解读</title>
    <link href="/2016/08/31/reading-source-code-of-FLAnimatedImage/"/>
    <url>/2016/08/31/reading-source-code-of-FLAnimatedImage/</url>
    
    <content type="html"><![CDATA[<h1 id="FLAnimatedImage-解读"><a href="#FLAnimatedImage-解读" class="headerlink" title="FLAnimatedImage 解读"></a>FLAnimatedImage 解读</h1><p><a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> 是由Flipboard开源的iOS平台上播放GIF动画的一个优秀解决方案，在内存占用和播放体验都有不错的表现。<br>本文章主要是介绍FLAnimatedImage框架的GIF动画加载和播放流程，旨在说明流程和主要细节点，大家可以参考流程进行源码解读并调试，相信可以得到大量有用信息。<br>文章不免有不足或者错误之处，请大家在下方评论指出，我会尽快修正 l-(&gt;-&lt;)-l 。</p><h3 id="FLAnimatedImage简单流程图"><a href="#FLAnimatedImage简单流程图" class="headerlink" title="FLAnimatedImage简单流程图"></a>FLAnimatedImage简单流程图</h3><p>FLAnimatedImage项目的流程比较简单，FLAnimatedImage就是负责GIF数据的处理，然后提供给FLAnimatedImageView一个UIImage对象。FLAnimatedImageView拿到UIImage对象显示出来就可以了。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage使用"><a href="#FLAnimatedImage使用" class="headerlink" title="FLAnimatedImage使用"></a>FLAnimatedImage使用</h3><p>使用FLAnimatedImage处理GIF动画数据，使用FLAnimatedImageView展示FLAnimatedImage处理后的动画数据。</p><ul><li><p>使用NSData初始化FLAnimatedImage,然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView1) &#123;<br>       self.imageView1 = [[FLAnimatedImageView alloc] init];<br>       self.imageView1.contentMode = UIViewContentModeScaleAspectFill;<br>       self.imageView1.clipsToBounds = YES;<br>   &#125;<br>   [self.view addSubview:self.imageView1];<br>   self.imageView1.frame = CGRectMake(0.0, 120.0, self.view.bounds.size.width, 447.0);   <br>   NSURL *url1 = [[NSBundle mainBundle] URLForResource:@&quot;rock&quot; withExtension:@&quot;gif&quot;];<br>   NSData *data1 = [NSData dataWithContentsOfURL:url1];<br>   FLAnimatedImage *animatedImage1 = [FLAnimatedImage animatedImageWithGIFData:data1];<br>   self.imageView1.animatedImage = animatedImage1;<br></code></pre></td></tr></table></figure></li><li><p>使用URL初始化FLAnimatedImage，然后将FLAnimatedImage赋值给FLAnimatedImageView</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">if (!self.imageView2) &#123;<br>    self.imageView2 = [[FLAnimatedImageView alloc] init];<br>    self.imageView2.contentMode = UIViewContentModeScaleAspectFill;<br>    self.imageView2.clipsToBounds = YES;<br>&#125;<br>[self.view addSubview:self.imageView2];<br>self.imageView2.frame = CGRectMake(0.0, 577.0, 379.0, 447.0);<br><br>NSURL *url2 = [NSURL URLWithString:@&quot;https://cloud.githubusercontent.com/assets/1567433/10417835/1c97e436-7052-11e5-8fb5-69373072a5a0.gif&quot;];<br>[self loadAnimatedImageWithURL:url2 completion:^(FLAnimatedImage *animatedImage) &#123;<br>    self.imageView2.animatedImage = animatedImage;<br>&#125;];<br></code></pre></td></tr></table></figure></li></ul><h3 id="FLAnimatedImage项目代码结构"><a href="#FLAnimatedImage项目代码结构" class="headerlink" title="FLAnimatedImage项目代码结构"></a>FLAnimatedImage项目代码结构</h3><p> FLAnimatedImage项目采用了“生产者和消费者”模型来处理这个GIF动画的播放问题。一个线程负责生产数据，另一个线程负责消费数据。生产者FLAnimatedImage负责提供帧UIImage对象，消费者FLAnimatedImageView负责显示该UIImage对象。</p><img src="/2016/08/31/reading-source-code-of-FLAnimatedImage/Untitled1.webp" class="" title="This is an example image"><h3 id="FLAnimatedImage接口"><a href="#FLAnimatedImage接口" class="headerlink" title="FLAnimatedImage接口"></a>FLAnimatedImage接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">@property (nonatomic, strong, readonly) UIImage *posterImage;//GIF动画的封面帧图片<br>@property (nonatomic, assign, readonly) CGSize size; //GIF动画的封面帧图片的尺寸<br>@property (nonatomic, assign, readonly) NSUInteger loopCount; //GIF动画的循环播放次数<br>@property (nonatomic, strong, readonly) NSDictionary *delayTimesForIndexes; // GIF动画中的每帧图片的显示时间集合<br>@property (nonatomic, assign, readonly) NSUInteger frameCount; //GIF动画的帧数量<br>@property (nonatomic, assign, readonly) NSUInteger frameCacheSizeCurrent; //当前被缓存的帧图片的总数量<br>@property (nonatomic, assign) NSUInteger frameCacheSizeMax; // 允许缓存多少帧图片<br><br>// Intended to be called from main thread synchronously; will return immediately.<br>// If the result isn&#x27;t cached, will return `nil`; the caller should then pause playback, not increment frame counter and keep polling.<br>// After an initial loading time, depending on `frameCacheSize`, frames should be available immediately from the cache.<br>// 取出对应索引的帧图片<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index;<br><br>// Pass either a `UIImage` or an `FLAnimatedImage` and get back its size<br>// 计算该帧图片的尺寸<br>+ (CGSize)sizeForImage:(id)image;<br><br>// 初始化方法<br>// On success, the initializers return an `FLAnimatedImage` with all fields initialized, on failure they return `nil` and an error will be logged.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data;<br>// Pass 0 for optimalFrameCacheSize to get the default, predrawing is enabled by default.<br>- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled NS_DESIGNATED_INITIALIZER;<br>+ (instancetype)animatedImageWithGIFData:(NSData *)data;<br><br>//初始化数据<br>@property (nonatomic, strong, readonly) NSData *data; // The data the receiver was initialized with; read-only<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImage解析"><a href="#FLAnimatedImage解析" class="headerlink" title="FLAnimatedImage解析"></a>FLAnimatedImage解析</h3><ul><li>关键方法 初始化解析<br>a、对传进来的数据进行合法性判断，至少不能为nil。<br>b、初始化对应的变量，用于存储各类辅助数据。<br>c、将传进来的数据处理成图片数据，根据 kCGImageSourceShouldCache 的官方文档描述 <strong>Whether the image should be cached in a decoded form. The value of this key must be a CFBoolean value. The default value is kCFBooleanFalse in 32-bit, kCFBooleanTrue in 64-bit.</strong>  所以设置 kCGImageSourceShouldCache为NO,可以避免系统对图片进行缓存，<br>d、从数据中读取图片类型，判断该图片是不是GIF动画类型。<br>e、读取GIF动画中的动画信息，包括动画循环次数，有几帧图片等。<br>f、遍历GIF动画中的所有帧图片，取出并保存帧图片的播放信息，设置GIF动画的封面帧图片<br>g、根据设置或者GIF动画的占用内存大小，与缓存策略对比，确认缓存策略。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (instancetype)initWithAnimatedGIFData:(NSData *)data optimalFrameCacheSize:(NSUInteger)optimalFrameCacheSize predrawingEnabled:(BOOL)isPredrawingEnabled<br>&#123;<br>    // 1、进行数据合法性判断<br>    BOOL hasData = ([data length] &gt; 0);<br>    if (!hasData) &#123;<br>        FLLog(FLLogLevelError, @&quot;No animated GIF data supplied.&quot;);<br>        return nil;<br>    &#125;<br>    <br>    self = [super init];<br>    if (self) &#123;<br>        // 2、初始化对应的变量<br>        // Do one-time initializations of `readonly` properties directly to ivar to prevent implicit actions and avoid need for private `readwrite` property overrides.<br>        // Keep a strong reference to `data` and expose it read-only publicly.<br>        // However, we will use the `_imageSource` as handler to the image data throughout our life cycle.<br>        _data = data;<br>        _predrawingEnabled = isPredrawingEnabled;<br>        <br>        // Initialize internal data structures<br>        _cachedFramesForIndexes = [[NSMutableDictionary alloc] init];//key-&gt;帧图片在GIF动画的索引位置 value-&gt;单帧图片<br>        _cachedFrameIndexes = [[NSMutableIndexSet alloc] init];//缓存的帧图片在GIF动画的索引位置集合<br>        _requestedFrameIndexes = [[NSMutableIndexSet alloc] init];//需要生产者生产的的帧图片的索引位置<br><br>        // 3、创建图片数据<br>        // Note: We could leverage `CGImageSourceCreateWithURL` too to add a second initializer `-initWithAnimatedGIFContentsOfURL:`.<br>        _imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)data,<br>                                                   (__bridge CFDictionaryRef)@&#123;(NSString *)kCGImageSourceShouldCache: @NO&#125;);<br>        // Early return on failure!<br>        if (!_imageSource) &#123;<br>            FLLog(FLLogLevelError, @&quot;Failed to `CGImageSourceCreateWithData` for animated GIF data %@&quot;, data);<br>            return nil;<br>        &#125;<br>        // 4、取出图片类型，判断是否是GIF动画<br>        // Early return if not GIF!<br>        CFStringRef imageSourceContainerType = CGImageSourceGetType(_imageSource);<br>        BOOL isGIFData = UTTypeConformsTo(imageSourceContainerType, kUTTypeGIF);<br>        if (!isGIFData) &#123;<br>            FLLog(FLLogLevelError, @&quot;Supplied data is of type %@ and doesn&#x27;t seem to be GIF data %@&quot;, imageSourceContainerType, data);<br>            return nil;<br>        &#125;<br>        // 5、取出GIF动画信息<br>        // Get `LoopCount`<br>        // Note: 0 means repeating the animation indefinitely.<br>        // Image properties example:<br>        // &#123;<br>        //     FileSize = 314446;<br>        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>        //         HasGlobalColorMap = 1;<br>        //         LoopCount = 0;<br>        //     &#125;;<br>        // &#125;<br>        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(_imageSource, NULL);<br>        //获取GIF动画循环次数<br>        _loopCount = [[[imageProperties objectForKey:(id)kCGImagePropertyGIFDictionary] objectForKey:(id)kCGImagePropertyGIFLoopCount] unsignedIntegerValue];<br>        <br>        // Iterate through frame images<br>        //遍历图片<br>        size_t imageCount = CGImageSourceGetCount(_imageSource);<br>        NSUInteger skippedFrameCount = 0;//用于记录GIF动画中异常帧的数量<br>        NSMutableDictionary *delayTimesForIndexesMutable = [NSMutableDictionary dictionaryWithCapacity:imageCount];//记录GIF动画中每帧图片的显示时间<br>        for (size_t i = 0; i &lt; imageCount; i++) &#123;<br>            @autoreleasepool &#123;<br>                // 6、取出帧图片<br>                //Return the image at `index&#x27; in the image source `isrc&#x27;.<br>                CGImageRef frameImageRef = CGImageSourceCreateImageAtIndex(_imageSource, i, NULL);<br>                if (frameImageRef) &#123;<br>                    UIImage *frameImage = [UIImage imageWithCGImage:frameImageRef];<br>                    // Check for valid `frameImage` before parsing its properties as frames can be corrupted (and `frameImage` even `nil` when `frameImageRef` was valid).<br>                    if (frameImage) &#123;<br>                        // Set poster image<br>                        // 取出的第一张图片为GIF动画的封面图片<br>                        if (!self.posterImage) &#123;<br>                            _posterImage = frameImage;<br>                            // Set its size to proxy our size.<br>                            _size = _posterImage.size;<br>                            // Remember index of poster image so we never purge it; also add it to the cache.<br>                            _posterImageFrameIndex = i;<br>                            [self.cachedFramesForIndexes setObject:self.posterImage forKey:@(self.posterImageFrameIndex)];<br>                            [self.cachedFrameIndexes addIndex:self.posterImageFrameIndex];<br>                        &#125;<br>                        // 7、取出帧图片的信息<br>                        // Get `DelayTime`<br>                        // Note: It&#x27;s not in (1/100) of a second like still falsely described in the documentation as per iOS 8 (rdar://19507384) but in seconds stored as `kCFNumberFloat32Type`.<br>                        // Frame properties example:<br>                        // &#123;<br>                        //     ColorModel = RGB;<br>                        //     Depth = 8;<br>                        //     PixelHeight = 960;<br>                        //     PixelWidth = 640;<br>                        //     &quot;&#123;GIF&#125;&quot; = &#123;<br>                        //         DelayTime = &quot;0.4&quot;;<br>                        //         UnclampedDelayTime = &quot;0.4&quot;;<br>                        //     &#125;;<br>                        // &#125;<br>                        <br>                        NSDictionary *frameProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyPropertiesAtIndex(_imageSource, i, NULL);<br>                        NSDictionary *framePropertiesGIF = [frameProperties objectForKey:(id)kCGImagePropertyGIFDictionary];<br>                        <br>                        // 8、取出帧图片的展示时间<br>                        // Try to use the unclamped delay time; fall back to the normal delay time.<br>                        NSNumber *delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFUnclampedDelayTime];<br>                        if (!delayTime) &#123;<br>                            delayTime = [framePropertiesGIF objectForKey:(id)kCGImagePropertyGIFDelayTime];<br>                        &#125;<br>                        // If we don&#x27;t get a delay time from the properties, fall back to `kDelayTimeIntervalDefault` or carry over the preceding frame&#x27;s value.<br>                        const NSTimeInterval kDelayTimeIntervalDefault = 0.1;<br>                        if (!delayTime) &#123;<br>                            if (i == 0) &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to default delay time for first frame %@ because none found in GIF properties %@&quot;, frameImage, frameProperties);<br>                                delayTime = @(kDelayTimeIntervalDefault);<br>                            &#125; else &#123;<br>                                FLLog(FLLogLevelInfo, @&quot;Falling back to preceding delay time for frame %zu %@ because none found in GIF properties %@&quot;, i, frameImage, frameProperties);<br>                                delayTime = delayTimesForIndexesMutable[@(i - 1)];<br>                            &#125;<br>                        &#125;<br>                        // Support frame delays as low as `kFLAnimatedImageDelayTimeIntervalMinimum`, with anything below being rounded up to `kDelayTimeIntervalDefault` for legacy compatibility.<br>                        // To support the minimum even when rounding errors occur, use an epsilon when comparing. We downcast to float because that&#x27;s what we get for delayTime from ImageIO.<br>                        if ([delayTime floatValue] &lt; ((float)kFLAnimatedImageDelayTimeIntervalMinimum - FLT_EPSILON)) &#123;<br>                            FLLog(FLLogLevelInfo, @&quot;Rounding frame %zu&#x27;s `delayTime` from %f up to default %f (minimum supported: %f).&quot;, i, [delayTime floatValue], kDelayTimeIntervalDefault, kFLAnimatedImageDelayTimeIntervalMinimum);<br>                            delayTime = @(kDelayTimeIntervalDefault);<br>                        &#125;<br>                        delayTimesForIndexesMutable[@(i)] = delayTime;<br>                    &#125; else &#123;<br>                        skippedFrameCount++;<br>                        FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because valid `CGImageRef` %@ did result in `nil`-`UIImage`.&quot;, i, frameImageRef);<br>                    &#125;<br>                    CFRelease(frameImageRef);<br>                &#125; else &#123;<br>                    skippedFrameCount++;<br>                    FLLog(FLLogLevelInfo, @&quot;Dropping frame %zu because failed to `CGImageSourceCreateImageAtIndex` with image source %@&quot;, i, _imageSource);<br>                &#125;<br>            &#125;<br>        &#125;<br>        //帧图片展示时间的数组<br>        _delayTimesForIndexes = [delayTimesForIndexesMutable copy];<br>        //GIF动画有多少帧图片<br>        _frameCount = imageCount;<br>        <br>        if (self.frameCount == 0) &#123;<br>            FLLog(FLLogLevelInfo, @&quot;Failed to create any valid frames for GIF with properties %@&quot;, imageProperties);<br>            return nil;<br>        &#125; else if (self.frameCount == 1) &#123;<br>            // Warn when we only have a single frame but return a valid GIF.<br>            FLLog(FLLogLevelInfo, @&quot;Created valid GIF but with only a single frame. Image properties: %@&quot;, imageProperties);<br>        &#125; else &#123;<br>            // We have multiple frames, rock on!<br>        &#125;<br>        // 9、GIF动画缓存策略<br>        // If no value is provided, select a default based on the GIF.<br>        if (optimalFrameCacheSize == 0) &#123;<br>            // Calculate the optimal frame cache size: try choosing a larger buffer window depending on the predicted image size.<br>            // It&#x27;s only dependent on the image size &amp; number of frames and never changes.<br>            // 图片的每行字节大小*高*图片数量/1M的字节 = GIF大小（M）<br>            // 根据GIF图的大小和缓存策略判断需要缓存的单帧图片数量<br>            <br>            //GIF动画的占用内存大小与FLAnimatedImageDataSizeCategory的方案比较，确认缓存策略<br>            CGFloat animatedImageDataSize = CGImageGetBytesPerRow(self.posterImage.CGImage) * self.size.height * (self.frameCount - skippedFrameCount) / MEGABYTE;<br>            if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryAll) &#123;<br>                _frameCacheSizeOptimal = self.frameCount;<br>            &#125; else if (animatedImageDataSize &lt;= FLAnimatedImageDataSizeCategoryDefault) &#123;<br>                // This value doesn&#x27;t depend on device memory much because if we&#x27;re not keeping all frames in memory we will always be decoding 1 frame up ahead per 1 frame that gets played and at this point we might as well just keep a small buffer just large enough to keep from running out of frames.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeDefault;<br>            &#125; else &#123;<br>                // The predicted size exceeds the limits to build up a cache and we go into low memory mode from the beginning.<br>                _frameCacheSizeOptimal = FLAnimatedImageFrameCacheSizeLowMemory;<br>            &#125;<br>        &#125; else &#123;<br>            // Use the provided value.<br>            _frameCacheSizeOptimal = optimalFrameCacheSize;<br>        &#125;<br>        // In any case, cap the optimal cache size at the frame count.<br>        // _frameCacheSizeOptimal 不能大于 self.frameCount<br>        // 确认最佳的GIF动画的帧图片缓存数量<br>        _frameCacheSizeOptimal = MIN(_frameCacheSizeOptimal, self.frameCount);<br>        <br>        // Convenience/minor performance optimization; keep an index set handy with the full range to return in `-frameIndexesToCache`.<br>        _allFramesIndexSet = [[NSIndexSet alloc] initWithIndexesInRange:NSMakeRange(0, self.frameCount)];<br>        <br>        // See the property declarations for descriptions.<br>        //成为FLWeakProxy的代理<br>        _weakProxy = (id)[FLWeakProxy weakProxyForObject:self];<br>        <br>        // Register this instance in the weak table for memory notifications. The NSHashTable will clean up after itself when we&#x27;re gone.<br>        // Note that FLAnimatedImages can be created on any thread, so the hash table must be locked.<br>        @synchronized(allAnimatedImagesWeak) &#123;<br>            [allAnimatedImagesWeak addObject:self];<br>        &#125;<br>    &#125;<br>    return self;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 取UIImage对象<br>a、对索引位置进行判断，避免出现越界情况<br>b、记录当前取出的帧图片的索引位置<br>c、根据缓存策略判断接下来需要生产的帧图片索引，正常是当前显示帧图片之后的帧图片的索引。<br>d、根据需要生产的帧图片索引生产帧图片<br>e、取出对应的帧图片<br>f、根据缓存策略清缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// See header for more details.<br>// Note: both consumer and producer are throttled: consumer by frame timings and producer by the available memory (max buffer window size).<br>- (UIImage *)imageLazilyCachedAtIndex:(NSUInteger)index<br>&#123;<br>    // Early return if the requested index is beyond bounds.<br>    // Note: We&#x27;re comparing an index with a count and need to bail on greater than or equal to.<br>    // 1、索引位置判断<br>    if (index &gt;= self.frameCount) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Skipping requested frame %lu beyond bounds (total frame count: %lu) for animated image: %@&quot;, (unsigned long)index, (unsigned long)self.frameCount, self);<br>        return nil;<br>    &#125;<br>    <br>    // Remember requested frame index, this influences what we should cache next.<br>    // 2、记录当前要生产的帧图片在GIF动画中的索引位置<br>    self.requestedFrameIndex = index;<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>    if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImage:didRequestCachedFrame:)]) &#123;<br>        [self.debug_delegate debug_animatedImage:self didRequestCachedFrame:index];<br>    &#125;<br>#endif<br>    <br>    // Quick check to avoid doing any work if we already have all possible frames cached, a common case.<br>    // 3、判断GIF动画的帧图片的是否全部缓存下来了,因为有可能缓存策略是缓存所有的帧图片<br>    if ([self.cachedFrameIndexes count] &lt; self.frameCount) &#123;<br>        // If we have frames that should be cached but aren&#x27;t and aren&#x27;t requested yet, request them.<br>        // Exclude existing cached frames, frames already requested, and specially cached poster image.<br>        // 4、根据缓存策略得到接下来需要缓存的帧图片索引，<br>        NSMutableIndexSet *frameIndexesToAddToCacheMutable = [self frameIndexesToCache];<br>        // 5、除去已经缓存下来的帧图片索引<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.cachedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndexes:self.requestedFrameIndexes];<br>        [frameIndexesToAddToCacheMutable removeIndex:self.posterImageFrameIndex];<br>        NSIndexSet *frameIndexesToAddToCache = [frameIndexesToAddToCacheMutable copy];<br>        <br>        // Asynchronously add frames to our cache.<br>        if ([frameIndexesToAddToCache count] &gt; 0) &#123;<br>            // 6、生产帧图片<br>            [self addFrameIndexesToCache:frameIndexesToAddToCache];<br>        &#125;<br>    &#125;<br>    <br>    // Get the specified image.<br>    // 7、取出帧图片<br>    UIImage *image = self.cachedFramesForIndexes[@(index)];<br>    <br>    // Purge if needed based on the current playhead position.<br>    // 8、根据缓存策略清缓存<br>    [self purgeFrameCacheIfNeeded];<br>    <br>    return image;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他关键方法简单介绍</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">// Only called once from `-imageLazilyCachedAtIndex` but factored into its own method for logical grouping.<br>// 生产帧图片<br>- (void)addFrameIndexesToCache:(NSIndexSet *)frameIndexesToAddToCache;<br><br>// 取出GIF动画的帧图片<br>- (UIImage *)imageAtIndex:(NSUInteger)index;<br><br>// Decodes the image&#x27;s data and draws it off-screen fully in memory; it&#x27;s thread-safe and hence can be called on a background thread.<br>// On success, the returned object is a new `UIImage` instance with the same content as the one passed in.<br>// On failure, the returned object is the unchanged passed in one; the data will not be predrawn in memory though and an error will be logged.<br>// First inspired by &amp; good Karma to: https://gist.github.com/steipete/1144242<br>// 解码图片<br>+ (UIImage *)predrawnImageFromImage:(UIImage *)imageToPredraw;<br><br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView接口"><a href="#FLAnimatedImageView接口" class="headerlink" title="FLAnimatedImageView接口"></a>FLAnimatedImageView接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C"><br>// FLAnimatedImageView是UIImageView的子类，完全兼容UIImageView的各个方法。<br><br>//  An `FLAnimatedImageView` can take an `FLAnimatedImage` and plays it automatically when in view hierarchy and stops when removed.<br>//  The animation can also be controlled with the `UIImageView` methods `-start/stop/isAnimating`.<br>//  It is a fully compatible `UIImageView` subclass and can be used as a drop-in component to work with existing code paths expecting to display a `UIImage`.<br>//  Under the hood it uses a `CADisplayLink` for playback, which can be inspected with `currentFrame` &amp; `currentFrameIndex`.<br>//<br>@interface FLAnimatedImageView : UIImageView<br><br>// Setting `[UIImageView.image]` to a non-`nil` value clears out existing `animatedImage`.<br>// And vice versa, setting `animatedImage` will initially populate the `[UIImageView.image]` to its `posterImage` and then start animating and hold `currentFrame`.<br>@property (nonatomic, strong) FLAnimatedImage *animatedImage;//设置GIF动画数据<br>@property (nonatomic, copy) void(^loopCompletionBlock)(NSUInteger loopCountRemaining);//GIF动画播放一次之后的回调Block<br><br>@property (nonatomic, strong, readonly) UIImage *currentFrame;//GIF动画当前显示的帧图片<br>@property (nonatomic, assign, readonly) NSUInteger currentFrameIndex;//GIF动画当前显示的帧图片索引<br><br>// The animation runloop mode. Enables playback during scrolling by allowing timer events (i.e. animation) with NSRunLoopCommonModes.<br>// To keep scrolling smooth on single-core devices such as iPhone 3GS/4 and iPod Touch 4th gen, the default run loop mode is NSDefaultRunLoopMode. Otherwise, the default is NSDefaultRunLoopMode.<br>@property (nonatomic, copy) NSString *runLoopMode;<br><br>@end<br></code></pre></td></tr></table></figure><h3 id="FLAnimatedImageView解析"><a href="#FLAnimatedImageView解析" class="headerlink" title="FLAnimatedImageView解析"></a>FLAnimatedImageView解析</h3><ul><li>关键方法 设置FLAnimatedImage对象解析<br>a、判断新旧FLAnimatedImage对象是否一致，一致就不需要继续操作了<br>b、设置GIF动画的封面帧图片，当前帧索引，GIF动画的循环播放次数，播放时间累加器<br>c、更新是否发起动画的标志位，判断是否启动GIF动画<br>d、刷新View的layer</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)setAnimatedImage:(FLAnimatedImage *)animatedImage<br>&#123;<br>    //新设置的GIF动画数据和当前的数据不一致<br>    if (![_animatedImage isEqual:animatedImage]) &#123;<br>        if (animatedImage) &#123;<br>            // Clear out the image.<br>            super.image = nil;<br>            // Ensure disabled highlighting; it&#x27;s not supported (see `-setHighlighted:`).<br>            super.highlighted = NO;<br>            // UIImageView seems to bypass some accessors when calculating its intrinsic content size, so this ensures its intrinsic content size comes from the animated image.<br>            //确保UIImageView的content size 大小来自 animated image<br>            [self invalidateIntrinsicContentSize];<br>        &#125; else &#123;<br>            // Stop animating before the animated image gets cleared out.<br>            // animatedImage为nil，需要清空当前动画图片<br>            [self stopAnimating];<br>        &#125;<br>        <br>        _animatedImage = animatedImage;<br>        <br>        self.currentFrame = animatedImage.posterImage;//GIF动画的封面帧图片<br>        self.currentFrameIndex = 0;//当前的帧图片索引<br>        //设置GIF动画的循环播放次数<br>        if (animatedImage.loopCount &gt; 0) &#123;<br>            self.loopCountdown = animatedImage.loopCount;<br>        &#125; else &#123;<br>            self.loopCountdown = NSUIntegerMax;<br>        &#125;<br>        //播放时间累加器<br>        self.accumulator = 0.0;<br>        <br>        // Start animating after the new animated image has been set.<br>        [self updateShouldAnimate];<br>        if (self.shouldAnimate) &#123;<br>            [self startAnimating];<br>        &#125;<br>        <br>        [self.layer setNeedsDisplay];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 设置CADisplayLink的frameInterval</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)startAnimating<br>&#123;<br>    //使用CADisplayLink来播放GIF动画<br>    if (self.animatedImage) &#123;<br>        // Lazily create the display link.<br>        if (!self.displayLink) &#123;<br>            // It is important to note the use of a weak proxy here to avoid a retain cycle. `-displayLinkWithTarget:selector:`<br>            // will retain its target until it is invalidated. We use a weak proxy so that the image view will get deallocated<br>            // independent of the display link&#x27;s lifetime. Upon image view deallocation, we invalidate the display<br>            // link which will lead to the deallocation of both the display link and the weak proxy.<br>            FLWeakProxy *weakProxy = [FLWeakProxy weakProxyForObject:self];<br>            self.displayLink = [CADisplayLink displayLinkWithTarget:weakProxy selector:@selector(displayDidRefresh:)];<br>            <br>            [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:self.runLoopMode];<br>        &#125;<br><br>        // Note: The display link&#x27;s `.frameInterval` value of 1 (default) means getting callbacks at the refresh rate of the display (~60Hz).<br>        // Setting it to 2 divides the frame rate by 2 and hence calls back at every other display refresh.<br>        const NSTimeInterval kDisplayRefreshRate = 60.0; // 60Hz<br>        // 1、frameInterval : Defines how many display frames must pass between each time the display link fires.<br>        // 2、先求出gif中每帧图片的播放时间，求出这些播放时间的最大公约数，<br>        // 3、将这个最大公约数*刷新速率，再与1比取最大值，该值作为frameInterval。<br>        // 4、将GIF动画的每帧图片显示时间除以帧显示时间的最大公约数，得到单位时间内GIF动画的每个帧显示时间的比例，然后再乘以屏幕刷新速率kDisplayRefreshRate作为displayLink.frameInterval,正好可以用displayLink调用刷新方法的频率来保证GIF动画的帧图片展示时间 frame delays的间隔比例，使GIF动画的效果能够正常显示。<br>        self.displayLink.frameInterval = MAX([self frameDelayGreatestCommonDivisor] * kDisplayRefreshRate, 1);<br><br>        self.displayLink.paused = NO;<br>    &#125; else &#123;<br>        [super startAnimating];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>关键方法 播放GIF动画<br>该方法关键点在于accumulator累加器的使用和displayLink.frameInterval的计算，涉及一些简单的数学过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs Objective-C">- (void)displayDidRefresh:(CADisplayLink *)displayLink<br>&#123;<br>    // If for some reason a wild call makes it through when we shouldn&#x27;t be animating, bail.<br>    // Early return!<br>    if (!self.shouldAnimate) &#123;<br>        FLLog(FLLogLevelWarn, @&quot;Trying to animate image when we shouldn&#x27;t: %@&quot;, self);<br>        return;<br>    &#125;<br>    <br>    NSNumber *delayTimeNumber = [self.animatedImage.delayTimesForIndexes objectForKey:@(self.currentFrameIndex)];<br>    // If we don&#x27;t have a frame delay (e.g. corrupt frame), don&#x27;t update the view but skip the playhead to the next frame (in else-block).<br>    if (delayTimeNumber) &#123;<br>        NSTimeInterval delayTime = [delayTimeNumber floatValue];<br>        // If we have a nil image (e.g. waiting for frame), don&#x27;t update the view nor playhead.<br>        // 拿到当前要显示的图片<br>        UIImage *image = [self.animatedImage imageLazilyCachedAtIndex:self.currentFrameIndex];<br>        if (image) &#123;<br>            FLLog(FLLogLevelVerbose, @&quot;Showing frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>            //显示图片<br>            self.currentFrame = image;<br>            if (self.needsDisplayWhenImageBecomesAvailable) &#123;<br>                [self.layer setNeedsDisplay];<br>                self.needsDisplayWhenImageBecomesAvailable = NO;<br>            &#125;<br>            //frameInterval:Defines how many display frames must pass between each time the display link fires<br>            //duration :duration of the display frame<br>            <br>            //displayLink.duration * displayLink.frameInterval是每个display link fires之间的时间间隔<br>            self.accumulator += displayLink.duration * displayLink.frameInterval;<br>            <br>//从前面的startAnimating方法中displayLink.frameInterval的计算过程可以知道，<br>//GIF动画中的帧图片的展示时间都是delayTime都是displayLink.duration * displayLink.frameInterval的倍数关系，<br>//也就是说一个GIF动画帧图片的展示时间至少是一个display link fires的时间间隔。<br>//以下数据是使用FLAnimatedImage的Demo项目的第一个GIF动画的播放信息打印出来的。<br>//按照Demo中的打印数据来说，第0帧图片的展示时间是14个display link fires的时间间隔，而1，2，3帧图片都是只有一个display link fires的时间间隔。<br>//所以累加器self.accumulator的意义在于累加display link fires的时间间隔，并与帧图片的delayTime做比较，如果小于delayTime说明该帧图片还需要继续展示，否则该帧图片结束展示。<br>            <br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.100000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.150000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.200000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.250000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.300000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.350000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.400000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.450000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.500000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.550000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.600000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.650000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;0,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.700000,   delayTime--&gt;0.700000<br>//            currentFrameIndex--&gt;1,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;2,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>//            currentFrameIndex--&gt;3,   duration---&gt;0.016667,    frameInterval--&gt;3,  accumulator--&gt;0.050000,   delayTime--&gt;0.050000<br>            <br>            <br>            // While-loop first inspired by &amp; good Karma to: https://github.com/ondalabs/OLImageView/blob/master/OLImageView.m<br>            while (self.accumulator &gt;= delayTime) &#123;<br>                self.accumulator -= delayTime;<br>                self.currentFrameIndex++;<br>                <br>                if (self.currentFrameIndex &gt;= self.animatedImage.frameCount) &#123;<br>                    // 播放到结尾，循环次数减1<br>                    // If we&#x27;ve looped the number of times that this animated image describes, stop looping.<br>                    self.loopCountdown--;<br>                    if (self.loopCompletionBlock) &#123;<br>                        self.loopCompletionBlock(self.loopCountdown);<br>                    &#125;<br>                    // 循环次数为0，停止播放,退出方法<br>                    if (self.loopCountdown == 0) &#123;<br>                        [self stopAnimating];<br>                        return;<br>                    &#125;<br>                    //重置帧图片索引，继续从头开始播放gif动画<br>                    self.currentFrameIndex = 0;<br>                &#125;<br>                // Calling `-setNeedsDisplay` will just paint the current frame, not the new frame that we may have moved to.<br>                // Instead, set `needsDisplayWhenImageBecomesAvailable` to `YES` -- this will paint the new image once loaded.<br>                // 展示新图片<br>                self.needsDisplayWhenImageBecomesAvailable = YES;<br>            &#125;<br>        &#125; else &#123;<br>            FLLog(FLLogLevelDebug, @&quot;Waiting for frame %lu for animated image: %@&quot;, (unsigned long)self.currentFrameIndex, self.animatedImage);<br>#if defined(DEBUG) &amp;&amp; DEBUG<br>            if ([self.debug_delegate respondsToSelector:@selector(debug_animatedImageView:waitingForFrame:duration:)]) &#123;<br>                [self.debug_delegate debug_animatedImageView:self waitingForFrame:self.currentFrameIndex duration:(NSTimeInterval)displayLink.duration * displayLink.frameInterval];<br>            &#125;<br>#endif<br>        &#125;<br>    &#125; else &#123;<br>        //取不到需要的信息直接开始下一张图片播放<br>        self.currentFrameIndex++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>FLAnimatedImage就是负责生产数据是生产者。</li><li>FLAnimatedImageView负责消费数据是消费者。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/">https://developer.apple.com/library/ios/documentation/QuartzCore/Reference/CADisplayLink_ClassRef/</a><br><a href="http://engineering.flipboard.com/2014/05/animated-gif/">http://engineering.flipboard.com/2014/05/animated-gif/</a><br><a href="https://github.com/Flipboard/FLAnimatedImage">https://github.com/Flipboard/FLAnimatedImage</a><br><a href="http://blog.ibireme.com/2015/11/02/ios_image_tips/">http://blog.ibireme.com/2015/11/02/ios_image_tips/</a><br><a href="http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">http://blog.ibireme.com/2015/11/02/mobile_image_benchmark/</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 网络框架－AFNetworking 3.1.0 源码解读</title>
    <link href="/2016/07/31/reading-source-code-of-AFNetworking/"/>
    <url>/2016/07/31/reading-source-code-of-AFNetworking/</url>
    
    <content type="html"><![CDATA[<h1 id="AFNetworking-解读"><a href="#AFNetworking-解读" class="headerlink" title="AFNetworking 解读"></a>AFNetworking 解读</h1><p>AFNetworking 基本是 iOS 开发中的网络第三方库标配,本文基于 <a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">AFNetworking3.1.0</a> 版本。废话不多说，这篇文章主要从使用的角度来介绍 AFNetworking 的发起 Get 请求的过程，偏重于解读过程，解读当你使用 AFNetworking 发起一个 Get 请求的时候，AFNetworking 内部的处理过程。而不是对 AFNetworking 源代码的各个类的代码进行深入解析，在源码深度解析方面，网络上已经有很多不错的文章，在文章的末尾我会给出参考链接。</p><h2 id="Get-请求流程图"><a href="#Get-请求流程图" class="headerlink" title="Get 请求流程图"></a>Get 请求流程图</h2><p>这是 AFNetworking 发起一个 Get 请求的流程图，大概可以分为这几个步骤，我会逐个解读这个流程。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled.webp" class="" title="This is an example image"><h2 id="AFHTTPSessionManager-发起Get请求"><a href="#AFHTTPSessionManager-发起Get请求" class="headerlink" title="AFHTTPSessionManager 发起Get请求"></a>AFHTTPSessionManager 发起Get请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled1.webp" class="" title="This is an example image"><p>这个方法是 AFN 的 Get 请求的起点，其他 Get 请求的方法也都是直接或者间接调用这个方法来发起 Get 请求。这个方法的代码量很少也很直观，就是调用其他方法生成 NSURLSessionDataTask 对象的实例,然后调用 NSURLSessionDataTask 的 resume 方法发起请求。</p><h2 id="创建-NSURLSessionDataTask"><a href="#创建-NSURLSessionDataTask" class="headerlink" title="创建 NSURLSessionDataTask"></a>创建 NSURLSessionDataTask</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled2.webp" class="" title="This is an example image"><p>这个方法是创建 NSURLSessionDataTask 对象实例并返回这个实例。首先创建一个 NSMutableURLRequest 对象的实例，然后配置。之后是使用 NSMutableURLRequest 对象的实例创建 NSURLSessionDataTask 对象实例，然后配置，可以选择性地传入各类 Block 回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。</p><h3 id="配置-NSMutableURLRequest-对象"><a href="#配置-NSMutableURLRequest-对象" class="headerlink" title="配置 NSMutableURLRequest 对象"></a>配置 NSMutableURLRequest 对象</h3><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled3.webp" class="" title="This is an example image"><p>在这个方法中先使用了url 创建了一个 NSMutableURLRequest 对象的实例,并且设置了 HTTPMethod 为 Get 方法（如果是 Post 方法，那么这里就是设置 Post 方法，以此类推）然后使用 KVC 的方法设置了 NSMutableURLRequest 的一些属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">//设置 NSMutableURLRequest 的属性</span><br> <span class="hljs-function"><span class="hljs-type">static</span> NSArray * <span class="hljs-title">AFHTTPRequestSerializerObservedKeyPaths</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        <span class="hljs-comment">//allowsCellularAccess 允许使用数据流量</span><br>        <span class="hljs-comment">//cachePolicy 缓存策略</span><br>        <span class="hljs-comment">//HTTPShouldHandleCookies 处理Cookie</span><br>        <span class="hljs-comment">//HTTPShouldUsePipelining 批量请求</span><br>        <span class="hljs-comment">//networkServiceType 网络状态</span><br>        <span class="hljs-comment">//timeoutInterval 超时</span><br>        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(allowsCellularAccess)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(cachePolicy)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldHandleCookies)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(HTTPShouldUsePipelining)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(networkServiceType)), <span class="hljs-built_in">NSStringFromSelector</span>(@<span class="hljs-built_in">selector</span>(timeoutInterval))];<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;<br>&#125;```<br><br><br>![配置NSMutableURLRequest对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-a228e54cc99ab038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br>先设置 HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于 Get 操作来说，参数是直接拼接在请求地址后面。<br><br>### 配置 NSURLSessionDataTask 对象<br><br>![配置NSURLSessionDataTask对象](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-df139131c05cc9b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>之后配置 NSMutableURLRequest 对象就需要配置 NSURLSessionDataTask 对象了。主要分为 <span class="hljs-number">2</span> 个步骤，第一个步骤是创建 NSURLSessionDataTask 对象实例，第二个步骤是给 NSURLSessionDataTask 对象实例设置 Delegate。用于实时了解网络请求的过程。<br><br><br>![给NSURLSessionDataTask对象实例设置Delegate](http:<span class="hljs-comment">//upload-images.jianshu.io/upload_images/656644-d75418e6972979c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><br>AFN 的代理统一使用 AFURLSessionManagerTaskDelegate 对象来管理，使用AFURLSessionManagerTaskDelegate 对象来接管 NSURLSessionTask 网络请求过程中的回调，然后再传入 AFN 内部进行管理。<br><br>```CPP<br>@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;<br></code></pre></td></tr></table></figure><p>如代码所示 AFURLSessionManagerTaskDelegate 接管了 NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 NSURLSessionTask 的 taskIdentifier 标识符对 delegate 进行管理，只要是用于识别该NSURLSessionTask 的代理，</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled4.webp" class="" title="This is an example image"><p>设置各类回调 Block,给 NSURLSessionTask 使用 KVO 进行各种过程进度监听。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task添加暂停和恢复的通知</span><br>- (<span class="hljs-type">void</span>)addNotificationObserverForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];<br>&#125;<br></code></pre></td></tr></table></figure><p>监听 NSURLSessionTask 被挂起和恢复的通知</p><h2 id="网络请求开始"><a href="#网络请求开始" class="headerlink" title="网络请求开始"></a>网络请求开始</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)GET:(<span class="hljs-built_in">NSString</span> *)URLString<br>                   parameters:(<span class="hljs-type">id</span>)parameters<br>                     progress:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> * _Nonnull))downloadProgress<br>                      success:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="hljs-type">id</span> _Nullable))success<br>                      failure:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDataTask</span> * _Nullable, <span class="hljs-built_in">NSError</span> * _Nonnull))failure<br>&#123;<br><br>    <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask = [<span class="hljs-keyword">self</span> dataTaskWithHTTPMethod:<span class="hljs-string">@&quot;GET&quot;</span><br>                                                        URLString:URLString<br>                                                       parameters:parameters<br>                                                   uploadProgress:<span class="hljs-literal">nil</span><br>                                                 downloadProgress:downloadProgress<br>                                                          success:success<br>                                                          failure:failure];<br><br>    [dataTask resume];<br><br>    <span class="hljs-keyword">return</span> dataTask;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 NSURLSessionTask 创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用 resume方法，NSURLSessionTask 才会开始执行。</p><h2 id="网络请求回调"><a href="#网络请求回调" class="headerlink" title="网络请求回调"></a>网络请求回调</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled5.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled6.webp" class="" title="This is an example image"><p>AFN 里面有关 NSURLSessionDelegate 的回调方法非常的多，这里我们只调和<br> NSURLSessionTask 相关的部分方法和 KVO 处理来进行说明，其他的大家可以参考源码细看。</p><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled7.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled8.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled9.webp" class="" title="This is an example image"><p>对于我们的 Get 请求来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//KVO监听的属性值发生变化</span><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *,<span class="hljs-type">id</span>&gt; *)change context:(<span class="hljs-type">void</span> *)context &#123;<br>    <span class="hljs-keyword">if</span> ([object isKindOfClass:[<span class="hljs-built_in">NSURLSessionTask</span> <span class="hljs-keyword">class</span>]] || [object isKindOfClass:[<span class="hljs-built_in">NSURLSessionDownloadTask</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesReceived))]) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesReceived&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中已经收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToReceive&quot;</span>);<br><span class="hljs-comment">//这个是在Get请求下，网络响应过程中期待收到的数据量</span><br>            <span class="hljs-keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待收到</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesSent))]) &#123;<br>             <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesSent&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//已经发送</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;<br>              <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;countOfBytesExpectedToSend&quot;</span>);<br>            <span class="hljs-keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<span class="hljs-comment">//期待发送</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.downloadProgress]) &#123;<br>        <span class="hljs-comment">//下载进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.downloadProgressBlock(object);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.uploadProgress]) &#123;<br>        <span class="hljs-comment">//上传进度变化</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.uploadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.uploadProgressBlock(object);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//收到请求响应</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>          dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;收到请求响应&quot;</span>);<br>    <span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionResponseAllow</span>;<span class="hljs-comment">//允许继续加载</span><br><br><span class="hljs-comment">//是否有收到请求响应的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        disposition = <span class="hljs-keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);<br>    &#125;<br><span class="hljs-comment">//是否有请求响应完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br><span class="hljs-comment">//若有调用该Block</span><br>        completionHandler(disposition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//请求完成</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;请求完成&quot;</span>);<br><span class="hljs-comment">//取出该NSURLSessionTask的代理对象</span><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br><br>    <span class="hljs-comment">// delegate may be nil when completing a task in the background</span><br>    <span class="hljs-keyword">if</span> (delegate) &#123;<br><span class="hljs-comment">//若是该代理对象存在，那么将对应数据转给该代理对象处理</span><br>        [delegate URLSession:session task:task didCompleteWithError:error];<br><span class="hljs-comment">//NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象</span><br>        [<span class="hljs-keyword">self</span> removeDelegateForTask:task];<br>    &#125;<br><span class="hljs-comment">//是否有请求完成的回调Block</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidComplete) &#123;<br><span class="hljs-comment">//若有调用改Block</span><br>        <span class="hljs-keyword">self</span>.taskDidComplete(session, task, error);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为在配置 NSURLSessionDataTask 对象的时候我们有给 NSURLSessionTask 做了一系列配置，那么当 NSURLSessionDataTask 任务完成之后，我们需要将该 NSURLSessionDataTask 的一系列配置全部清理掉。</p><p>这个是我们的配置过程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//通过task的标识符管理代理</span><br>- (<span class="hljs-type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [delegate setupProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//给task移除delegate</span><br>- (<span class="hljs-type">void</span>)removeDelegateForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task &#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    [delegate cleanUpProgressForTask:task];<br>    [<span class="hljs-keyword">self</span> removeNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled10.webp" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled11.webp" class="" title="This is an example image"><h2 id="关于-Post-请求"><a href="#关于-Post-请求" class="headerlink" title="关于 Post 请求"></a>关于 Post 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled12.webp" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - AFURLRequestSerialization</span><br><span class="hljs-comment">//设置Header和请求参数</span><br>- (<span class="hljs-built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                               withParameters:(<span class="hljs-type">id</span>)parameters<br>                                        error:(<span class="hljs-built_in">NSError</span> *__autoreleasing *)error<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(request);<br><br>    <span class="hljs-built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];<br>    [<span class="hljs-keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-type">id</span> field, <span class="hljs-type">id</span> value, <span class="hljs-type">BOOL</span> * __unused stop) &#123;<br>        <span class="hljs-comment">//判断header的field是否存在,如果不存在则设置，存在则跳过</span><br>        <span class="hljs-keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;<br>            <span class="hljs-comment">//设置 header</span><br>            [mutableRequest setValue:value forHTTPHeaderField:field];<br>        &#125;<br>    &#125;];<br><br>    <span class="hljs-built_in">NSString</span> *query = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (parameters) &#123;<br>        <span class="hljs-comment">//用传进来的自定义block格式化请求参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.queryStringSerialization) &#123;<br>            <span class="hljs-built_in">NSError</span> *serializationError;<br>            query = <span class="hljs-keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);<br>            <span class="hljs-keyword">if</span> (serializationError) &#123;<br>                <span class="hljs-keyword">if</span> (error) &#123;<br>                    *error = serializationError;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.queryStringSerializationStyle) &#123;<br>                <span class="hljs-keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:<br>                    <span class="hljs-comment">//默认的格式化方式</span><br>                    query = AFQueryStringFromParameters(parameters);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;<br>       <span class="hljs-comment">//判断是否有参数</span><br>        <span class="hljs-keyword">if</span> (query &amp;&amp; query.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//拼接请求参数</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;query--&gt;%@&quot;</span>,query);<br>            mutableRequest.URL = [<span class="hljs-built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="hljs-string">@&quot;&amp;%@&quot;</span> : <span class="hljs-string">@&quot;?%@&quot;</span>, query]];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span><br>        <span class="hljs-keyword">if</span> (!query) &#123;<br>            query = <span class="hljs-string">@&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//参数带在body上，大多是POST PUT</span><br>        <span class="hljs-keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>]) &#123;<br>            <span class="hljs-comment">//设置Content-Type HTTP头，告诉服务端body的参数编码类型</span><br>            [mutableRequest setValue:<span class="hljs-string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>];<br>        &#125;<br>        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="hljs-keyword">self</span>.stringEncoding]];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mutableRequest;<br>&#125; <br></code></pre></td></tr></table></figure><p>如果是 Post 请求，那么请求参数是没有拼接在 URL 上面，而是放在 body 上，这个是 Post 和 Get 请求的最大区别了，其他过程和 Get 请求并没有太多区别。</p><h2 id="关于-HTTPS-请求"><a href="#关于-HTTPS-请求" class="headerlink" title="关于 HTTPS 请求"></a>关于 HTTPS 请求</h2><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled13.png" class="" title="This is an example image"><img src="/2016/07/31/reading-source-code-of-AFNetworking/Untitled14.png" class="" title="This is an example image"><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Http认证处理</span><br><span class="hljs-comment">//认证处理</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *http://www.cnblogs.com/polobymulberry/p/5140806.html</span><br><span class="hljs-comment"> *web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。</span><br><span class="hljs-comment"> *这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</span><br><span class="hljs-comment"> *接收到挑战后，</span><br><span class="hljs-comment"> *客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential</span><br><span class="hljs-comment"> *（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。</span><br><span class="hljs-comment"> *最后调用completionHandler回应服务器端的挑战。</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-comment">//NSURLAuthenticationChallenge 挑战处理类型为 默认</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="hljs-comment">     *NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">//自定义方法，用来如何应对服务器端的认证挑战</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//服务端要求客户端提供证书</span><br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-comment">//客户端评估服务端的安全性</span><br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                <span class="hljs-comment">//客户端产生证书</span><br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>                <span class="hljs-keyword">if</span> (credential) &#123;<br>                    <span class="hljs-comment">//使用指定的证书</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//默认处理</span><br>                    disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//不处理服务端的认证要求</span><br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//如果没有实现方法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *- (void)URLSession:(NSURLSession *)session</span><br><span class="hljs-comment"> *didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="hljs-comment"> *completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//那么URLSession会调用下面的方法进入认证处理</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br> completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler<br>&#123;<br>    <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>    __block <span class="hljs-built_in">NSURLCredential</span> *credential = <span class="hljs-literal">nil</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;<br>        disposition = <span class="hljs-keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="hljs-built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;<br>            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeUseCredential</span>;<br>                credential = [<span class="hljs-built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                disposition = <span class="hljs-built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            disposition = <span class="hljs-built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (completionHandler) &#123;<br>        completionHandler(disposition, credential);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是 HTTPS 请求的话，那么会先走上面的2个代理方法进行 HTTPS 认证，之后继续其他操作。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AFN 发起 Get 请求主要分为以下步骤：<br>1.创建 NSURLSessionDataTask<br>2.配置 NSURLSessionDataTask<br>3.设置 NSURLSessionDataTask 的 Delegate<br>4.调用 NSURLSessionDataTask 的 resume 方法开始请求<br>5.在 Delegate 的方法里面处理网络请求的各个过程<br>6.清理 NSURLSessionDataTask 的配置<br>其实也就是使用 NSURLSessionDataTask 的步骤，AFN 在这几个步骤加了一些封装，让整个请求过程更加好用，易用。</p><p>对于 AFN 这类几乎是 iOS 开发网络库标配的开源项目来说，肯定已经有许多非常优秀的源码解析文章了。所以这篇文章是着重讲解和介绍 AFN 的整个网络请求的处理流程而且很多的技术细节。相信如果对流程熟悉的话，那么要想找对应的细节处理过程也就比较简单的，再配合一些调试手段的话，基本上对于 AFN 的细节处理的理解也就不再话下了。由于个人水平有限，文章有不对之处恳请指出，我稍作修改，大家共同进步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://blog.cnbang.net/tech/2320/">http://blog.cnbang.net/tech/2320/</a><br><a href="http://blog.cnbang.net/tech/2371/">http://blog.cnbang.net/tech/2371/</a><br><a href="http://blog.cnbang.net/tech/2416/">http://blog.cnbang.net/tech/2416/</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a><br><a href="http://bugly.qq.com/bbs/forum.php">http://bugly.qq.com/bbs/forum.php</a>?<br><a href="http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6">http://www.guokr.com/post/114121/mod=viewthread&amp;tid=417&amp;fromuid=6</a><br><a href="http://www.guokr.com/post/116169/">http://www.guokr.com/post/116169/</a><br><a href="http://www.guokr.com/blog/148613/">http://www.guokr.com/blog/148613/</a><br><a href="http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html">http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html</a><br><a href="http://www.cnblogs.com/polobymulberry/p/5140806.html">http://www.cnblogs.com/polobymulberry/p/5140806.html</a><br><a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">https://github.com/AFNetworking/AFNetworking/tree/3.1.0</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 图片加载框架－SDWebImage 解读</title>
    <link href="/2016/03/09/reading-source-code-of-SDWebImage/"/>
    <url>/2016/03/09/reading-source-code-of-SDWebImage/</url>
    
    <content type="html"><![CDATA[<h1 id="SDWebImage-解读"><a href="#SDWebImage-解读" class="headerlink" title="SDWebImage 解读"></a>SDWebImage 解读</h1><p>在 iOS 的图片加载框架中，<a href="https://github.com/rs/SDWebImage">SDWebImage</a> 可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的 UIImageView 控件或者 UIButton 控件。在项目中使用 SDWebImage 来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。</p><h2 id="SDWebImage-概论"><a href="#SDWebImage-概论" class="headerlink" title="SDWebImage 概论"></a>SDWebImage 概论</h2><p>1.提供了一个 UIImageView 的 category 用来加载网络图片并且对网络图片的缓存进行管理<br>2.采用异步方式来下载网络图片<br>3.采用异步方式，使用 memory＋disk 来缓存网络图片，自动管理缓存。<br>4.支持 GIF 动画<br>5.支持 WebP 格式<br>6.同一个 URL 的网络图片不会被重复下载<br>7.失效的 URL 不会被无限重试<br>8.耗时操作都在子线程，确保不会阻塞主线程<br>9.使用 GCD 和 ARC<br>10.支持 Arm64</p><h2 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h2><p>1.使用 ImageView+WebCache category 来加载 UITableView 中 cell 的图片</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>]];<br></code></pre></td></tr></table></figure><p>2.使用 block,采用这个方案可以在网络图片加载过程中得知图片的下载进度和图片加载成功与否</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[cell.imageView sd_setImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;http://www.domain.com/path/to/image.jpg&quot;</span>] placeholderImage:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;placeholder.png&quot;</span>] completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="hljs-built_in">NSURL</span> *imageURL) &#123;<br>    <span class="hljs-comment">//... completion code here ... </span><br> &#125;];<br></code></pre></td></tr></table></figure><p>3.使用 SDWebImageManager,SDWebImageManager 为UIImageView+WebCache category 的实现提供接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">SDWebImageManager *manager = [SDWebImageManager sharedManager] ;<br>[manager downloadImageWithURL:imageURL options:<span class="hljs-number">0</span> progress:^(<span class="hljs-built_in">NSInteger</span>   receivedSize, <span class="hljs-built_in">NSInteger</span> expectedSize) &#123; <br>      <span class="hljs-comment">// progression tracking code</span><br> &#125;  completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType,   <span class="hljs-type">BOOL</span> finished, <span class="hljs-built_in">NSURL</span> *imageURL) &#123; <br>   <span class="hljs-keyword">if</span> (image) &#123; <br>    <span class="hljs-comment">// do something with image</span><br>   &#125;<br> &#125;];<br></code></pre></td></tr></table></figure><p>4.加载图片还有使用 SDWebImageDownloader 和 SDImageCache 方式，但那个并不是我们经常用到的。基本上面所讲的3个方法都能满足需求。</p><h2 id="SDWebImage-流程"><a href="#SDWebImage-流程" class="headerlink" title="SDWebImage 流程"></a>SDWebImage 流程</h2><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled.webp" class="" title="This is an example image"><h2 id="SDWebImage-接口"><a href="#SDWebImage-接口" class="headerlink" title="SDWebImage 接口"></a>SDWebImage 接口</h2><p>SDWebImage 是一个成熟而且比较庞大的框架，但是在使用过程中并不需要太多的接口,这算是一种代码封装程度的体现。这里就介绍比较常用的几个接口。</p><ol><li>给 UIImageView 设置图片的接口，SDWebImage 有提供多个给UIImageView 设置图片的接口，最终所有的接口都会调用下图的这个接口，这是大多数框架的做法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled1.webp" class="" title="This is an example image"><ol start="2"><li><p>获取 SDWebImage 的磁盘缓存大小,在项目中有时候会需要统计应用的磁盘缓存内容大小，那么获取图片的缓存大小就是使用这个接口来实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[SDImageCache sharedImageCache] getSize];<br></code></pre></td></tr></table></figure></li><li><p>清理内存缓存，清理内存中缓存的图片资源，释放内存资源。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearMemory];<br></code></pre></td></tr></table></figure></li><li><p>有了清理内存缓存，自然也有清理磁盘缓存的接口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[SDImageCache sharedImageCache] clearDisk];<br></code></pre></td></tr></table></figure></li></ol><h2 id="SDWebImage-解析"><a href="#SDWebImage-解析" class="headerlink" title="SDWebImage 解析"></a>SDWebImage 解析</h2><p>解析主要围绕着 SDWebImage 的图片加载流程来分析，介绍SDWebImage 这个框架加载图片过程中的一些处理方法和设计思路。</p><ol><li>给 UIImageView 设置图片，然后 SDWebImage 调用这个最终的图片加载方法。</li></ol><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled2.webp" class="" title="This is an example image"><ol start="2"><li>开始加载之前图片先取消对应的 UIImageView 先前的图片下载操作。试想，如果我们给 UIImageView 设置了一张新的图片，那么我们还会在意该 UIImageVIew 先前是要加载哪一张图片么？应该是不在意的吧！那是不是应该尝试把该 UIImageView 先前的加载图片相关操作给取消掉呢?</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> sd_cancelCurrentImageLoad]<br></code></pre></td></tr></table></figure><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled3.webp" class="" title="This is an example image"><p>该方法经过周转，最后调用了以下方法，框架将图片对应的下载操作放到 UIView 的一个自定义字典属性 (operationDictionary) 中，取消下载操作第一步也是从这个 UIView 的自定义字典属性 (operationDictionary)中取出所有的下载操作，然后依次调用取消方法，最后将取消的操作从(operationDictionary) 字典属性中移除。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled4.webp" class="" title="This is an example image"><p>3.移除之前没用的图片下载操作之后就创建一个新的图片下载操作，然后设置到 UIView 的一个自定义字典属性 (operationDictionary) 中。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled5.webp" class="" title="This is an example image"><p>4.看看如何创建一个新的图片下载操作,框架保存了一个失效的 url 列表，如果 url 失效了就会被加入这个列表，保证不会重复多次请求失效的 url。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled6.webp" class="" title="This is an example image"><p>根据给定的 url 生成一个唯一的 key ,之后利用这个 key 到缓存中查找对应的图片缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled7.webp" class="" title="This is an example image"><p>5.读取图片缓存,根据 key 先从内存中读取图片缓存，若没有命中内存缓存则读取磁盘缓存，如果磁盘缓存命中，那么将磁盘缓存读到内存中成为内存缓存。如果都没有命中缓存的话，那么就在执行的 doneBlock中开始下载图片。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled8.webp" class="" title="This is an example image"><p>6.图片下载操作完成后会将图片对应的数据通过 completedBlock 进行回调</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled9.webp" class="" title="This is an example image"><p>在图片下载方法中，调用了一个方法用于添加创建和下载过程中的各类block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled10.webp" class="" title="This is an example image"><p>添加该 url 加载过程的状态回调 block<br> <img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled11.webp" class="" title="This is an example image"></p><p>如果该 url 是第一次加载的话，那么就会执行 createCallback 这个回调block ,然后在 createCallback 里面开始构建网络请求，在下载过程中执行各类进度 block 回调。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled12.webp" class="" title="This is an example image"><p>7.当图片下载完成之后会回到 done 的 block 回调中做图片转换处理和缓存操作</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled13.webp" class="" title="This is an example image"><p>回到 UIImageView 控件的设置图片方法 block 回调中，给对应的UIImageView 设置图片，操作流程到此完成。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled14.webp" class="" title="This is an example image"><p> 8.304 的处理<br>SDWebImage在加载图片网络请求的 NSURLConnection 的代理中对httpCode 做了判断，当 httpCode 为 304 的时候放弃下载，读取缓存。</p><img src="/2016/03/09/reading-source-code-of-SDWebImage/Untitled15.webp" class="" title="This is an example image"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SDWebImage 作为一个优秀的图片加载框架，提供的使用方法和接口对开发者来说非常友好。其内部实现多是采用 block 的方式来实现回调，代码阅读起来可能没有那么直观。此文章旨在给大家讲解 SDWebImage 这个框架的图片大概加载流程，其中具体细节限于篇幅无法详细深究。能力有限，文章中难免有错误，若大家在阅读过程中有发现不合理或者错误的地方恳请在评论中指出，我会在第一时间进行修正,不胜感激。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>注释项目 <a href="https://github.com/junbinchencn/SDWebImage">https://github.com/junbinchencn/SDWebImage</a></li><li><a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS缓存框架－PINCache 解读</title>
    <link href="/2016/01/13/reading-source-code-of-PINCache/"/>
    <url>/2016/01/13/reading-source-code-of-PINCache/</url>
    
    <content type="html"><![CDATA[<h1 id="PINCache-解读"><a href="#PINCache-解读" class="headerlink" title="PINCache 解读"></a>PINCache 解读</h1><p>在项目中总是需要缓存一些网络请求数据以减轻服务器压力，业内也有许多优秀的开源的解决方案。通常的缓存方案都是由内存缓存和磁盘缓存组成的，内存缓存速度快容量小，磁盘缓存容量大速度慢可持久化。常见的内存缓存有 NSCache、<a href="https://github.com/tumblr/TMCache">TMMemoryCache</a>、<a href="https://github.com/pinterest/PINCache">PINMemoryCache</a>、<a href="https://github.com/ibireme/YYCache">YYMemoryCache</a>。常见的磁盘缓存有 TMDiskCache、PINDiskCache、SDWebImage。这次解读先从<a href="https://github.com/pinterest/PINCache">PINCache</a> 这个优秀的开源项目开始。PINCache 项目是在 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的基于 TMCache 的一个内存缓存，修复了 TMCache 存在的性能和死锁问题，可以说是有了一个较大的提升。</p><h3 id="PINCache-概论"><a href="#PINCache-概论" class="headerlink" title="PINCache 概论"></a>PINCache 概论</h3><p>PINCache 是多线程安全的，使用键值对来保存数据。PINCache 内部包含了 2 个类似的对象属性，一个是内存缓存 PINMemoryCache，另一个是磁盘缓存 PINDiskCache。PINCache 本身并没有过多的做处理缓存的具体工作，而是全部交给它内部的2个对象属性来实现，它只是对外提供了一些同步或者异步接口。在 iOS 中，当 App 收到内存警告或者进入后台的时候，PINCache 能够清理掉所有的内存缓存。</p><h3 id="PINCache-使用"><a href="#PINCache-使用" class="headerlink" title="PINCache 使用"></a>PINCache 使用</h3><p>采用 PINCache 项目的 Demo 来说明，这个是从服务器加载数据，再缓存下来，继而做业务逻辑处理，如果下次还需要同样的数据，要是缓存里面还有这个数据的话，那么就不需要再次发起网络请求了，而是直接使用这个数据。<strong>PINCache除了可以按键取值、按键存值、按键删值之外，还可以移除某个日期之前的缓存数据、删除所有缓存、限制缓存大小，限制缓存对象的存活时间等</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP">[[PINCache sharedCache] objectForKey:[url absoluteString]  block:^(PINCache *cache, NSString *key, id object) &#123;<br>                                     <span class="hljs-keyword">if</span> (object) &#123;<br>                                      <span class="hljs-comment">//有缓存，在这里做业务逻辑处理</span><br>                                         <span class="hljs-keyword">return</span>;<br>                                     &#125; <br>                                     <span class="hljs-comment">//没有缓存，那么去服务器加载数据，存入缓存，做业务逻辑处理</span><br>                                    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;cache miss, requesting %@&quot;</span>, url);<br>                                   [[PINCache sharedCache] setObject:data forKey:[url absoluteString]];<br>   &#125;];<br></code></pre></td></tr></table></figure><h3 id="PINCache-结构"><a href="#PINCache-结构" class="headerlink" title="PINCache 结构"></a>PINCache 结构</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled.webp" class="" title="This is an example image"><p>PINCache 的内部结构比较简单，最核心的就是 2 个缓存实现类，这里先给出一个大概的结构，让大家可以有个了解，下面就来讲讲详细的接口。</p><h3 id="PINCache-接口"><a href="#PINCache-接口" class="headerlink" title="PINCache 接口"></a>PINCache 接口</h3><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled1.webp" class="" title="This is an example image"><p><strong>核心属性</strong><br>1.name 是 PINCache 的名字<br>2.concurrentQueue 是一个用来执行异步任务的并行队列<br>3.磁盘缓存<br>4.内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled2.webp" class="" title="This is an example image"><p><strong>初始化方法</strong><br>1.单例对象<br>2.使用名字初始化<br>3.使用名字和缓存路径来初始化</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled3.webp" class="" title="This is an example image"><p><strong>异步方法</strong><br>多数开源缓存框架的方法也就这么几个，大多类似。<br>1.异步按键取值，之后执行 Block<br>2.异步按键设值，之后执行 Block<br>3.异步按键删值，之后执行 Block<br>4.异步删除某个时间之后没有使用的缓存，之后执行 Block<br>5.异步删除所有缓存，之后执行 Block</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled4.webp" class="" title="This is an example image"><p><strong>同步方法</strong><br>这里的同步方法与异步方法的区别除了方法是否立即返回之外，还有一个区别就是异步方法可以传入一个 Block 参数<br>1.同步按键取值<br>2.同步按键设值<br>3.同步按键删值<br>4.同步删除某个时间之后没有使用的缓存<br>5.同步删除所有缓存</p><p><strong>PINCache 主要是包装 PINDiskCache 和 PINMemoryCache 的功能，具体的功能实现是交给对应的对象去实现</strong>。</p><p>###PINDiskCache 解析<br>PINDiskCache 涉及到磁盘缓存的具体实现，这里就不再一一列举所有的属性和方法了（具体的内容可以查看 PINCache 的文档），主要挑重要的取值方法，设值方法，还有删除方法来讲。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled5.webp" class="" title="This is an example image"><p>PINDiskCache 使用 semaphore 来做线程同步控制的，在写磁盘缓存的时候给 diskCache 对象加锁，写完之后解锁。在读磁盘缓存的时候也会给 diskCache 对象加锁，读完之后解锁。<em>读写过程都会加锁</em>。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled6.webp" class="" title="This is an example image"><p>写磁盘缓存的大概步骤是这样的，只是讲解一些思路，具体的详细信息需要大家查看源代码。<br>1.判断给的键值是否为空<br>2.加锁，保证多线程安全<br>3.把数据写入磁盘<br>4.更新缓存信息（包括但不限于保存磁盘缓存的总容量）<br>5.判断现在的磁盘缓存容量是否超过容量限制，若超出，按照缓存时间策略来删除对应的缓存，没有超过则不做操作<br>6.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled7.webp" class="" title="This is an example image"><p>读磁盘缓存相对简单一些，就是找到文件，然后读取。<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把数据从磁盘读到内存对象中<br>4.解锁，让其他线程可以进入操作</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled8.webp" class="" title="This is an example image"><p>移除缓存就是文件的删除操作<br>1.判断给的键是否为空<br>2.加锁，保证多线程安全<br>3.把文件从磁盘中删除<br>4.解锁，让其他线程可以进入操作</p><h3 id="PINMemoryCache-解析"><a href="#PINMemoryCache-解析" class="headerlink" title="PINMemoryCache 解析"></a>PINMemoryCache 解析</h3><p>内存缓存相比磁盘缓存多了一个 App 收到内存警告或者 App 进入后台的时候清理缓存的功能。内存缓存的数据保存在字典里面。</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled9.webp" class="" title="This is an example image"><p>1.收到系统内存警告通知，清理内存缓存<br>2.收到App进入后台的系统通知,清理内存缓存</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled10.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.将数据存到缓存池，也就是字典里面<br>4.更新缓存对应的数据<br>5.解锁<br>6.判断内存缓存容量是否超出，超过删除部分</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled11.webp" class="" title="This is an example image"><p>1.判断键值是否为空<br>2.加锁，保证多线程安全<br>3.从字典里面取对应值<br>4.更新缓存对应的数据<br>5.解锁</p><img src="/2016/01/13/reading-source-code-of-PINCache/Untitled12.webp" class="" title="This is an example image"><p>1.取出内存缓存值<br>2.加锁<br>3.更新内存缓存容量<br>4.删除内存缓存<br>5.更新内存缓存对应的数据<br>6.解锁</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存一般有 2 个部分组成，一个是内存缓存，一个是磁盘缓存。<br>1.对于<strong>内存缓存</strong>来说，一般使用字典来作为数据的缓存池，配合一个保存每个内存缓存数据的缓存时间的字典，一个保存每个内存缓存数据的缓存容量的字典，一个保存内存缓存总容量的变量。对于增删改查操作，基本也都是围绕着字典来的，需要重点注意的就是在这些个操作过程的多线程安全问题，还有同步和异步访问方法，以及异步方法中的 Block 参数的循环引用问题。<br>2.对于<strong>磁盘缓存</strong>来说，使用文件系统来保存缓存数据，配合设置文件的参数，比如文件的修改日期（访问一次即修改一次），文件的大小来管理着这个缓存数据。对缓存数据的增删改查，也就是转化成为对文件的读写删除操作。<br>3.不管是内存缓存还是磁盘缓存，在删除超过限制容量的缓存的时候总是有一个同样的策略。有优先删除缓存最久，最少使用的策略，也有优先删除，容量最大，最少使用的策略。没有什么最好的策略，只有适合你业务产品的策略。<br>最后感谢<a href="https://github.com/pinterest">PINCache的作者们</a>给我们提供了一个优秀的缓存开源框架。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="http://blog.ibireme.com/2015/10/26/yycache/">http://blog.ibireme.com/2015/10/26/yycache/</a><br><a href="https://github.com/pinterest/PINCache">https://github.com/pinterest/PINCache</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>源码解读</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
